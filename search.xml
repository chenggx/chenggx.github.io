<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Laravel学习笔记</title>
      <link href="/2019/06/18/laravel-xue-xi-bi-ji/"/>
      <url>/2019/06/18/laravel-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="第一步：了解几个常用名称"><a href="#第一步：了解几个常用名称" class="headerlink" title="第一步：了解几个常用名称"></a>第一步：了解几个常用名称</h2><blockquote><p>Service Container、Service Provider、Facades、Contracts。当第一次使用 Laravel 框架的时候被这几个词直接搞蒙圈了，完全不知道是什么意思，尤其是在看完文档之后，真的想说 WTF 。不过不知道也不会太影响使用。（😅有个朋友说过，不管用着在 NB 的框架，依然可以写出屎一样的代码）</p></blockquote><h3 id="Service-Container"><a href="#Service-Container" class="headerlink" title="Service Container"></a>Service Container</h3><p>中文解释：服务容器 （😂 是不是看完这个翻译更不知道是啥了）</p><p>我的理解：一个装着各种各样的服务实例的容器。这些服务就是 Laravel 中的各种模块，如 Redis、Route 等等。</p><p>实现一个简单的容器：</p><pre class=" language-php"><code class="language-php"><span class="token keyword">class</span> <span class="token class-name">Container</span><span class="token punctuation">{</span>  <span class="token keyword">protected</span> <span class="token variable">$binds</span><span class="token punctuation">;</span>  <span class="token keyword">protected</span> <span class="token variable">$instances</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token variable">$abstract</span><span class="token punctuation">,</span> <span class="token variable">$concrete</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//Todo: 向 container 添加一种对象的的生产方式</span>    <span class="token comment" spellcheck="true">//$abstract: 第一个参数 $abstract, 一般为一个字符串(有时候也会是一个接口), 当你需要 make 这个类的对象的时候, 传入这个字符串(或者接口), 这样make 就知道制造什么样的对象了</span>    <span class="token comment" spellcheck="true">//$concrete: 第二个参数 $concrete, 一般为一个 Closure 或者 一个单例对象, 用于说明制造这个对象的方式</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$concrete</span> <span class="token keyword">instanceof</span> <span class="token class-name">Closure</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">binds</span><span class="token punctuation">[</span><span class="token variable">$abstract</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$concrete</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">instances</span><span class="token punctuation">[</span><span class="token variable">$abstract</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$concrete</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token variable">$abstract</span><span class="token punctuation">,</span> <span class="token variable">$parameters</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//Todo: 生产一种对象</span>    <span class="token comment" spellcheck="true">//$abstract: 在bind方法中已经介绍过</span>    <span class="token comment" spellcheck="true">//$parameters: 生产这种对象所需要的参数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">instances</span><span class="token punctuation">[</span><span class="token variable">$abstract</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">instances</span><span class="token punctuation">[</span><span class="token variable">$abstract</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">array_unshift</span><span class="token punctuation">(</span><span class="token variable">$parameters</span><span class="token punctuation">,</span> <span class="token variable">$this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">call_user_func_array</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">binds</span><span class="token punctuation">[</span><span class="token variable">$abstract</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token variable">$parameters</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="为什么理解-IOC-Container-对于理解-Laravel-架构是如此的重要？"><a href="#为什么理解-IOC-Container-对于理解-Laravel-架构是如此的重要？" class="headerlink" title="为什么理解 IOC Container 对于理解 Laravel 架构是如此的重要？"></a>为什么理解 IOC Container 对于理解 Laravel 架构是如此的重要？</h4><blockquote><p>因为在 Laravel 中，你所能使用到的 Laravel 的特性和功能几乎全部是由 IOC Container 实现的。</p></blockquote><pre class=" language-php"><code class="language-php">Cache<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> Route<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token string">'HomeController@index'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面的 Cache、Route 都是通过把各自类的实现 bind 到 Container 中，然后 Container make 出的一个实例。<br>那么它们是在哪里进行的 bind 呢？没错就是 Service Provider 中。</p><h3 id="Service-Provider"><a href="#Service-Provider" class="headerlink" title="Service Provider"></a>Service Provider</h3><p>在 Laravel 中有两种方式来使用 IOC Container：</p><ol><li>通过 Service Provider</li><li>不通过 Service Provider<blockquote><p>一般情况都是使用第一种方式。</p></blockquote></li></ol><h4 id="不通过-Service-Provider-来使用-IOC-Container"><a href="#不通过-Service-Provider-来使用-IOC-Container" class="headerlink" title="不通过 Service Provider 来使用 IOC Container"></a>不通过 Service Provider 来使用 IOC Container</h4><p>实例：</p><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">//web.php</span><span class="token comment" spellcheck="true">//创建一个类</span><span class="token keyword">class</span> <span class="token class-name">Apple</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token variable">$id</span> <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Route<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//使用 app() 辅助方法将 Apple 类 bind 到 IOC Container 中  </span>  App<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Apple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//使用 App() 辅助方法将 Apple 实例 make 出来</span>  <span class="token variable">$apple</span> <span class="token operator">=</span> App<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//使用 Apple 类中的属性</span>  <span class="token keyword">return</span> <span class="token variable">$apple</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">id</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="通过-Service-Provider-来使用-IOC-Container"><a href="#通过-Service-Provider-来使用-IOC-Container" class="headerlink" title="通过 Service Provider 来使用 IOC Container"></a>通过 Service Provider 来使用 IOC Container</h4><blockquote><p>原因：我们知道，有时候我们的类、模块会有需要其他类和组件的情况，为了保证初始化阶段不会出现所需要的模块和组件没有注册的情况，laravel 将注册和初始化行为进行拆分，注册的时候就只能注册，初始化的时候就是初始化。拆分后的产物就是现在的 服务提供者。<br>可以想象这样一个场景，你要绑定 3 个类 A B C 到 IOC Container 中。 A，B，C 都是非常复杂的类。在 bind A 时，引用了一个类 B 的实例，那么想要获得类 B 的实例，就需要 B 已经被 bind，只有这样，我们的 IOC Container 才有能力 make 出一个 B 的实例。 而在 bind B 时，恰好又需要 C 的实例.<br>如果是这样的逻辑，那么在 bind A B C 时，就必须手动的严格安排 bind 的次序，而且这只是 3 个类的情况，如果有几十个类的话，人工已经无法完成了.<br>而这时就需要 Service Provider 的作用了。</p><blockquote><p>引用自——<a href="https://learnku.com/laravel/t/3361/starting-with-the-1-line-of-code-with-a-systematic-understanding-of-the-core-concepts-of-service-container#e9b441" target="_blank" rel="noopener">从 1 行代码开始，带你系统性地理解 Service Container 核心概念</a></p></blockquote></blockquote><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token comment" spellcheck="true">// 1. 创建一个 Apple 类 app/Test/Apple.php</span><span class="token keyword">namespace</span> <span class="token package">App<span class="token punctuation">\</span>Test</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Apple</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token variable">$id</span> <span class="token operator">=</span> <span class="token string">'agg'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//2. 使用 php artisan make:provider AppleProvider 生成 provider</span><span class="token keyword">namespace</span> <span class="token package">App<span class="token punctuation">\</span>Providers</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token package">Illuminate<span class="token punctuation">\</span>Support<span class="token punctuation">\</span>ServiceProvider</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token package">App<span class="token punctuation">\</span>Test<span class="token punctuation">\</span>Apple</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">AppleProvider</span> <span class="token keyword">extends</span> <span class="token class-name">ServiceProvider</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * Register services.     *     * @return void     */</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">register</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">app</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">singleton</span><span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token variable">$app</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Apple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Bootstrap services.     *     * @return void     */</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">boot</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 3. 在 config/app.php 中注册 APPServiceProvider</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token string">'providers'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    App\<span class="token package">Providers<span class="token punctuation">\</span>AppleProvider</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">class</span><span class="token punctuation">,</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment" spellcheck="true">// 4. 最终在 route/web.php 中使用</span>Route<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">app</span><span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">app</span><span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*输出结果，因为使用了单例的模式进行绑定所以输出的两个实例的编号是一致的object(App\Test\Apple)#206 (1) { ["id"]=> string(3) "agg" } object(App\Test\Apple)#206 (1) { ["id"]=> string(3) "agg" }*/</span></code></pre><h3 id="Facades"><a href="#Facades" class="headerlink" title="Facades"></a>Facades</h3><pre class=" language-php"><code class="language-php">Route<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token string">'HomeController@index'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>想必大家在第一使用 Laravel 的时候一定会注意到这行代码。在使用 phpStorm 之类的 IDE 工具是无法跳转到对应的类文件。那么这是为啥呢？</p></blockquote><p>你是无法找到对 Route 类的声明的，是因为使用了别名。别名是 PHP 的一个特性（ <a href="https://www.php.net/manual/zh/function.class-alias.php" target="_blank" rel="noopener">class_alias</a> 方法 ）。</p><p>别名在哪里设置呢——app/config/app.php</p><pre class=" language-php"><code class="language-php"><span class="token string">'aliases'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token string">'Route'</span> <span class="token operator">=</span><span class="token operator">></span> Illuminate\<span class="token package">Support<span class="token punctuation">\</span>Facades<span class="token punctuation">\</span>Route</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">class</span><span class="token punctuation">,</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> laravel </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网易云音乐评论摘录</title>
      <link href="/2019/05/28/wang-yi-yun-yin-le-ping-lun-zhai-lu/"/>
      <url>/2019/05/28/wang-yi-yun-yin-le-ping-lun-zhai-lu/</url>
      
        <content type="html"><![CDATA[<p>网易云音乐里有才的人实在太多，写出来的歌词或评论是真的不错。这里就把我觉得还不错的收藏一波吧（不定期更新）。</p><h2 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h2><blockquote><p>人会长大三次：<br>第一次是在发现自己不是世界的中心的时候。<br>第二次是在发现即使在怎么努力，终究还是有些事令人无能为力的时候。<br>第三次是在，明知道有些事可能会无能为力，但还是会尽力争取的时候。<br>————《一如少年模样》</p></blockquote><blockquote><p>白天要好好读书 书里有您不知道的<br>夜里要好好睡觉 梦里有你想要的<br>————《他》</p></blockquote><blockquote><p>你哭的最伤心的那个晚上变成大人了么？不是，是我忍住没哭的那个晚上。<br>————林宥嘉《天真有邪》</p></blockquote><blockquote><p>小时候，把一片口香糖掰成两块儿，很舍不得吃。那时候就天真的想，等我长大了，有钱了，就一口气嚼一包！一定特别甜！今天突然想到了儿时的这个梦想，就买了一包，当我把口香糖一片片塞进嘴里的时候，我的眼泪夺目而出。。。我哽咽着大口的嚼着。。。心里却满是酸楚，我想，这时光一点也不甜。。。<br>————周传雄《黄昏》 </p></blockquote><blockquote><p>爱上一个人，始于颜值，陷于才华，忠于人品；爱上一首歌，始于歌名，陷于旋律，忠于词义。</p></blockquote><blockquote><p>当我孑然一身的时候，贫穷与我不过是晚上吃馒头还是牛排的问题，无损我的快乐，当但我爱上一个姑娘的时候，我才深深感受到了贫穷所带来的自卑。</p></blockquote><blockquote><p>古代药房门口会挂着：<br>但愿世上无疾苦，宁可架上药生尘。<br>现在药房门口贴着：<br>会员积分，买十赠五，消费满58送20个鸡蛋。<br>————《只要平凡》</p></blockquote><blockquote><p>月老，麻烦下次为我牵红线的时候能换成钢丝吗，红线老TM断。<br>————《猫都瞧不起我》</p></blockquote><blockquote><p>我告诉你我喜欢你，并不是一定要和你在一起，只是希望今后的您，在遭遇人生低谷的时候，不要灰心，至少曾经有人被你的魅力所吸引，曾经是，以后也会是。<br>————《我要你》</p></blockquote><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><blockquote><p>你是我患得患失的梦 我是你可有可无的人 毕竟这穿越山河的剑 刺的都是用情至极的人 你是我辗转反侧的梦 我是你如梦山河的古人<br>————解忧少帅《写给黄淮》</p></blockquote><blockquote><p>像我这样优秀的人 本该灿烂过一生 怎么二十多年到头来 还在人海里浮沉<br>———— 毛不易《像我这样的人》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令总结</title>
      <link href="/2019/04/06/git-chang-yong-ming-ling-zong-jie/"/>
      <url>/2019/04/06/git-chang-yong-ming-ling-zong-jie/</url>
      
        <content type="html"><![CDATA[<blockquote><p>内容不定期更新</p></blockquote><h2 id="自己常用的-git-alias-可以在命令行中更好的显示-log-信息"><a href="#自己常用的-git-alias-可以在命令行中更好的显示-log-信息" class="headerlink" title="自己常用的 git alias 可以在命令行中更好的显示 log 信息"></a>自己常用的 git alias 可以在命令行中更好的显示 log 信息</h2><pre class=" language-shell"><code class="language-shell">alias gl="git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit"alias gll="git log --graph --abbrev-commit --decorate --all --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(dim white) - %an%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n %C(white)%s%C(reset)'"</code></pre><h2 id="1-git-commit-–amend"><a href="#1-git-commit-–amend" class="headerlink" title="1. git commit –amend"></a>1. git commit –amend</h2><pre class=" language-git"><code class="language-git">git commit --amend</code></pre><blockquote><p>解释：当第一次 commit 之后，发现没有修改正确，但是又不想在 git log 中出现两次提交记录，那么在第二次修改后，可以使用 git commit –amend 命令进行修改提交。此时提交成功后就只有一条 commit 记录了。</p></blockquote><h2 id="2-gitignore-生效"><a href="#2-gitignore-生效" class="headerlink" title="2. gitignore 生效"></a>2. gitignore 生效</h2><blockquote><p>解释: .gitignore 文件是忽略 git 项目中不需要提交的内容的配置文件。但是当某次提交的时候把不需要的内容提交到 git 版本控制中了之后。再想修改 .gitignore 文件来忽略那个文件的话是不会生效的。需要先想文件在 git 缓存中删除，然后在进行提交。就可以了。（下面是操作步骤）</p></blockquote><pre class=" language-git"><code class="language-git">git rm -r --cached .   //如何是目录的话，增加 -r 参数git add .git commit -m <span class="token string">'fix ignore'</span>//删除指定文件的缓存git rm --cached xx.html</code></pre><h2 id="3-git-reset-–soft-hard-hash"><a href="#3-git-reset-–soft-hard-hash" class="headerlink" title="3. git reset –soft/hard  hash*"></a>3. git reset –soft/hard  <strong>hash*</strong></h2><pre class=" language-git"><code class="language-git">git reset --soft  **hash***git reset --hard  **hash***</code></pre><blockquote><p>解释：当执行 git commit 之后，想回到之前的版本，可以使用 git reset 进行版本回退。–sorf 参数的意思是，git log 撤销版本，但代码中的内容没有回退。 –hard 参数的意思是，git log 中的记录和 文件内容完全回退到选的的版本。（–hard 更常用）</p></blockquote><h2 id="4-git-stash"><a href="#4-git-stash" class="headerlink" title="4. git stash"></a>4. git stash</h2><pre class=" language-git"><code class="language-git">git stash           //将当前工作去内容进行暂存，然后就进行切换分支或其他的操作了git stash list      //查看当前已经暂存的记录列表git stash pop       //将当前暂存内容回复到工作区并删除暂存记录列表中的内容git stash apply     //将当前暂存内容回复到工作区，不删除记录</code></pre><h2 id="5-git-rebase-变基"><a href="#5-git-rebase-变基" class="headerlink" title="5. git rebase (变基)"></a>5. git rebase (变基)</h2><blockquote><p>解释：当在两个分支进行操作的时候，一般我们使用 merge 将两个分支进行合并，但是这样会产生一个新的提交，并且另一个分支的提交记录在当前分支是不存在的。为了解决这个问题，可以使用 rebase。</p></blockquote><pre class=" language-git"><code class="language-git">//前提：master 分支和 new-feature 分支都进行了多次提交git checkout new-feature        //首先切换到新分支git rebase master               //将 master 分支的提交记录添加到当前分支git checkout master             //切换回 master 分支git merge new-feature           //将 new-feature 分支合并入master，此时 master 分支中就有了 new-feature 分支的提交记录，但是不会产生新的提交记录。此命令可以使提交历史更为整洁。</code></pre>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用frp搭建本地微信开发环境</title>
      <link href="/2019/03/08/shi-yong-frp-da-jian-ben-di-wei-xin-kai-fa-huan-jing/"/>
      <url>/2019/03/08/shi-yong-frp-da-jian-ben-di-wei-xin-kai-fa-huan-jing/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>2019-3-10</strong> 更新记录</p></blockquote><p>再使用 TP5 进行开发的时候需要注意一下几点</p><ol><li>关闭 trace 调试模式。</li><li>在使用路由的时候尽量确定对应接口请求的类型，如果不知道类型建议使用 <strong>Route::any()</strong>;</li></ol><p><em>可以使用 <a href="http://www.fangbei.org/tool/message" target="_blank" rel="noopener">微信消息测试工具</a>进行测试</em>。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>之前在做相关微信开发时，因为需要验证公网可以访问的到的域名，所以总是将代码推到线上服务器进行相关的测试。每次有些小改动也要进本地代码推送到服务器，服务器拉取最新代码这种重复性的操作，感觉十分繁琐，一直想找一个简单方便的方式进行微信本地环境的开发。😓 无奈之前自己太懒了……总是拖。最近几天好好研究了下特此记录下来。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>一台公网可以访问的服务器（或使用海外服务器）。</li><li>一个已经备案的域名。</li><li>内网穿透工具 <a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">frp</a></li></ol><h2 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h2><h3 id="下载-frp"><a href="#下载-frp" class="headerlink" title="下载 frp"></a>下载 frp</h3><p>下载对应系统的 <a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">frp</a> 包。因为我的公网服务器是 centOS6-x64 所以下载了 <code>frp_0.24.1_linux_amd64.tar.gz</code> 包。</p><h3 id="配置-frp-服务端"><a href="#配置-frp-服务端" class="headerlink" title="配置 frp 服务端"></a>配置 frp 服务端</h3><ol><li>在服务器上解压下载好的 frp 包。</li></ol><pre class=" language-bash"><code class="language-bash"> <span class="token function">tar</span> zxvf frp_0.24.1_linux_amd64.tar.gz</code></pre><ol start="2"><li><p>进入解压好的目录，编辑 frp 服务器端配置文件 <strong>frps.ini</strong>。</p><pre class=" language-ini"><code class="language-ini"><span class="token selector">[common]</span><span class="token constant">bind_port</span> <span class="token attr-value"><span class="token punctuation">=</span> 7000             #frp 绑定的端口</span><span class="token constant">vhost_http_port</span> <span class="token attr-value"><span class="token punctuation">=</span> 8000       #http 访问端口</span></code></pre><ol start="3"><li>启动服务端 frp</li></ol><pre class=" language-bash"><code class="language-bash">./frps -c ./frps.ini</code></pre></li></ol><h2 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h2><p>在域名服务商配置域名解析，将域名解析到上面的服务器 ip 地址上。</p><h2 id="配置-nginx-反向代理进行-frp-端口的转发"><a href="#配置-nginx-反向代理进行-frp-端口的转发" class="headerlink" title="配置 nginx 反向代理进行 frp 端口的转发"></a>配置 nginx 反向代理进行 frp 端口的转发</h2><ol><li>配置 nginx </li></ol><pre class=" language-nginx"><code class="language-nginx"><span class="token keyword">server</span> <span class="token punctuation">{</span>    <span class="token keyword">listen</span> <span class="token number">80</span><span class="token punctuation">;</span>    <span class="token keyword">server_name</span> wx<span class="token punctuation">.</span>domain<span class="token punctuation">.</span>com<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 绑定域名</span>    <span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">{</span>        <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token punctuation">:</span><span class="token number">8000</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 转发至本机8000,即在frps.ini中配置>的vhost_http_port</span>        <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Real<span class="token operator">-</span>IP <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> Host <span class="token variable">$host</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Forwarded<span class="token operator">-</span>For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol start="2"><li>重启 nginx</li></ol><h2 id="本地端配置"><a href="#本地端配置" class="headerlink" title="本地端配置"></a>本地端配置</h2><blockquote><p> 本地使用的是 vagrant 虚拟机。使用的同样是 centOS6-x64。在配置 frp 客户端之前需要将项目代码在 nginx 中正确配置，指定的域名就是上面解析的域名。</p></blockquote><ol><li>根据本地系统环境下载对应的  <a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">frp</a> 包。</li><li><p>编辑 frp 客户端配置文件 <strong>frpc.ini</strong>。</p><pre class=" language-ini"><code class="language-ini"><span class="token selector">[common]</span><span class="token constant">server_addr</span> <span class="token attr-value"><span class="token punctuation">=</span> x.x.x.x     #frps 所在的服务器的 IP</span><span class="token constant">server_port</span> <span class="token attr-value"><span class="token punctuation">=</span> 7000        #frps 绑定的端口</span><span class="token constant">use_encryption</span> <span class="token attr-value"><span class="token punctuation">=</span> true     #将 frpc 与 frps 之间的通信内容加密传输，将会有效防止流量被拦截。 </span><span class="token constant">use_compression</span> <span class="token attr-value"><span class="token punctuation">=</span> true     # 对传输内容进行压缩，可以有效减小 frpc 与 frps 之间的网络流量，加快流量转发速度，但是会额外消耗一些 cpu 资源。</span><span class="token selector">[web]</span><span class="token constant">type</span> <span class="token attr-value"><span class="token punctuation">=</span> http</span><span class="token constant">local_port</span> <span class="token attr-value"><span class="token punctuation">=</span> 80   #为本地机器上 web 服务对应的端口</span><span class="token constant">custom_domains</span> <span class="token attr-value"><span class="token punctuation">=</span> wx.domain.com   #上一步中解析好的域名</span></code></pre></li></ol><ol start="3"><li>启动 frp 客户端<pre class=" language-bash"><code class="language-bash">./frpc -c ./frpc.ini</code></pre></li></ol><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>如果一切正常那么现在随便找一台设备，访问刚才的域名就可以访问到本地的项目了。</p>]]></content>
      
      
      <categories>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> frp </tag>
            
            <tag> 开发环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 各种锁的理解</title>
      <link href="/2019/02/14/ge-chong-suo-de-li-jie/"/>
      <url>/2019/02/14/ge-chong-suo-de-li-jie/</url>
      
        <content type="html"><![CDATA[<blockquote><p>之前总是听说 MySQL 中的锁，一直没有具体的看过，晚上抽了空看了一点就先记录了下来，后面有机会在补充。</p></blockquote><h2 id="为什么需要锁"><a href="#为什么需要锁" class="headerlink" title="为什么需要锁"></a>为什么需要锁</h2><p>因为数据库是一个多用户共享的资源，也就是任何人都可以访问数据。当有一个商品表库存为1，当一个用户购买该商品的时候，首先需要查询商品的库存。如果一个人请求是没有任何问题的。但是当两个用户同时购买该商品的时候由于时间比较接近，当第一个用户查询完商品还未进行更新库存的时候，第二个用户就进来了，由于库存还没有更新，所以该用户也可以下单成功。最终将导致库存为-1，破幻了数据的一致性。为了解决这问题才有个锁的概念。</p><h2 id="有哪些锁"><a href="#有哪些锁" class="headerlink" title="有哪些锁"></a>有哪些锁</h2><ul><li>锁的类型<ul><li>读锁</li><li>写锁</li></ul></li><li>锁的粒度<ul><li>行锁</li><li>表锁</li></ul></li><li>持有锁的时间<ul><li>临时锁</li><li>持续锁</li></ul></li></ul><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><blockquote><p>说到锁那么接下来就需要了解隔离级别，了解隔离级别就需要了解数据库的四要素。</p></blockquote><h3 id="数据库四要素（ACID）"><a href="#数据库四要素（ACID）" class="headerlink" title="数据库四要素（ACID）"></a>数据库四要素（ACID）</h3><ul><li>原子性（Atomicity）：要么全部完成，要么全 <strong>不</strong> 完成。</li><li>一致性（Consistency）：一个事务单元提交后才可以被其他事务查看到。</li><li>隔离性（Isolation）：并发事务之间不相互影响。<em>设立了不同的隔离级别，通过适度破坏一致性来提高性能</em></li><li>持久性（Durability）：事物提交之后即持久化到磁盘中不会丢失。</li></ul><p><em><strong>锁只是实现隔离级别的几种方式之一，除了锁，实现并发问题的方式还有时间戳，多版本控制等等，这些也可以称为无锁的并发控制。</strong></em></p><h3 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h3><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> @<span class="token variable">@tx_isolation</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">#查询当前隔离级别</span><span class="token keyword">select</span> @<span class="token variable">@global.tx_isolation</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">#查询全局隔离级别</span><span class="token keyword">set</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation level</span> <span class="token keyword">read</span> <span class="token keyword">uncommitted</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">#设置当前隔离级别为 RU</span><span class="token keyword">set</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation level</span> <span class="token keyword">read</span> <span class="token keyword">committed</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">#设置当前隔离级别为 RC</span><span class="token keyword">set</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation level</span> <span class="token keyword">repeatable</span> <span class="token keyword">read</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">#设置当前隔离级别为 RR</span><span class="token keyword">set</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation level</span> <span class="token keyword">serializable</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">#设置当前隔离级别为 RS</span></code></pre><ul><li>读未提交（Read Uncommitted）：事务的读不阻塞其他事务的读和写，事务的写只阻塞其他事务的写，但不阻塞读。<strong>通过对写操作加“持续 X 锁”，对读操作不加锁实现。</strong></li><li>读已提交（Read Committed）：事务的读不阻塞其他事务的读和写，事务的写也会阻塞其他事务的读和写。<strong>通过对写操作加“持续 X 锁”，对读操作加“临时 S 锁”实现。</strong></li><li>可重复读（Repeatable Read）：事务的读会阻塞其他事务的写，但不阻塞读。事务的写会阻塞其他事务的读和写。<strong>通过对写操作加“持续 X 锁”，对读操作加“持续 S 锁”实现。</strong></li><li>序列化（Serializable）：最安全的一种级别，不会出现脏读、不可重复读、幻读问题。但是可能会导致大量的超时现象和锁竞争。<strong>使用的是表级锁</strong></li></ul><h3 id="可能产生的问题"><a href="#可能产生的问题" class="headerlink" title="可能产生的问题"></a>可能产生的问题</h3><p><img src="http://static.xiangdangnian.net.cn/blog/WX20190219-093153@2x.png" alt="WX20190219-093153@2x.png"></p><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>公司发工资，打了10000万到我的账户，但是该事务没有提交。这时我正好查看账户，发现10000元已经到账，非常开心。可以公司这时又发现发错了，于是回滚事务，修改金额为5000，然后提交事务。最终我实际得到的工资只有5000，空欢喜一场。</p><blockquote><p>这就是脏读，两个并发的事务，其中一个读取到了另一个没有提交的数据。</p></blockquote><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>拿着刚发的工资去买本书看看，付钱时系统读到我卡里有5000元，然而此时女友也拿着我的卡在消费，并花完了卡里的钱，并在我之前提交了事务，当我这边进行扣款的时候系统发现卡里没有钱了，提示扣款失败。我就十分纳闷，明明有钱啊，怎么。。。</p><blockquote><p> 这就是不可重复读，两个并发事务，在一个事务中读取到另一个事务中提交了的结果，第一事务在第二个事务提交前和提交后查看到的结果不一致。（主要是针对更新和删除操作）<strong>当隔离级别设置为Read committed时，避免了脏读，但是可能会造成不可重复读。</strong></p></blockquote><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>我又一个计划任务表，当前为空的。在第一个事务中我查看所有任务显示为空。这时女友在另一个事务增加了一条任务“早上起床做早饭”，并提交了事务。这是我又查看了一下所有任务发现还是空的，我就准备加一个任务“早上起床做早饭”，可是这时却提示我错误。我就纳了闷了，明明没有数据啊，怎么不让我加呢？难道出现了幻觉？</p><blockquote><p>这就是幻读。第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。（主要针对新增操作）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现负载均衡</title>
      <link href="/2019/01/27/shi-xian-fu-zai-jun-heng/"/>
      <url>/2019/01/27/shi-xian-fu-zai-jun-heng/</url>
      
        <content type="html"><![CDATA[<h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="http://static.xiangdangnian.net.cn/blog/2019-01-273.56.02.png" alt="架构图"></p><blockquote><p>简介： 用户访问负载均衡服务器，负载均衡服务器将相应的请求转发至应用服务器APP1或APP2。当前其中一台应用服务器down调的时候，负载均衡服务器将会把请求转发至另一台正常的服务器上。</p></blockquote><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="安装负载均衡服务器"><a href="#安装负载均衡服务器" class="headerlink" title="安装负载均衡服务器"></a>安装负载均衡服务器</h3><h4 id="安装并启动-nginx-或使用-jellybool-的-sh-脚本"><a href="#安装并启动-nginx-或使用-jellybool-的-sh-脚本" class="headerlink" title="安装并启动 nginx (或使用 jellybool 的 sh 脚本)"></a>安装并启动 nginx (<a href="https://github.com/JellyBool/laravel-server-script/blob/master/laravel-nginx-proxy-server.sh" target="_blank" rel="noopener">或使用 jellybool 的 sh 脚本</a>)</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> update<span class="token function">sudo</span> LC_ALL<span class="token operator">=</span>en_US.UTF-8 add-apt-repository ppa:nginx/development -y<span class="token function">sudo</span> <span class="token function">apt-get</span> update<span class="token function">sudo</span> <span class="token function">apt-get</span> -y <span class="token function">install</span> nginx<span class="token function">sudo</span> <span class="token function">cp</span> /etc/nginx/sites-available/default /etc/nginx/sites-available/default.bak<span class="token function">sudo</span> <span class="token function">service</span> nginx start</code></pre><h4 id="配置-nginx-服务器为负载均衡服务器"><a href="#配置-nginx-服务器为负载均衡服务器" class="headerlink" title="配置 nginx 服务器为负载均衡服务器"></a>配置 nginx 服务器为负载均衡服务器</h4><pre class=" language-nginx"><code class="language-nginx"><span class="token keyword">upstream</span> backend <span class="token punctuation">{</span>    <span class="token keyword">server</span> pravite<span class="token operator">-</span>ip<span class="token operator">-</span>address<span class="token number">-1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">#应用服务器ip地址</span>    <span class="token keyword">server</span> pravite<span class="token operator">-</span>ip<span class="token operator">-</span>address<span class="token number">-2</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">#应用服务器ip地址</span><span class="token punctuation">}</span><span class="token keyword">server</span> <span class="token punctuation">{</span>    <span class="token keyword">listen</span> <span class="token number">80</span> default_server<span class="token punctuation">;</span>    <span class="token keyword">listen</span> <span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token number">80</span> default_server<span class="token punctuation">;</span>    <span class="token keyword">server_name</span> nuli<span class="token punctuation">.</span>io www<span class="token punctuation">.</span>nuli<span class="token punctuation">.</span>io<span class="token punctuation">;</span>    <span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">{</span>        <span class="token keyword">add_header</span> X<span class="token operator">-</span>Content<span class="token operator">-</span>Type<span class="token operator">-</span>Options nosniff<span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Scheme <span class="token variable">$scheme</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Real<span class="token operator">-</span>IP <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Forwarded<span class="token operator">-</span>For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> Host <span class="token variable">$http_host</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>NginX<span class="token operator">-</span><span class="token keyword">Proxy</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_hide_header</span> X<span class="token operator">-</span>Powered<span class="token operator">-</span>By<span class="token punctuation">;</span>        <span class="token keyword">proxy_hide_header</span> Vary<span class="token punctuation">;</span>        <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>backend<span class="token punctuation">;</span>        <span class="token keyword">proxy_redirect</span> off<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="检测-nginx-配置并重启-nginx-服务"><a href="#检测-nginx-配置并重启-nginx-服务" class="headerlink" title="检测 nginx 配置并重启 nginx 服务"></a>检测 nginx 配置并重启 nginx 服务</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> nginx -t<span class="token function">sudo</span> <span class="token function">service</span> nginx reload</code></pre><h3 id="安装应用服务器-APP1"><a href="#安装应用服务器-APP1" class="headerlink" title="安装应用服务器 APP1"></a>安装应用服务器 APP1</h3><h4 id="安装-nginx-和-php-以及-php-扩展-或使用-jellybool-的-sh-脚本"><a href="#安装-nginx-和-php-以及-php-扩展-或使用-jellybool-的-sh-脚本" class="headerlink" title="安装 nginx 和 php 以及 php 扩展  或使用 jellybool 的 sh 脚本"></a>安装 nginx 和 php 以及 php 扩展  <a href="https://github.com/JellyBool/laravel-server-script/blob/master/laravel-app-server.sh" target="_blank" rel="noopener">或使用 jellybool 的 sh 脚本</a></h4><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> update<span class="token function">sudo</span> <span class="token function">apt-get</span> -y <span class="token function">install</span> zsh <span class="token function">htop</span> <span class="token function">zip</span> unzip composer<span class="token function">sudo</span> LC_ALL<span class="token operator">=</span>en_US.UTF-8 add-apt-repository ppa:nginx/development -y<span class="token function">sudo</span> <span class="token function">apt-get</span> update<span class="token function">sudo</span> <span class="token function">apt-get</span> -y <span class="token function">install</span> nginx<span class="token function">sudo</span> <span class="token function">service</span> nginx start<span class="token function">sudo</span> LC_ALL<span class="token operator">=</span>en_US.UTF-8 add-apt-repository ppa:ondrej/php -y<span class="token function">sudo</span> <span class="token function">apt-get</span> update<span class="token function">sudo</span> <span class="token function">apt-get</span> -y <span class="token function">install</span> php7.2<span class="token function">sudo</span> <span class="token function">apt-get</span> -y <span class="token function">install</span> php7.2-mysql<span class="token function">sudo</span> <span class="token function">apt-get</span> -y <span class="token function">install</span> php7.2-fpm<span class="token function">sudo</span> <span class="token function">apt-get</span> -y <span class="token function">install</span> php7.2-curl php7.2-xml php7.2-json php7.2-gd php7.2-mbstring php7.2-bcmath<span class="token function">sudo</span> <span class="token function">service</span> php7.2-fpm restart<span class="token function">sudo</span> <span class="token function">cp</span> /etc/nginx/sites-available/default /etc/nginx/sites-available/default.bak</code></pre><h3 id="安装应用服务器-APP2-同-APP1"><a href="#安装应用服务器-APP2-同-APP1" class="headerlink" title="安装应用服务器 APP2 (同 APP1)"></a>安装应用服务器 APP2 (同 APP1)</h3><h3 id="测试负载均衡"><a href="#测试负载均衡" class="headerlink" title="测试负载均衡"></a>测试负载均衡</h3><ol><li>在 APP1 服务器上的 <code>/var/www/html</code> 目录下将 <code>index.html</code>文件内容更改为 APP1。</li><li>在 APP2 服务器上的 <code>/var/www/html</code> 目录下将 <code>index.html</code>文件内容更改为 APP2。</li><li>访问负载均衡服务器 ip 地址或配置的域名。此时页面将交替显示 APP1 和 APP2 。~~~成功。</li></ol><h3 id="使用-Envoy-将-Laravel-项目同时部署在所有负载均衡的机器上"><a href="#使用-Envoy-将-Laravel-项目同时部署在所有负载均衡的机器上" class="headerlink" title="使用 Envoy 将 Laravel 项目同时部署在所有负载均衡的机器上"></a>使用 Envoy 将 Laravel 项目同时部署在所有负载均衡的机器上</h3><ol><li>在本机上创建 Laravel 项目</li><li>将项目提交到 coding 或 github 上</li><li>配置 coding 或 github 的ssh （可选）</li><li>使用 ssh 或 https 的方式将项目部署到 APP1 和 APP2 服务器上</li><li>配置两台服务器的 .env 文件 <strong><strong>保证两台服务器的 APP_KEY 要一直</strong></strong></li><li>测试——<em>访问负载均衡服务器可以看到 Laravel 欢迎语</em></li><li>在本机中的 Laravel 项目中安装 Envoy 扩展  <a href="https://laravel-china.org/docs/laravel/5.7/envoy/2307" target="_blank" rel="noopener">参考文档</a></li><li>在项目根目录新增 <code>Envoy.blade.php</code> 文件并在文件中增加如下内容。「需要注意的是：本机可以通过 ssh 的方式访问对应的服务器」</li></ol><pre class=" language-php"><code class="language-php">@<span class="token function">servers</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'web-1'</span>  <span class="token operator">=</span><span class="token operator">></span>  <span class="token string">'ssh root@192.168.3.11'</span><span class="token punctuation">,</span> <span class="token string">'web-2'</span>  <span class="token operator">=</span><span class="token operator">></span>  <span class="token string">'ssh root@192.168.3.11'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>@<span class="token function">task</span><span class="token punctuation">(</span><span class="token string">'deploy'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'on'</span>  <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token string">'web-1'</span><span class="token punctuation">,</span> <span class="token string">'web-2'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'parallel'</span>  <span class="token operator">=</span><span class="token operator">></span>  <span class="token boolean">true</span><span class="token punctuation">]</span><span class="token punctuation">)</span>cd <span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>www<span class="token operator">/</span>laravel<span class="token operator">-</span>deploy   sudo git pull origin master@endtask</code></pre><ol start="9"><li>运行部署命令 <code>envoy run deploy</code>,如果输出内容没有错误的话，就表示部署成功，就可以在负载均衡服务器上进行查看了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> nginx </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CGI, Fast-CGI，PHP-CGI，PHP-FPM 几个概念的总结</title>
      <link href="/2019/01/24/cgi-fast-cgi-php-cgi-php-fpm-li-jie-md/"/>
      <url>/2019/01/24/cgi-fast-cgi-php-cgi-php-fpm-li-jie-md/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在开始学php的时候有几个概念一直没有弄明白，最近查了些资料，特此补充记录一下，以防忘记。有不对的地方还请高手指点。</p></blockquote><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li>CGI：WEB 服务器与 WEB 应用程序之间交换数据的一种协议。</li><li>FastCGI：同 CGI 一样，也是一种协议，只是在效率上比 CGI 好一些。</li><li>PHP-CGI：fastCGI 协议的一种实现。(也就是 php 可执行目录下的php-cgi程序)。他有2个问题。<ul><li>更改配置文件后无法平滑重启。</li><li>无法动态调整进制多少。</li></ul></li><li>spawn-fcgi：解决了 php-cgi 出现的问题。但器仅仅是一个进程管理器。</li><li>PHP-FPM：实现了 Fast-CGI 协议并且之前平滑重启，同时还带有进程管理功能。</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.ietf.org/rfc/rfc3875" target="_blank" rel="noopener">CGI 协议内容</a></p><p><a href="http://andylin02.iteye.com/blog/648412" target="_blank" rel="noopener">Fast-CGI 协议内容</a></p><p><a href="http://yongxiong.leanote.com/post/%E4%BB%8ECGI%E5%88%B0FastCGI%E5%88%B0PHP-FPM" target="_blank" rel="noopener">从CGI到FastCGI到PHP-FPM</a></p><p><a href="https://www.awaimai.com/371.html" target="_blank" rel="noopener">CGI、FastCGI和PHP-FPM关系图解</a></p>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇文章</title>
      <link href="/2019/01/21/wo-de-di-yi-pian-wen-zhang/"/>
      <url>/2019/01/21/wo-de-di-yi-pian-wen-zhang/</url>
      
        <content type="html"><![CDATA[<h1 id="我的第一篇文章"><a href="#我的第一篇文章" class="headerlink" title="我的第一篇文章"></a>我的第一篇文章</h1><blockquote><p>这是我的第一篇文章，主要记录一下hexo博客的建立和使用方法。</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/HarleyWang93/blog/issues/1" target="_blank" rel="noopener">搭建参考</a></p><p><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">主题配置</a></p><h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><ol><li>需要安装git和Node.js</li><li>注册Github账号</li></ol><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><ol><li><p>使用npm全局安装hexo</p><pre class=" language-yaml"><code class="language-yaml">sudo npm install <span class="token punctuation">-</span>g hexo<span class="token punctuation">-</span>cli</code></pre></li><li><p>使用hexo init 初始化项目</p><pre class=" language-yaml"><code class="language-yaml">hexo init blog</code></pre></li><li><p>使用hexo s查看状态(默认访问该地址<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000 </a>)</p><pre class=" language-yaml"><code class="language-yaml">hexo s</code></pre></li></ol><h3 id="关联Github"><a href="#关联Github" class="headerlink" title="关联Github"></a>关联Github</h3><ol><li>创建仓库</li><li>开启Github Pages</li><li>选择分支</li></ol><h3 id="修改全局配置-注意：每个冒号后面都有个空格"><a href="#修改全局配置-注意：每个冒号后面都有个空格" class="headerlink" title="修改全局配置(注意：每个冒号后面都有个空格)"></a>修改全局配置(注意：每个冒号后面都有个空格)</h3><p>在项目中找到_config.yml文件，在文件最后添加如下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span> git    <span class="token key atrule">repository</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//github.com/xxx/xxx.github.io.git  <span class="token key atrule">branch</span><span class="token punctuation">:</span> master</code></pre><h3 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a>生成静态页面</h3><ol><li>执行生成静态文件命令</li></ol><pre class=" language-yaml"><code class="language-yaml">hexo g</code></pre><ol start="2"><li>安装git上传插件</li></ol><pre class=" language-yaml"><code class="language-yaml">npm install hexo<span class="token punctuation">-</span>deployer<span class="token punctuation">-</span>git <span class="token punctuation">-</span><span class="token punctuation">-</span>save</code></pre><ol start="3"><li>执行上传静态文件命令</li></ol><pre class=" language-yaml"><code class="language-yaml">hexo d</code></pre><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><pre><code>hexo new &quot;文章标题&quot;         //新建文章hexo new page &quot;页面名&quot;      //新建页面hexo g                     //生成静态文件至public目录hexo server                //开启本地访问hexo deploy                //部署到github</code></pre><h2 id="主题使用"><a href="#主题使用" class="headerlink" title="主题使用"></a>主题使用</h2><blockquote><p>具体详细内容查看项目链接 <a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">hexo-theme-matery</a></p></blockquote><h3 id="文章头部示例"><a href="#文章头部示例" class="headerlink" title="文章头部示例"></a>文章头部示例</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-07 09:25:00</span><span class="token key atrule">author</span><span class="token punctuation">:</span> 赵奇<span class="token key atrule">img</span><span class="token punctuation">:</span> /source/images/xxx.jpg <span class="token comment" spellcheck="true"># 或者:http://xxx.com/xxx.jpg</span><span class="token key atrule">top</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true"># 如果top值为true，则会是首页推荐文章</span><span class="token comment" spellcheck="true"># 如果要对文章设置阅读验证密码的话，就可以在设置password的值，该值必须是用SHA256加密后的密码，防止被他人识破</span><span class="token key atrule">password</span><span class="token punctuation">:</span> 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92<span class="token comment" spellcheck="true"># 本文章是否开启mathjax，且需要在主题的_config.yml文件中也需要开启才行</span><span class="token key atrule">mathjax</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">categories</span><span class="token punctuation">:</span> Markdown<span class="token key atrule">tags</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> Typora  <span class="token punctuation">-</span> Markdown<span class="token punctuation">---</span></code></pre><blockquote><ol><li>如果img属性不填写的话，文章特色图会根据文章标题的hashcode的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。</li><li>date的值尽量保证每篇文章是唯一的，因为本主题中Gitalk和Gitment识别id是通过date的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在Front-matter中设置采用了SHA256加密的password的值，还需要在主题的_config.yml中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
