<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《从点子到产品》读书笔记</title>
      <link href="/2021/06/13/%E4%BB%8E%E7%82%B9%E5%AD%90%E5%88%B0%E4%BA%A7%E5%93%81%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/06/13/%E4%BB%8E%E7%82%B9%E5%AD%90%E5%88%B0%E4%BA%A7%E5%93%81%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>豆瓣地址 <a href="https://book.douban.com/subject/26927349/" target="_blank" rel="noopener">https://book.douban.com/subject/26927349/</a></p><p><img src="http://static.xiangdangnian.net.cn/blog/2021/06/13/17-57-31-e130fa171cbb0fa6a7afea12c9466106-59554f.jpg" alt="从点子到产品"></p><h3 id="内容简介："><a href="#内容简介：" class="headerlink" title="内容简介："></a>内容简介：</h3><p>《从点子到产品：产品经理的价值观与方法论》以产品经理的方法论与价值观为主线，讲述了产品经理在从点子到产品的过程中应该考虑的问题、思考问题的思路，以及如何解决问题的方法。第一部分主要讲述从粗略的点子到具体的方案，要经历的步骤。第二部分主要讲述如何落实方案，以及如何进行用户研究、需求分析和产品设计。第三部分主要讲述在落实方案的过程中要掌握的方法和管理技巧。最后一部分主要讲述产品经理在工作和成长过程中要考虑的一些问题</p><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="http://static.xiangdangnian.net.cn/blog/2021/06/13/17-54-38-efd83c3a94b8cc8e02993d36fd134392-6b9e7d.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>composer 版本约束使用方法</title>
      <link href="/2020/09/15/composer%E7%89%88%E6%9C%AC%E7%BA%A6%E6%9D%9F%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
      <url>/2020/09/15/composer%E7%89%88%E6%9C%AC%E7%BA%A6%E6%9D%9F%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>composer 在平常的开发中是经常的使用，但是从来没有特别注意过 composer 包的版本约束，只是知道个大概，秉着活到老学到老的态度再次重新系统的学习下 composer 版本约束的具体规则。</p><p>##语义化版本</p><blockquote><p>首先我们需要先了解一下语义化版本</p></blockquote><p>这里有一篇介绍<a href="https://semver.org/lang/zh-CN" target="_blank" rel="noopener">语义化版本</a>的文章，有时间的小伙伴可以看一下。下面总结一下：</p><ul><li>版本格式： 主版本号.次版本号.修订版本号</li><li>主版本号：当你做了不兼容的 API 修改，</li><li>次版本号：当你做了向下兼容的功能性新增，</li><li>修订号：当你做了向下兼容的问题修正。</li><li>先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。</li></ul><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>1.2.34</p><ul><li>1 为主版本号</li><li>2 为次版本号</li><li>34 为修订号</li></ul><p>1.0.0-alpha1 这种在后面添加修饰符的表示先行版本。</p><h2 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h2><h3 id="不指定版本号（使用-号）"><a href="#不指定版本号（使用-号）" class="headerlink" title="不指定版本号（使用 * 号）"></a>不指定版本号（使用 * 号）</h3><p><strong>一般不建议使用</strong></p><pre><code>&quot;require&quot;: {        &quot;overtrue/wechat&quot;: &quot;*&quot;    }</code></pre><p>使用 * 号在进行composer 更新的时候会安装最新版本，如果第三方包的作者做了不兼容的版本的更新，那么更新后项目就跑步起来了。</p><h3 id="使用-dev-前缀加分支名"><a href="#使用-dev-前缀加分支名" class="headerlink" title="使用 dev- 前缀加分支名"></a>使用 dev- 前缀加分支名</h3><p><strong>一般在开发包的时候会使用</strong></p><pre><code>  &quot;require&quot;: {        &quot;overtrue/wechat&quot;: &quot;dev-master&quot;    }</code></pre><p>它表示使用该分支下最新的提交。</p><h3 id="符号约束小版本"><a href="#符号约束小版本" class="headerlink" title="~ 符号约束小版本"></a>~ 符号约束小版本</h3><p><strong>这种方式比较常用</strong></p><pre><code>&quot;require&quot;: {        &quot;overtrue/wechat&quot;: &quot;~1.2&quot;    }</code></pre><p>以上内容表示安装 &gt;= 1.2 且 &lt;2.0 的版本。（1.3、1.4、1.5等 不大于 2.0 的版本）</p><p>如果写成 “~1.2.3”，该约束表示 &gt;=1.2.3 且 &lt;1.2 (1.2.3、1.2.4、1.2.5 不大于 1.2 的版本)</p><p><em>~ 的作用是允许表达式中最后一位变到最大值</em></p><h2 id="符号约束大版本"><a href="#符号约束大版本" class="headerlink" title="^ 符号约束大版本"></a>^ 符号约束大版本</h2><p><strong>这种方式也比较常用</strong></p><pre><code>&quot;require&quot;: {        &quot;overtrue/wechat&quot;: &quot;^1.2&quot;    }</code></pre><p>以上内容表示可以安装 &gt;=1.2 且 &lt;2.0.0 版本。</p><p>如果写成 “^1.2.3” 则表示 &gt;=1.2.3 且 &lt;2.0.0 版本。</p><p><em>也就是说 ^ 锁定不允许变的第一位</em></p><h2 id="锁定版本范围"><a href="#锁定版本范围" class="headerlink" title="锁定版本范围"></a>锁定版本范围</h2><p>有时候我们的使用场景要求只能安装某些版本范围内的时候，可以使用 &gt;、&lt;、&gt;=、&lt;=、| 这些符号来组合，比如：&gt;= 1.3 &lt;1.6、&gt;=1.3 | &gt;=1.7 、3.0|4.0 等。这样的使用场景并不多，根据你的情况来调整用法就好。</p><h2 id="锁定具体版本"><a href="#锁定具体版本" class="headerlink" title="锁定具体版本"></a>锁定具体版本</h2><pre><code>&quot;require&quot;: {        &quot;overtrue/wechat&quot;: &quot;1.2&quot;    }</code></pre><p>以上内容表示必须为 1.2 的版本。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>如果你的版本是 1.0 以下，0.0.1，0.9.99999 等这样的版本的时候， ^ 的作用与 ~ 一样，也就是说：</p><p>^0.0.3 与 ~0.0.3 一样，都表示：&gt;=0.0.3 &lt; 0.0.4</p><p>因为主版本号为零（0.y.z）的软件一般处于开发初始阶段，一切都可能随时被改变。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过上面的学习我们知道了语义化版本的重要性，composer 在执行 update 的时候会根据我们定义的版本约束进行升级，如果我们使用的第三方包没有按照语义化版本来定义版本号，那么在升级之后就会出现项目无法运行的情况。所以我们在使用第三方的包的时候一定要注意该包是否使用语义化版本来定义版本号(不知道怎么选的，一般选择用得人比较多的第三方包)。在有一点就是我们自己在开发扩展包的时候也需要安装语义化版本来定义扩展包的版本号。</p><p><img src="http://static.xiangdangnian.net.cn/4vB3ZRunrw8VzSW6cLpJyaibKfYTNCU0.png" alt="程序员的艺术人生"></p>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> composer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>laravel 视图数据共享</title>
      <link href="/2020/09/13/laravel%E8%A7%86%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/"/>
      <url>/2020/09/13/laravel%E8%A7%86%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<p>在我们做网站的时候有些数据是每个视图页面都需要的（导航、侧边栏等内容），但如果我们在每个视图的控制器里面都写向视图传递数据的操作则会显得代码比较冗余。那么在 laravel 中我们一般可以使用 viewShare 和 viewComposer 的方式来进行视图页面数据的共享。</p><h2 id="viewShare"><a href="#viewShare" class="headerlink" title="viewShare"></a>viewShare</h2><h3 id="首先需要在-AppServiceProvider-中的-boot-方法中定义需要共享的数据。"><a href="#首先需要在-AppServiceProvider-中的-boot-方法中定义需要共享的数据。" class="headerlink" title="首先需要在 AppServiceProvider 中的 boot 方法中定义需要共享的数据。"></a>首先需要在 AppServiceProvider 中的 boot 方法中定义需要共享的数据。</h3><p>app/Providers/AppServiceProvider.php</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">namespace</span> <span class="token package">App<span class="token punctuation">\</span>Providers</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token package">Illuminate<span class="token punctuation">\</span>Support<span class="token punctuation">\</span>ServiceProvider</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token package">Illuminate<span class="token punctuation">\</span>Support<span class="token punctuation">\</span>Facades<span class="token punctuation">\</span>View</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">AppServiceProvider</span> <span class="token keyword">extends</span> <span class="token class-name">ServiceProvider</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * Register any application services.     *     * @return void     */</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">register</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Bootstrap any application services.     *     * @return void     */</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">boot</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        View<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">share</span><span class="token punctuation">(</span><span class="token string">'sitename'</span><span class="token punctuation">,</span><span class="token string">'xxx的网站'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="定义两个路由文件"><a href="#定义两个路由文件" class="headerlink" title="定义两个路由文件"></a>定义两个路由文件</h3><p>routes/web.php</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">use</span> <span class="token package">Illuminate<span class="token punctuation">\</span>Support<span class="token punctuation">\</span>Facades<span class="token punctuation">\</span>Route</span><span class="token punctuation">;</span>Route<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/product'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">view</span><span class="token punctuation">(</span><span class="token string">'product'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Route<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/blog'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">view</span><span class="token punctuation">(</span><span class="token string">'blog'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="在-blog-和-product-视图页使用共享的数据"><a href="#在-blog-和-product-视图页使用共享的数据" class="headerlink" title="在 blog 和 product 视图页使用共享的数据"></a>在 blog 和 product 视图页使用共享的数据</h3><p>resources/views/blog.blade.php</p><pre class=" language-php"><code class="language-php"><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token variable">$sitename</span><span class="token punctuation">}</span><span class="token punctuation">}</span>文章页</code></pre><p>resources/views/product.blade.php</p><pre class=" language-php"><code class="language-php"><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token variable">$sitename</span><span class="token punctuation">}</span><span class="token punctuation">}</span>产品页</code></pre><h3 id="验证效果"><a href="#验证效果" class="headerlink" title="验证效果"></a>验证效果</h3><p><img src="http://static.xiangdangnian.net.cn/20200914105715.png" alt=""><br><img src="http://static.xiangdangnian.net.cn/20200914105738.png" alt=""></p><h2 id="viewComposer"><a href="#viewComposer" class="headerlink" title="viewComposer"></a>viewComposer</h2><h3 id="设置-composer"><a href="#设置-composer" class="headerlink" title="设置 composer"></a>设置 composer</h3><p>有三种方式设置</p><ul><li><p>使用新的provider</p></li><li><p>在 AppServiceProvider 中的 boot 方法使用基于 viewComposer 的闭包</p></li><li><p>在 AppServiceProvider 中的 boot 方法使用 viewComposer 成器</p><h4 id="使用新的provider"><a href="#使用新的provider" class="headerlink" title="使用新的provider"></a>使用新的provider</h4><p>app/Providers/MenuComposerProvider.php</p></li></ul><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">namespace</span> <span class="token package">App<span class="token punctuation">\</span>Providers</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token package">App<span class="token punctuation">\</span>Http<span class="token punctuation">\</span>View<span class="token punctuation">\</span>Composers<span class="token punctuation">\</span>MenuComposer</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token package">Illuminate<span class="token punctuation">\</span>Support<span class="token punctuation">\</span>Facades<span class="token punctuation">\</span>View</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token package">Illuminate<span class="token punctuation">\</span>Support<span class="token punctuation">\</span>ServiceProvider</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">MenuComposerProvider</span> <span class="token keyword">extends</span> <span class="token class-name">ServiceProvider</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">register</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">boot</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        View<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">composer</span><span class="token punctuation">(</span><span class="token string">'menu'</span><span class="token punctuation">,</span>MenuComposer<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="在-AppServiceProvider-中的-boot-方法使用基于-viewComposer-的闭包-逻辑比较简单的话使用该方法"><a href="#在-AppServiceProvider-中的-boot-方法使用基于-viewComposer-的闭包-逻辑比较简单的话使用该方法" class="headerlink" title="在 AppServiceProvider 中的 boot 方法使用基于 viewComposer 的闭包(逻辑比较简单的话使用该方法)"></a>在 AppServiceProvider 中的 boot 方法使用基于 viewComposer 的闭包(逻辑比较简单的话使用该方法)</h4><p>app/Providers/MenuComposerProvider.php</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">namespace</span> <span class="token package">App<span class="token punctuation">\</span>Providers</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token package">Illuminate<span class="token punctuation">\</span>Support<span class="token punctuation">\</span>ServiceProvider</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token package">Illuminate<span class="token punctuation">\</span>Support<span class="token punctuation">\</span>Facades<span class="token punctuation">\</span>View</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">AppServiceProvider</span> <span class="token keyword">extends</span> <span class="token class-name">ServiceProvider</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">register</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">boot</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 使用基于合成器的闭包</span>        View<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">composer</span><span class="token punctuation">(</span><span class="token string">'menu'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token variable">$view</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token variable">$view</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">with</span><span class="token punctuation">(</span><span class="token string">'list'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'首页'</span><span class="token punctuation">,</span> <span class="token string">'文章'</span><span class="token punctuation">,</span> <span class="token string">'产品'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="在-AppServiceProvider-中的-boot-方法使用-viewComposer"><a href="#在-AppServiceProvider-中的-boot-方法使用-viewComposer" class="headerlink" title="在 AppServiceProvider 中的 boot 方法使用 viewComposer"></a>在 AppServiceProvider 中的 boot 方法使用 viewComposer</h4><p>app/Providers/MenuComposerProvider.php</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">namespace</span> <span class="token package">App<span class="token punctuation">\</span>Providers</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token package">App<span class="token punctuation">\</span>Http<span class="token punctuation">\</span>View<span class="token punctuation">\</span>Composers<span class="token punctuation">\</span>MenuComposer</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token package">Illuminate<span class="token punctuation">\</span>Support<span class="token punctuation">\</span>ServiceProvider</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token package">Illuminate<span class="token punctuation">\</span>Support<span class="token punctuation">\</span>Facades<span class="token punctuation">\</span>View</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">AppServiceProvider</span> <span class="token keyword">extends</span> <span class="token class-name">ServiceProvider</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">register</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">boot</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        View<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">composer</span><span class="token punctuation">(</span><span class="token string">'menu'</span><span class="token punctuation">,</span>MenuComposer<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="注册-Provider-（后两种方式不用注册）"><a href="#注册-Provider-（后两种方式不用注册）" class="headerlink" title="注册 Provider （后两种方式不用注册）"></a>注册 Provider （后两种方式不用注册）</h3><p>config/app.php</p><pre class=" language-php"><code class="language-php"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token string">'providers'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        App\<span class="token package">Providers<span class="token punctuation">\</span>MenuComposerProvider</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">class</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><h3 id="创建-MenuComposer"><a href="#创建-MenuComposer" class="headerlink" title="创建 MenuComposer"></a>创建 MenuComposer</h3><p>app/Http/View/Composers/MenuComposer.php</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">namespace</span> <span class="token package">App<span class="token punctuation">\</span>Http<span class="token punctuation">\</span>View<span class="token punctuation">\</span>Composers</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token package">Illuminate<span class="token punctuation">\</span>View<span class="token punctuation">\</span>View</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">MenuComposer</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">compose</span><span class="token punctuation">(</span>View <span class="token variable">$view</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$view</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">with</span><span class="token punctuation">(</span><span class="token string">'list'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'首页'</span><span class="token punctuation">,</span> <span class="token string">'文章'</span><span class="token punctuation">,</span> <span class="token string">'产品'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="创建-menu-视图文件"><a href="#创建-menu-视图文件" class="headerlink" title="创建 menu 视图文件"></a>创建 menu 视图文件</h3><p>resources/views/menu.blade.php</p><pre class=" language-php"><code class="language-php"><span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span></span>    @<span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token variable">$list</span> <span class="token keyword">as</span> <span class="token variable">$menu</span><span class="token punctuation">)</span>        <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span></span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token variable">$menu</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span></span>    @<span class="token keyword">endforeach</span><span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span></span></code></pre><h3 id="设置路由"><a href="#设置路由" class="headerlink" title="设置路由"></a>设置路由</h3><p>routes/web.php</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">use</span> <span class="token package">Illuminate<span class="token punctuation">\</span>Support<span class="token punctuation">\</span>Facades<span class="token punctuation">\</span>Route</span><span class="token punctuation">;</span>Route<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/product'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">view</span><span class="token punctuation">(</span><span class="token string">'product'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Route<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/blog'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">view</span><span class="token punctuation">(</span><span class="token string">'blog'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="在-product、blog-视图文件中引入-menu-视图"><a href="#在-product、blog-视图文件中引入-menu-视图" class="headerlink" title="在 product、blog 视图文件中引入 menu 视图"></a>在 product、blog 视图文件中引入 menu 视图</h3><p>resources/views/product.blade.php</p><pre class=" language-php"><code class="language-php">@<span class="token keyword">include</span><span class="token punctuation">(</span><span class="token string">'menu'</span><span class="token punctuation">)</span>产品页</code></pre><p>resources/views/blog.blade.php</p><pre class=" language-php"><code class="language-php">@<span class="token keyword">include</span><span class="token punctuation">(</span><span class="token string">'menu'</span><span class="token punctuation">)</span>文章页</code></pre><h3 id="查看效果"><a href="#查看效果" class="headerlink" title="查看效果"></a>查看效果</h3><p><img src="http://static.xiangdangnian.net.cn/20200914143225.png" alt=""></p><p><img src="http://static.xiangdangnian.net.cn/20200914143247.png" alt=""></p><p><img src="http://static.xiangdangnian.net.cn/4vB3ZRunrw8VzSW6cLpJyaibKfYTNCU0.png" alt="程序员的艺术人生"></p>]]></content>
      
      
      <categories>
          
          <category> laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 撤销相关操作</title>
      <link href="/2020/09/12/git%E6%92%A4%E9%94%80%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/09/12/git%E6%92%A4%E9%94%80%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>每次使用 git 需要进行版本回退相关的操作都要在搜索引擎重新查询相关命令，很是费时间，今天有空总结一下，算是记笔记方便以后使用。</p><h2 id="撤销本地当前所有修改"><a href="#撤销本地当前所有修改" class="headerlink" title="撤销本地当前所有修改"></a>撤销本地当前所有修改</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> reset --hard</code></pre><p>如果本地文件修改得一团乱，但是还没有 commit，可以通过这个命令恢复到上次 commit 的状态。</p><h2 id="丢弃-commit"><a href="#丢弃-commit" class="headerlink" title="丢弃 commit"></a>丢弃 commit</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> reset --hard commitID</code></pre><p>将代码恢复到指定的 commitID 处。如果不指定 –hard 参数，那么不会改变工作区的文件。（一般使用都会带上该参数）</p><h2 id="撤销-commit"><a href="#撤销-commit" class="headerlink" title="撤销 commit"></a>撤销 commit</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> revert HEAD</code></pre><p>commit 代码以后，你突然意识到这个 commit 有问题，应该撤销掉，这时执行该命令就可以了。该命令会新生成一个 commit 提交记录，并不改变其他内容，在 log 中可查看到撤销记录。基本属于撤销操作的首先方案。</p><blockquote><p>该命令还有两个常用参数</p></blockquote><ul><li>–no-edit：执行时不打开默认编辑器，直接使用 Git 自动生成的提交信息。</li><li>–no-commit：只抵消暂存区和工作区的文件变化，不产生新的提交。</li></ul><h2 id="撤销-add-操作"><a href="#撤销-add-操作" class="headerlink" title="撤销 add 操作"></a>撤销 add 操作</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> reset HEAD <span class="token punctuation">[</span>filename<span class="token punctuation">]</span></code></pre><p>可选参数</p><p>filename 指定撤销的文件。（不使用该参数表示所有已经 add 了的文件全部取消 add 状态）</p><h2 id="替换上一次-commit"><a href="#替换上一次-commit" class="headerlink" title="替换上一次 commit"></a>替换上一次 commit</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> commit --amend -m <span class="token string">"new Message"</span></code></pre><p>如果我们在 commit 之后发现信息写错了，这是可以使用该命令修改信息。</p><p><strong>这时如果暂存区有发生变化的文件（也就是有文件被 add 了），会一起提交到仓库。所以，–amend不仅可以修改提交信息，还可以整个把上一次提交替换掉。</strong></p><h2 id="暂时将未提交的变化移除，稍后再移入"><a href="#暂时将未提交的变化移除，稍后再移入" class="headerlink" title="暂时将未提交的变化移除，稍后再移入"></a>暂时将未提交的变化移除，稍后再移入</h2><p>$ git stash<br>$ git stash pop</p><p>如果我们在修改了一些文件后发现不应该在这个分支上操作，那么我们可以使用 git stash 将当前工作区的文件保存一下，然后切换的新分支，执行 git stash pop 将保存的内容恢复到新分支。</p><h2 id="时光机"><a href="#时光机" class="headerlink" title="时光机"></a>时光机</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> reflog</code></pre><p>只要HEAD发生了变化, 就会在reflog里面看得到。</p><p>配合 git reset 命令可以将代码切换到任意状态。</p><h2 id="取消已经-push-的行为（强制-PUSH）"><a href="#取消已经-push-的行为（强制-PUSH）" class="headerlink" title="取消已经 push 的行为（强制 PUSH）"></a>取消已经 push 的行为（强制 PUSH）</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查询 git 所有变化日志</span><span class="token function">git</span> reflog <span class="token comment" spellcheck="true"># 本地仓库回退到某一版本</span><span class="token function">git</span> reset -hard xxxx<span class="token comment" spellcheck="true"># 强制 PUSH，此时远程分支已经恢复成指定的 commit 了</span><span class="token function">git</span> push origin master --force</code></pre><p><img src="http://static.xiangdangnian.net.cn/4vB3ZRunrw8VzSW6cLpJyaibKfYTNCU0.png" alt="程序员的艺术人生"></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 学习笔记（十）</title>
      <link href="/2020/09/06/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%8D%81%EF%BC%88swarm%EF%BC%89/"/>
      <url>/2020/09/06/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%8D%81%EF%BC%88swarm%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Swarm 是 Docker 引擎内置（原生）的集群管理和编排工具</p></blockquote><p>学习 swarm 一定要理解的几个重要概念</p><ul><li>节点</li><li>服务</li><li>任务</li></ul><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>一台物理或云主机加入 docker 集群，那么这台主机就是一个节点。</p><p>节点分为管理 (manager) 节点和工作 (worker) 节点。</p><p>管理节点用于集群的管理，一个 Swarm 集群可以有多个管理节点，但只有一个管理节点可以成为 leader。</p><p>工作节点是任务执行节点，管理节点将服务 (service) 下发至工作节点执行。</p><p><strong>管理节点默认也作为工作节点。你也可以通过配置让工作节点只进行任务调度。</strong></p><p>Docker 官网的这张图片形象的展示了集群中管理节点与工作节点的关系。</p><p><img src="http://static.xiangdangnian.net.cn/20200831144229.png" alt="管理节点与工作节点的关系"></p><h3 id="任务和服务"><a href="#任务和服务" class="headerlink" title="任务和服务"></a>任务和服务</h3><p>任务 （Task）是 Swarm 中的最小的调度单位，目前来说就是一个单一的容器。任务包含一个 Docker 容器和在容器中运行的命令。</p><p>服务 （Services） 是指一组任务的集合，服务定义了任务的属性。服务有两种模式：</p><ul><li>replicated services（副本模式） 按照一定规则在各个工作节点上运行指定个数的任务。</li><li>global services（全局模式） 每个工作节点上运行一个任务</li></ul><p>两种模式通过 docker service create 的 –mode 参数指定。</p><h3 id="swarm-集群基本操作"><a href="#swarm-集群基本操作" class="headerlink" title="swarm 集群基本操作"></a>swarm 集群基本操作</h3><ul><li>三台安装了 Docker 的主机，各主机间可以通信。</li><li>Docker 版本必须大于 1.12</li><li>需要打开 tcp 2377 端口、tcp/udp 7946 端口、udp 4789 端口</li><li>选一台主机作为管理节点，获取其 ip 地址</li></ul><h4 id="docker-machine"><a href="#docker-machine" class="headerlink" title="docker-machine"></a>docker-machine</h4><p>Docker Machine 是 Docker 官方提供的一个工具，它可以帮助我们在远程的机器上安装 Docker，或者在虚拟机 host 上直接安装虚拟机并在虚拟机中安装 Docker。我们还可以通过 docker-machine 命令来管理这些虚拟机和 Docker。 </p><h5 id="安装-docker-machine"><a href="#安装-docker-machine" class="headerlink" title="安装 docker-machine"></a>安装 docker-machine</h5><ol><li>首先下载可执行文件 <a href="https://github.com/docker/machine/releases" target="_blank" rel="noopener">https://github.com/docker/machine/releases</a></li><li>将下载好的文件移动到 <code>/usr/local/bin/docker-machine</code> 目录下并改名为 docker-machine</li><li>执行 <code>sudo chmod +x /usr/local/bin/docker-machine</code> 命令为其添加可执行权限</li><li>执行如下命令，验证是否安装成功<pre class=" language-bash"><code class="language-bash">$ docker-machine -vdocker-machine version 0.16.1, build cce350d7</code></pre></li></ol><h5 id="初始化集群"><a href="#初始化集群" class="headerlink" title="初始化集群"></a>初始化集群</h5><p>第一步：如下命令创建 一个 Docker 主机作为管理节点。</p><pre class=" language-bash"><code class="language-bash">$ docker-machine create -d virtualbox manager</code></pre><p>由于众所周知的原因下载 boot2docker 特别慢，我们通过 <a href="https://github.com/boot2docker/boot2docker/releases/" target="_blank" rel="noopener">boot2docker 项目</a>页面直接下载该文件，然后将该文件移动到该 <code>/Users/用户名/.docker/machine/cache</code> 目录下。最后重新执行创建的命令就可以了</p><p>第二步：在管理节点上初始化一个 swarm 集群</p><pre class=" language-bash"><code class="language-bash">// <span class="token function">ssh</span> 到虚拟机中$ docker-machine <span class="token function">ssh</span> manager// 初始化 swarm 集群，并指定管理节点 ip 地址docker@manager:~$ docker swarm init --advertise-addr 192.168.99.100Swarm initialized: current node <span class="token punctuation">(</span>dxn1zf6l61qsb1josjja83ngz<span class="token punctuation">)</span> is now a manager.To add a worker to this swarm, run the following command:    docker swarm <span class="token function">join</span> \    --token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \    192.168.99.100:2377To add a manager to this swarm, run <span class="token string">'docker swarm join-token manager'</span> and follow the instructions.</code></pre><p><strong>执行 docker swarm init 命令的节点自动成为管理节点。</strong></p><p>第三步：创建工作节点，并加入 swarm 集群</p><p>worker 1 </p><pre class=" language-bash"><code class="language-bash">$ docker-machine create -d virtualbox worker1$ docker-machine <span class="token function">ssh</span> worker1// 工作节点初始化集群的时候会自动给出该命令。docker@worker1:~$ docker swarm <span class="token function">join</span> \    --token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \    192.168.99.100:2377This node joined a swarm as a worker.</code></pre><p><strong>通过该 <code>docker swarm join-token worker</code> 命令获取加入集群的命令</strong></p><p>worker2</p><pre class=" language-bash"><code class="language-bash">$ docker-machine create -d virtualbox worker2$ docker-machine <span class="token function">ssh</span> worker2docker@worker1:~$ docker swarm <span class="token function">join</span> \    --token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \    192.168.99.100:2377This node joined a swarm as a worker.</code></pre><p>第四步：查看节点状态</p><pre class=" language-bash"><code class="language-bash">// 该命令只能在管理节点使用$ docker node <span class="token function">ls</span>ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSIONjnn6cji3hy22ninkymqxer49q *   manager             Ready               Active              Leader              19.03.12r5sce06gn9351jvotf6xp1r53     worker1             Ready               Active                                  19.03.12ssdfsdfs2df32dfk34dc3498      worker1             Ready               Active                                  19.03.12</code></pre><p><strong>Docker 引擎通过主机名自动为节点命名</strong></p><p><strong>MANAGER 列标识群中的管理器节点。Leader 表示管理节点，空表示工作节点</strong></p><h5 id="部署一个服务"><a href="#部署一个服务" class="headerlink" title="部署一个服务"></a>部署一个服务</h5><pre class=" language-bash"><code class="language-bash">$ docker <span class="token function">service</span> create --replicas 1 --name helloworld busybox <span class="token function">ping</span> baidu.comwo27l49vowb7reote7apzqn8doverall progress: 1 out of 1 tasks1/1: running   <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">></span><span class="token punctuation">]</span>verify: Service converged</code></pre><ul><li>–preplicas 1 指定副本个数为 1 个（即在集群中启动一个容器运行）</li><li>–name 指定服务名称为 helloworld</li><li>busybox 指定镜像为 busybox</li><li>ping baidu.com  指定运行的命令</li></ul><h5 id="查看当前运行的服务"><a href="#查看当前运行的服务" class="headerlink" title="查看当前运行的服务"></a>查看当前运行的服务</h5><pre class=" language-bash"><code class="language-bash">$ docker <span class="token function">service</span> <span class="token function">ls</span>ID                  NAME                MODE                REPLICAS            IMAGE                        PORTSwo27l49vowb7        helloworld          replicated          1/1                 busybox:latesttcp</code></pre><h5 id="查看服务详情"><a href="#查看服务详情" class="headerlink" title="查看服务详情"></a>查看服务详情</h5><pre class=" language-bash"><code class="language-bash">$ docker <span class="token function">service</span> inspect --pretty helloworldID:        wo27l49vowb7reote7apzqn8dName:        helloworldService Mode:    Replicated Replicas:    1Placement:UpdateConfig: Parallelism:    1 On failure:    pause Monitoring Period: 5s Max failure ratio: 0 Update order:      stop-firstRollbackConfig: Parallelism:    1 On failure:    pause Monitoring Period: 5s Max failure ratio: 0 Rollback order:    stop-firstContainerSpec: Image:        busybox:latest@sha256:4f47c01fa91355af2865ac10fef5bf6ec9c7f42ad2321377c21e844427972977 Args:        <span class="token function">ping</span> baidu.com Init:        <span class="token boolean">false</span>Resources:Endpoint Mode:    vip</code></pre><ul><li>–pretty 以更好看的格式显示（不指定的话将以 json 格式显示）</li></ul><h5 id="查看服务运行在哪个接点上"><a href="#查看服务运行在哪个接点上" class="headerlink" title="查看服务运行在哪个接点上"></a>查看服务运行在哪个接点上</h5><pre class=" language-bash"><code class="language-bash">docker@manager:~$ docker <span class="token function">service</span> <span class="token function">ps</span> helloworldID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE            ERROR               PORTSre3rdqvnsoa3        helloworld.1        busybox:latest      worker1             Running             Running 11 minutes ago</code></pre><p>我们可以看到该服务运行在 worker1 节点上。让我们 ssh 到 worker1 节点执行 docker ps 命令，发现确实有容器在运行。而我们 ssh 到其他节点上执行 docker ps 会发现并没有容器在运行。</p><h5 id="扩展集群中的服务"><a href="#扩展集群中的服务" class="headerlink" title="扩展集群中的服务"></a>扩展集群中的服务</h5><p><strong>必须在管理节点操作</strong></p><pre class=" language-bash"><code class="language-bash">$ docker <span class="token function">service</span> scale helloworld<span class="token operator">=</span>5helloworld scaled to 5overall progress: 5 out of 5 tasks1/5: running   <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">></span><span class="token punctuation">]</span>2/5: running   <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">></span><span class="token punctuation">]</span>3/5: running   <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">></span><span class="token punctuation">]</span>4/5: running   <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">></span><span class="token punctuation">]</span>5/5: running   <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">></span><span class="token punctuation">]</span>verify: Service converged$ docker <span class="token function">service</span> <span class="token function">ps</span> helloworldID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE               ERROR                              PORTSre3rdqvnsoa3        helloworld.1        busybox:latest      worker1             Running             Running about an hour ago4tjmgtulmkx0        helloworld.2        busybox:latest      worker2             Running             Running 38 minutes agozl3u08rsrm72        helloworld.3        busybox:latest      manager             Running             Running 38 minutes agoam36krqw6o97        helloworld.4        busybox:latest      manager             Running             Running 39 minutes agotsbhagfz6fx6        helloworld.5        busybox:latest      worker1             Running             Running 39 minutes ago</code></pre><ul><li>我们可以看到新增加了 4 个任务分布在manager、worker1、worker2 上。</li><li>ssh 到各个主机执行 <code>docker ps</code> 查看主机运行容器的状态</li></ul><h5 id="删除集群中的服务"><a href="#删除集群中的服务" class="headerlink" title="删除集群中的服务"></a>删除集群中的服务</h5><p><strong>必须在管理节点操作</strong></p><pre class=" language-bash"><code class="language-bash">$ docker <span class="token function">service</span> <span class="token function">rm</span> helloworldhelloworlddocker@manager:~$ docker <span class="token function">service</span> <span class="token function">ls</span>ID                  NAME                MODE                REPLICAS            IMAGE               PORTS</code></pre><p><strong>其他主机需要等一会再查看运行的容器是否删除</strong></p><h5 id="动态升级服务"><a href="#动态升级服务" class="headerlink" title="动态升级服务"></a>动态升级服务</h5><p>创建一个低版本的 redis 服务</p><pre class=" language-bash"><code class="language-bash">$ docker <span class="token function">service</span> create --replicas 3 --name redis --update-delay 10s redis:3.0.6vep8ciixn4otmt9g0khd98z5doverall progress: 3 out of 3 tasks1/3: running   <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">></span><span class="token punctuation">]</span>2/3: running   <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">></span><span class="token punctuation">]</span>3/3: running   <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">></span><span class="token punctuation">]</span>verify: Service converged</code></pre><ul><li>–update-delay 设置更新任务之间的延迟时间（20h10m5s 表示延迟为 20 小时 10 分钟 5 表）</li><li>–update-parallelism 设置同时更新任务的最大数（默认值为 1）</li><li>–update-failure-action 设置更新任务失败后执行的动作(默认设置为如果在更新过程中的任何时候任务返回失败，则调度程序将暂停更新)</li></ul><p>更新 redis</p><pre class=" language-bash"><code class="language-bash">$ docker <span class="token function">service</span> update --image redis:3.0.7 redis</code></pre><p>上面的命令实际执行流程为：</p><ol><li>暂停第一个任务</li><li>为停止的任务安排更新计划</li><li>启动一个新版本的容器</li><li>如果任务的返回“RUNNING”，则等待指定的延迟时间后开始下一个任务</li><li>如果任务返回“FAILED”，则暂停更新。</li></ol><p>查看当前服务状态 </p><p><em>可以看出服务的更新是暂停老版本，增加新版本</em></p><pre class=" language-bash"><code class="language-bash">docker@manager:~$ docker <span class="token function">service</span> <span class="token function">ps</span> redisID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE            ERROR                              PORTSjbojkid2itrn        redis.1             redis:3.0.7         worker2             Running             Running 3 minutes agor4nyfe94e5ms         \_ redis.1         redis:3.0.6         worker2             Shutdown            Shutdown 3 minutes agot8umvvy4bf80        redis.2             redis:3.0.7         manager             Running             Running 2 minutes agorhunef6vi2dk         \_ redis.2         redis:3.0.6         manager             Shutdown            Shutdown 3 minutes agow2jcya0tc9cv        redis.3             redis:3.0.7         worker1             Running             Running 2 minutes agosz1ptkhmak6q         \_ redis.3         redis:3.0.6         worker1             Shutdown            Shutdown 2 minutes ago</code></pre><h5 id="设置节点为-Drain-状态"><a href="#设置节点为-Drain-状态" class="headerlink" title="设置节点为 Drain 状态"></a>设置节点为 Drain 状态</h5><p>目前我们的所有节点都为 Active 状态，也就是所有节点都可以接受任务。但有时候我们想指定某个节点正在维护，不进行任务处理，那么我们就要对节点的状态进行更改。</p><pre class=" language-bash"><code class="language-bash">// 为了后面查看方便，删除上面进行创建的 redis 服务$ docker <span class="token function">service</span> <span class="token function">rm</span> redis //重新创建一个 redis 服务$ docker <span class="token function">service</span> create --replicas 3 --name redis --update-delay 10s redis:3.0.6// 查看当前服务运行状态（每个节点运行一个任务）$ docker <span class="token function">service</span> <span class="token function">ps</span> redisID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE            ERROR               PORTSffhwf4i243yc        redis.1             redis:3.0.6         worker2             Running             Running 35 seconds agosflv38rtetvh        redis.2             redis:3.0.6         manager             Running             Running 35 seconds agokzn7cn15rrye        redis.3             redis:3.0.6         worker1             Running             Running 35 seconds ago// 将 worker1 节点设为 Drain 状态$ docker node update --availability drain worker1worker1// 查看当前服务运行状态（注意 worker1 节点服务的状态已经为关闭，worker2 节点上又多了一个任务）$ docker <span class="token function">service</span> <span class="token function">ps</span> redisID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE                     ERROR               PORTSffhwf4i243yc        redis.1             redis:3.0.6         worker2             Running             Running about a minute agosflv38rtetvh        redis.2             redis:3.0.6         manager             Running             Running about a minute agoir0nvesyhrea        redis.3             redis:3.0.6         worker2             Running             Running <span class="token function">less</span> than a second agokzn7cn15rrye         \_ redis.3         redis:3.0.6         worker1             Shutdown            Shutdown <span class="token function">less</span> than a second ago</code></pre><h3 id="Routing-Mesh-（路由网格）"><a href="#Routing-Mesh-（路由网格）" class="headerlink" title="Routing Mesh （路由网格）"></a>Routing Mesh （路由网格）</h3><p>Routing Mesh 是 docker swarm 提供的确保服务在多节点网络上可用的集群网络机制。</p><p>当我们创建一个服务的时候，如果将端口发布出来，那么所有节点都会加入到这个路由网格中，当我们在外部通过任意主机 ip 和发布的端口访问服务的时候，无论该主机上时候启动服务，我们都能访问的到。（负载均衡）</p><p>在使用之前需要先开启如下端口：</p><ul><li>TCP/UDP 的 7946 端口</li><li>UDP 的 4789 端口</li></ul><p>格式： </p><pre class=" language-bash"><code class="language-bash">docker <span class="token function">service</span> create \  --name <span class="token operator">&lt;</span>SERVICE-NAME<span class="token operator">></span> \  --publish published<span class="token operator">=</span><span class="token operator">&lt;</span>PUBLISHED-PORT<span class="token operator">></span>,target<span class="token operator">=</span><span class="token operator">&lt;</span>CONTAINER-PORT<span class="token operator">></span> \  <span class="token operator">&lt;</span>IMAGE<span class="token operator">></span></code></pre><ul><li>SERVICE-NAME 自定义服务的名称</li><li>PUBLISHED-PORT 对外发布的端口号</li><li>CONTAINER-PORT 容器的端口号</li><li>IMAGE 服务所使用的镜像</li></ul><h4 id="启动-nginx-服务并发布端口"><a href="#启动-nginx-服务并发布端口" class="headerlink" title="启动 nginx 服务并发布端口"></a>启动 nginx 服务并发布端口</h4><pre class=" language-bash"><code class="language-bash">$ docker <span class="token function">service</span> create --name web --publish published<span class="token operator">=</span>8080,target<span class="token operator">=</span>80 --replicas 2 nginx// 查看服务当前运行在哪个节点上$ docker <span class="token function">service</span> <span class="token function">ps</span> webID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE            ERROR               PORTSkuocqhmt4rl7        web.1               nginx:latest        worker1             Running             Running 40 seconds agos3ybcckxdrnb        web.2               nginx:latest        manager             Running             Running 40 seconds ago// 查看当前所有节点$ docker node <span class="token function">ls</span>ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION3px1nw94x2wmnr0k7846hpksh *   manager             Ready               Active              Leader              19.03.12ibhxsuf055peywhawgp7hslav     worker1             Ready               Active                                  19.03.12ny1e3wd4l7enyh0pp547azefe     worker2             Ready               Active                                  19.03.12</code></pre><p>各节点 ip 地址</p><ul><li>manager 192.168.99.100</li><li>worker1 192.168.99.101</li><li>worker2 192.168.99.102</li></ul><h4 id="访问各个节点"><a href="#访问各个节点" class="headerlink" title="访问各个节点"></a>访问各个节点</h4><p><img src="http://static.xiangdangnian.net.cn/blog/2020/08/31/21-35-55-45776d21fca64c07fad073412e998fa0-bdf130.png" alt="访问结果"></p><p>我们发现即使 worker2 节点没有运行 nginx 容器，但我们依然可以通过 worker2 节点访问发布的服务。</p><h4 id="对已存在的服务发布端口"><a href="#对已存在的服务发布端口" class="headerlink" title="对已存在的服务发布端口"></a>对已存在的服务发布端口</h4><pre class=" language-bash"><code class="language-bash">docker <span class="token function">service</span> update \  --publish-add published<span class="token operator">=</span><span class="token operator">&lt;</span>PUBLISHED-PORT<span class="token operator">></span>,target<span class="token operator">=</span><span class="token operator">&lt;</span>CONTAINER-PORT<span class="token operator">></span> \  <span class="token operator">&lt;</span>SERVICE<span class="token operator">></span></code></pre><h4 id="绕过-Routing-Mesh"><a href="#绕过-Routing-Mesh" class="headerlink" title="绕过 Routing Mesh"></a>绕过 Routing Mesh</h4><p>不具体讲解了，没有想到实际的应用场景。</p><pre class=" language-bash"><code class="language-bash">$ docker <span class="token function">service</span> create --name dns-cache \  --publish published<span class="token operator">=</span>53,target<span class="token operator">=</span>53,protocol<span class="token operator">=</span>udp,mode<span class="token operator">=</span>host \  --mode global \  dns-cache</code></pre><h3 id="服务全局模式（global-service）"><a href="#服务全局模式（global-service）" class="headerlink" title="服务全局模式（global service）"></a>服务全局模式（global service）</h3><p>上面的各种示例都是基于副本模式，下面开始全局模式。</p><pre class=" language-bash"><code class="language-bash">$ docker <span class="token function">service</span> create \  --mode global \  --publish mode<span class="token operator">=</span>host,target<span class="token operator">=</span>80,published<span class="token operator">=</span>8080 \  --name<span class="token operator">=</span>nginx \  nginx:latest</code></pre><p>使用上面的命令可以在当前的每个工作节点启动一个 nginx 容器，这时如果有一个节点挂掉了，那么并不会在其他节点重启启动一个新的容器。而如果我们这时在添加一个新的节点，那么当这个新的节点加入 swarm 集群的时候，该节点也会自动启动一个 nginx 容器。</p><h3 id="overlay-网络"><a href="#overlay-网络" class="headerlink" title="overlay 网络"></a>overlay 网络</h3><blockquote><p>该网络可以连接 swarm 集群中的一个或多个服务</p></blockquote><h4 id="创建-overlay-网络"><a href="#创建-overlay-网络" class="headerlink" title="创建 overlay 网络"></a>创建 overlay 网络</h4><pre class=" language-bash"><code class="language-bash">$ docker network create --driver overlay my-network</code></pre><h4 id="创建服务的时候加入-overlay-网络"><a href="#创建服务的时候加入-overlay-网络" class="headerlink" title="创建服务的时候加入 overlay 网络"></a>创建服务的时候加入 overlay 网络</h4><pre class=" language-bash"><code class="language-bash">$ docker <span class="token function">service</span> create --replicas 3  --network my-network --name my-web nginx</code></pre><h4 id="将现有的服务加入-overlay-网络"><a href="#将现有的服务加入-overlay-网络" class="headerlink" title="将现有的服务加入 overlay 网络"></a>将现有的服务加入 overlay 网络</h4><pre class=" language-bash"><code class="language-bash">$ docker <span class="token function">service</span> update --network-add my-network my-web</code></pre><h4 id="将现有服务从-overlay-网络中断开"><a href="#将现有服务从-overlay-网络中断开" class="headerlink" title="将现有服务从 overlay 网络中断开"></a>将现有服务从 overlay 网络中断开</h4><pre class=" language-bash"><code class="language-bash">$ docker <span class="token function">service</span> update --network-rm my-network my-web</code></pre><h3 id="在-Swarm-集群中管理敏感数据"><a href="#在-Swarm-集群中管理敏感数据" class="headerlink" title="在 Swarm 集群中管理敏感数据"></a>在 Swarm 集群中管理敏感数据</h3><h4 id="创建-secret"><a href="#创建-secret" class="headerlink" title="创建 secret"></a>创建 secret</h4><p>格式：<code>docker secret create &lt;secret-name&gt; &lt;file-name&gt;</code></p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">printf</span> <span class="token string">"This is a secret"</span> <span class="token operator">|</span> docker secret create my_secret_data -</code></pre><p>因为我们通过读取标准输入的方式，所以最后使用 - 标记</p><h4 id="创建一个-redis-服务并授权方位-secret"><a href="#创建一个-redis-服务并授权方位-secret" class="headerlink" title="创建一个 redis 服务并授权方位 secret"></a>创建一个 redis 服务并授权方位 secret</h4><pre class=" language-bash"><code class="language-bash">$ docker <span class="token function">service</span>  create --name redis --secret my_secret_data redis:alpine</code></pre><p>默认情况下，容器可以通过 <code>/run/secrets/&lt;secret_name&gt;</code> 路径访问密钥。或者可以使用 target 选项自定义容器上的文件名。</p><h4 id="查看当前服务运行状态"><a href="#查看当前服务运行状态" class="headerlink" title="查看当前服务运行状态"></a>查看当前服务运行状态</h4><pre><code>$ docker service ps redisID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE                ERROR               PORTSbp0ylcmxw6ll        redis.1             redis:alpine        worker1             Running             Running about a minute ago</code></pre><h4 id="验证-secret"><a href="#验证-secret" class="headerlink" title="验证 secret"></a>验证 secret</h4><pre class=" language-bash"><code class="language-bash">// 根据上面查看的数据，进入 worker1 容器$ docker-machine <span class="token function">ssh</span> worker1// 获取 worker1 容器运行的 redis 服务$ docker <span class="token function">ps</span>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMESaa049d4173e1        redis:alpine        <span class="token string">"docker-entrypoint.s…"</span>   8 minutes ago       Up 8 minutes        6379/tcp            redis.1.bp0ylcmxw6llv9icvhgrk189f// 进入 redis 容器$ docker <span class="token function">exec</span> -it redis.1.bp0ylcmxw6llv9icvhgrk189f sh//在容器中查看 secret<span class="token comment" spellcheck="true"># cat /run/secrets/my_secret_data</span>This is a secret</code></pre><h4 id="使用中的-secret-无法删除"><a href="#使用中的-secret-无法删除" class="headerlink" title="使用中的 secret 无法删除"></a>使用中的 secret 无法删除</h4><pre class=" language-bash"><code class="language-bash">// 进入 manager 节点$ docker-machine <span class="token function">ssh</span> manager$ docker secret <span class="token function">rm</span> my_secret_dataError response from daemon: rpc error: code <span class="token operator">=</span> InvalidArgument desc <span class="token operator">=</span> secret <span class="token string">'my_secret_data'</span> is <span class="token keyword">in</span> use by the following service: redisdocker@manager:~$</code></pre><h4 id="通过更新的方式删除-secret"><a href="#通过更新的方式删除-secret" class="headerlink" title="通过更新的方式删除 secret"></a>通过更新的方式删除 secret</h4><pre class=" language-bash"><code class="language-bash">$ docker <span class="token function">service</span> update --secret-rm my_secret_data redisredisoverall progress: 1 out of 1 tasks1/1: running   <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">></span><span class="token punctuation">]</span>verify: Service converged</code></pre><h4 id="删除服务和-secret"><a href="#删除服务和-secret" class="headerlink" title="删除服务和 secret"></a>删除服务和 secret</h4><pre class=" language-bash"><code class="language-bash">$ docker <span class="token function">service</span> <span class="token function">rm</span> redis$ docker secret <span class="token function">rm</span> my_secret_data</code></pre><h3 id="在-Swarm-集群中管理非敏感数据（配置）"><a href="#在-Swarm-集群中管理非敏感数据（配置）" class="headerlink" title="在 Swarm 集群中管理非敏感数据（配置）"></a>在 Swarm 集群中管理非敏感数据（配置）</h3><p><strong>使用方式与 secret 相似</strong></p><blockquote><p>docker 17.06引入了swarm service configs。允许你在服务映像或运行容器之外存储非敏感信息</p></blockquote><p><strong>注意：config 仅能在 Swarm 集群中使用。</strong></p><h4 id="创建-config"><a href="#创建-config" class="headerlink" title="创建 config"></a>创建 config</h4><pre class=" language-bash"><code class="language-bash">// 创建一个名为 redis.conf 的文件，内容为 port：6380$ <span class="token function">cat</span> redis.confport 6380// 创建 config$ docker config create redis.conf redis.conf$ docker config <span class="token function">ls</span>ID                          NAME                CREATED             UPDATEDfkamdbup3egw8752bm4ixrsm2   redis.conf          23 minutes ago      23 minutes ago</code></pre><p>跟 secret 使用类似</p><h4 id="创建-redis-服务并授权其方位-config"><a href="#创建-redis-服务并授权其方位-config" class="headerlink" title="创建 redis 服务并授权其方位 config"></a>创建 redis 服务并授权其方位 config</h4><pre class=" language-bash"><code class="language-bash">$ docker <span class="token function">service</span> create \--name redis \--config redis.conf \--publish published<span class="token operator">=</span>6379,target<span class="token operator">=</span>6380 \redis:latest \redis-server /redis.conf</code></pre><p>或显式的指定路径</p><pre class=" language-bash"><code class="language-bash">$ docker <span class="token function">service</span> create \--name redis \--config source<span class="token operator">=</span>redis.conf,target<span class="token operator">=</span>/etc/redis.conf \--publish published<span class="token operator">=</span>6379,target<span class="token operator">=</span>6380 \redis:latest \redis-server /etc/redis.conf</code></pre><p>以上两种创建服务的方法都可以</p><h4 id="验证-config"><a href="#验证-config" class="headerlink" title="验证 config"></a>验证 config</h4><p>使用 redis 管理工具连接 redis，链接地址填写 192.168.99.100</p><p><img src="http://static.xiangdangnian.net.cn/20200903172350.png" alt="连接配置"><br><img src="http://static.xiangdangnian.net.cn/20200903172402.png" alt="连接结果"></p><h4 id="使用中的-config-无法删除"><a href="#使用中的-config-无法删除" class="headerlink" title="使用中的 config 无法删除"></a>使用中的 config 无法删除</h4><pre class=" language-bash"><code class="language-bash">$ docker config <span class="token function">rm</span> redis.confError response from daemon: rpc error: code <span class="token operator">=</span> InvalidArgument desc <span class="token operator">=</span> config <span class="token string">'redis.conf'</span> is <span class="token keyword">in</span> use by the following service: redis</code></pre><h4 id="通过更新的方式删除-config"><a href="#通过更新的方式删除-config" class="headerlink" title="通过更新的方式删除 config"></a>通过更新的方式删除 config</h4><pre class=" language-bash"><code class="language-bash">docker <span class="token function">service</span> update --config-rm redis.conf redisdocker config <span class="token function">rm</span> redis.confredis.conf</code></pre><h4 id="移除-redis-服务"><a href="#移除-redis-服务" class="headerlink" title="移除 redis 服务"></a>移除 redis 服务</h4><pre class=" language-bash"><code class="language-bash">$ docker <span class="token function">service</span> <span class="token function">rm</span> redis</code></pre><p><img src="http://static.xiangdangnian.net.cn/4vB3ZRunrw8VzSW6cLpJyaibKfYTNCU0.png" alt="程序员的艺术人生"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 学习笔记（九）</title>
      <link href="/2020/08/30/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%9D%EF%BC%88Laradock%E4%BD%BF%E7%94%A8%EF%BC%89/"/>
      <url>/2020/08/30/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%9D%EF%BC%88Laradock%E4%BD%BF%E7%94%A8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="克隆-laradock-到本地"><a href="#克隆-laradock-到本地" class="headerlink" title="克隆 laradock 到本地"></a>克隆 laradock 到本地</h2><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cd</span> ~$ <span class="token function">git</span> clone https://github.com/Laradock/laradock.git$ <span class="token function">cd</span> laradock$ <span class="token function">git</span> checkout -b v11.0</code></pre><h2 id="在-laradock-同级创建-wwwroot-目录作为网站主目录"><a href="#在-laradock-同级创建-wwwroot-目录作为网站主目录" class="headerlink" title="在 laradock 同级创建 wwwroot 目录作为网站主目录"></a>在 laradock 同级创建 wwwroot 目录作为网站主目录</h2><pre class=" language-bash"><code class="language-bash">$ <span class="token function">mkdir</span> ~/wwwroot</code></pre><h2 id="复制-laradock-项目中的-env-example-到当前目录并改名为-env"><a href="#复制-laradock-项目中的-env-example-到当前目录并改名为-env" class="headerlink" title="复制 laradock 项目中的 env-example 到当前目录并改名为 .env"></a>复制 laradock 项目中的 env-example 到当前目录并改名为 .env</h2><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cp</span> env-example .env</code></pre><h2 id="编辑-env"><a href="#编辑-env" class="headerlink" title="编辑 .env"></a>编辑 .env</h2><p><strong>在该配置文件中可以修改各种容器的配置，例如 mysql 密码、php 版本等，大家可以自行参考</strong></p><p>一下内容是需要修改的地方</p><pre><code># 设置网站主目录APP_CODE_PATH_HOST=../wwwroot# 开启 api 源镜像（嘿嘿，这就是开源软件的好处，我们可以给项目提交 pr，让项目可以兼容我国的网络）CHANGE_SOURCE=true# 设置 composer 镜像地址WORKSPACE_COMPOSER_REPO_PACKAGIST=https://mirrors.aliyun.com/composer# 设置 npm 镜像地址WORKSPACE_NPM_REGISTRY=https://registry.npm.taobao.org</code></pre><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>启动我们需要等容器，然后就是耐心的等待了</p><pre class=" language-bash"><code class="language-bash">$ docker-compose up -d nginx mysql redis workspace</code></pre><h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p>当看到如下内容就表示启动成功了</p><pre class=" language-bash"><code class="language-bash">Creating laradock_mysql_1            <span class="token punctuation">..</span>. <span class="token keyword">done</span>Creating laradock_docker-in-docker_1 <span class="token punctuation">..</span>. <span class="token keyword">done</span>Creating laradock_redis_1            <span class="token punctuation">..</span>. <span class="token keyword">done</span>Creating laradock_workspace_1        <span class="token punctuation">..</span>. <span class="token keyword">done</span>Creating laradock_php-fpm_1          <span class="token punctuation">..</span>. <span class="token keyword">done</span>Creating laradock_nginx_1            <span class="token punctuation">..</span>. <span class="token keyword">done</span></code></pre><h2 id="创建-Laravel-项目"><a href="#创建-Laravel-项目" class="headerlink" title="创建 Laravel 项目"></a>创建 Laravel 项目</h2><p>接下来让我们看下 laradock 有什么优势吧</p><h3 id="创建一个-laravel-项目（我们使用-learnku-的电商实战项目进行演示）"><a href="#创建一个-laravel-项目（我们使用-learnku-的电商实战项目进行演示）" class="headerlink" title="创建一个 laravel 项目（我们使用 learnku 的电商实战项目进行演示）"></a>创建一个 laravel 项目（我们使用 learnku 的电商实战项目进行演示）</h3><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cd</span> ~/wwwroot$ <span class="token function">git</span> clone -b L05_7.x https://github.com/summerblue/laravel-shop.git</code></pre><h3 id="进入-workspace-容器配置项目"><a href="#进入-workspace-容器配置项目" class="headerlink" title="进入 workspace 容器配置项目"></a>进入 workspace 容器配置项目</h3><pre class=" language-bash"><code class="language-bash">$ docker-compose <span class="token function">exec</span> workspace <span class="token function">bash</span>workspace<span class="token comment" spellcheck="true"># cd laravel-shop</span>workspace<span class="token comment" spellcheck="true"># composer install</span>workspace<span class="token comment" spellcheck="true"># cp .env.example .env</span>workspace<span class="token comment" spellcheck="true"># php artisan key:generate</span>workspace<span class="token comment" spellcheck="true"># vim .env    //修改数据库部分，内容如下。</span>workspace<span class="token comment" spellcheck="true"># php artisan migrate</span>workspace<span class="token comment" spellcheck="true"># php artisan db:seed</span></code></pre><p><img src="http://static.xiangdangnian.net.cn/20200907115535.png" alt="env 配置"></p><p><strong>查看 laradock 中的 .env 文件，获取数据库相关信息</strong><br><img src="http://static.xiangdangnian.net.cn/20200907115641.png" alt=""></p><h3 id="配置-nginx"><a href="#配置-nginx" class="headerlink" title="配置 nginx"></a>配置 nginx</h3><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cd</span> ~/laradock/nginx/sites$ <span class="token function">cp</span> laravel.conf.example shop.conf//修改配置文件如下图所示$ vim shop.conf   $ <span class="token function">cd</span> ~/laradock/$ docker-compose restart nginx</code></pre><p><img src="http://static.xiangdangnian.net.cn/20200907120035.png" alt="nginx 配置文件"></p><h3 id="更改项目所属用户"><a href="#更改项目所属用户" class="headerlink" title="更改项目所属用户"></a>更改项目所属用户</h3><p><strong>由于权限问题，需要将项目的所属用户设置为 laradock 用户</strong></p><pre><code>$ docker-compose exec workspace bash# chown -R laradock:laradock laravel-shop</code></pre><h3 id="将前端项目打包"><a href="#将前端项目打包" class="headerlink" title="将前端项目打包"></a>将前端项目打包</h3><p>访问我们设置的域名后发现错误了。由于laravel 项目前端需要打包才能正常运行，下面执行打包操作。</p><p><img src="http://static.xiangdangnian.net.cn/20200907142614.png" alt=""> </p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># npm install </span><span class="token comment" spellcheck="true"># npm run prod</span></code></pre><h3 id="重新访问项目"><a href="#重新访问项目" class="headerlink" title="重新访问项目"></a>重新访问项目</h3><p><em>如果能看到下面的内容就表示成功了</em></p><p><img src="http://static.xiangdangnian.net.cn/20200907142935.png" alt=""></p><p><img src="http://static.xiangdangnian.net.cn/4vB3ZRunrw8VzSW6cLpJyaibKfYTNCU0.png" alt="程序员的艺术人生"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 学习笔记（八）</title>
      <link href="/2020/08/27/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AB%EF%BC%88docker-compose%EF%BC%89/"/>
      <url>/2020/08/27/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AB%EF%BC%88docker-compose%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-docker-compose-搭建-LNMP-开发环境"><a href="#使用-docker-compose-搭建-LNMP-开发环境" class="headerlink" title="使用 docker-compose 搭建 LNMP 开发环境"></a>使用 docker-compose 搭建 LNMP 开发环境</h1><p>上一集我们已经可以通过 docker 搭建 LNMP 的开发环境了，但是想必大家也发现配置挺复杂的，每个容器启动都有好长的命令。那有没有更简单一点的方式呢？有的，就是今天要学习的——docker-compose。</p><blockquote><p>什么是 docker-compose 呢？</p></blockquote><p>docker-compose 是一个使用 python 编写，用于定义和运行多容器的工具。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="二进制包安装"><a href="#二进制包安装" class="headerlink" title="二进制包安装"></a>二进制包安装</h3><pre class=" language-bash"><code class="language-bash">// 由于网络原因可以将文件直接下载下来，然后放到对应的位置，最后赋予相应的执行权限也是一样的$ <span class="token function">sudo</span> curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> -s<span class="token variable">`</span></span>-<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> -m<span class="token variable">`</span></span> <span class="token operator">></span> /usr/local/bin/docker-compose$ <span class="token function">sudo</span> <span class="token function">chmod</span> +x /usr/local/bin/docker-compose</code></pre><h3 id="pip-安装"><a href="#pip-安装" class="headerlink" title="pip 安装"></a>pip 安装</h3><pre class=" language-bash"><code class="language-bash">$ <span class="token function">sudo</span> pip <span class="token function">install</span> -U docker-compose</code></pre><h4 id="bash-补全命令"><a href="#bash-补全命令" class="headerlink" title="bash 补全命令"></a>bash 补全命令</h4><p>使用如下命令使 docker-compose 具有代码提示功能（如不生效，可以退出终端重新进入就可以了）</p><pre class=" language-bash"><code class="language-bash">$ curl -L https://raw.githubusercontent.com/docker/compose/1.25.5/contrib/completion/bash/docker-compose <span class="token operator">></span> /etc/bash_completion.d/docker-compose</code></pre><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>通过二进制包安装的卸载方式</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">rm</span> /usr/local/bin/docker-compose</code></pre><p>通过 pip 安装的卸载方式</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">sudo</span> pip uninstall docker-compose</code></pre><h2 id="通过-docker-compose-配置-LNMP-开发环境"><a href="#通过-docker-compose-配置-LNMP-开发环境" class="headerlink" title="通过 docker-compose 配置 LNMP 开发环境"></a>通过 docker-compose 配置 LNMP 开发环境</h2><blockquote><p>我们直接将上一集中配置的 LNMP 环境通过docker-compose 的方式在配置一遍</p></blockquote><p>主要步骤如下：</p><ol><li>创建一个目录 easy-docker 作为 docker-compose 目录</li><li>运行一个临时的 nginx 容器，将 nginx 配置文件复制到 easy-docker 目录中，并修改配置文件</li><li>在 easy-docker 目录中创建 php 目录并在该目录下创建 Dockerfile 文件</li><li>编辑 phpfpm 目录下的 Dockerfile 文件</li><li>在 easy-docker 目录下创建 docker-compose.yml 文件并编辑</li><li>使用 docker-compose up -d 运行</li></ol><pre class=" language-bash"><code class="language-bash">// 创建一个目录用于保存 docker-compose 项目所需的内容$ <span class="token function">mkdir</span> easy-docker <span class="token operator">&amp;&amp;</span> <span class="token function">cd</span> easy-docker// 运行一个临时的 nginx 容器并将配置文件复制到当前目录$ docker run --name temp-nginx -d nginx$ docker <span class="token function">cp</span> temp-nginx:/etc/nginx ./// 删除临时 nginx 容器$ docker <span class="token function">rm</span> -f temp-nginx// 修改 nginx 配置文件（详情见下图）$ vim nginx/conf.d/default.conf// 创建一个目录作为 nginx 容器项目主目录$ <span class="token function">mkdir</span> wwwroot// 创建 phpfpm 目录$ <span class="token function">mkdir</span> phpfpm <span class="token operator">&amp;&amp;</span> <span class="token function">cd</span> phpfpm// 创建 Dockerfile 文件（见下图）$ vim Dockerfile// 在 easy-docker 目录下创建 docker-compose.yml 文件（见下文）$ <span class="token function">cd</span> <span class="token punctuation">..</span>$ vim docker-compose.yml//构建镜像并启动容器$ docker-compose up// 测试$ <span class="token keyword">echo</span> <span class="token string">"&lt;?php phpinfo(); ?>"</span> <span class="token operator">></span> ./wwwroot/info.php// 访问页面可以看到 phpinfo 页面怎成功</code></pre><hr><p>nginx 配置文件</p><p><img src="http://static.xiangdangnian.net.cn/20200826104323.png" alt="nginx 配置文件"></p><hr><p>phpfpm Dockerfile 内容</p><pre class=" language-bash"><code class="language-bash">FROM php:7.2-fpmRUN <span class="token function">sed</span> -i <span class="token string">"s@http://deb.debian.org@http://mirrors.aliyun.com@g"</span> /etc/apt/sources.list \      <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> -Rf /var/lib/apt/lists/* \      <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> -y \                libfreetype6-dev \                libjpeg62-turbo-dev \                libpng-dev \        <span class="token operator">&amp;&amp;</span> docker-php-ext-install -j<span class="token variable"><span class="token variable">$(</span>nproc<span class="token variable">)</span></span> <span class="token function">iconv</span> \        <span class="token operator">&amp;&amp;</span> docker-php-ext-configure gd --with-freetype-dir<span class="token operator">=</span>/usr/include/ --with-jpeg-dir<span class="token operator">=</span>/usr/include/ \        <span class="token operator">&amp;&amp;</span> docker-php-ext-install -j<span class="token variable"><span class="token variable">$(</span>nproc<span class="token variable">)</span></span> gd \   <span class="token operator">&amp;&amp;</span> docker-php-ext-install mysqli pdo pdo_mysql</code></pre><hr><p>docker-compose 文件内容</p><p><img src="http://static.xiangdangnian.net.cn/20200827171943.png" alt=""></p><p>上面的 docker-compose.yml 文件只展示了部分指令的用法，可以参考<a href="https://yeasy.gitbook.io/docker_practice/compose/compose_file" target="_blank" rel="noopener">链接</a>查看其他指令的详细用法。</p><h2 id="docker-compose-常用命令"><a href="#docker-compose-常用命令" class="headerlink" title="docker-compose 常用命令"></a>docker-compose 常用命令</h2><p>该命令非常常用，主要功能是尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p><pre class=" language-bash"><code class="language-bash">$ docker-compose up -d      </code></pre><p>将会停止 up 命令所启动的容器，并移除网络</p><pre class=" language-bash"><code class="language-bash">$ docker-compose down</code></pre><p>其他一些命令类似有 docker 相关命令，只是把关键指令换成 docker-compose 了，例如 docker-compose ps、docker-compose exec 等，可自行尝试。 <a href="https://yeasy.gitbook.io/docker_practice/compose/commands#exec" target="_blank" rel="noopener">相关文档</a></p><h2 id="优秀项目参考"><a href="#优秀项目参考" class="headerlink" title="优秀项目参考"></a>优秀项目参考</h2><p>上面我们只是简单的搭建了一个开发环境，实际上真实的环境会很复杂，我们自己写一个完整的 docker-compose 文件可能比较困难（大神忽略）。那么有什么简单的方法呢？</p><p>下面我推荐两个我用过还不错的项目，大家可以参考学习。</p><p><a href="https://github.com/laradock/laradock" target="_blank" rel="noopener">laradock</a></p><p><a href="https://github.com/khs1994-docker/lnmp" target="_blank" rel="noopener">LNMP</a></p><p><img src="http://static.xiangdangnian.net.cn/4vB3ZRunrw8VzSW6cLpJyaibKfYTNCU0.png" alt="程序员的艺术人生"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 学习笔记（七）</title>
      <link href="/2020/08/25/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83%EF%BC%88%E6%90%AD%E5%BB%BALNMP%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%EF%BC%89/"/>
      <url>/2020/08/25/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83%EF%BC%88%E6%90%AD%E5%BB%BALNMP%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建简单的-LNMP-开发环境"><a href="#搭建简单的-LNMP-开发环境" class="headerlink" title="搭建简单的 LNMP 开发环境"></a>搭建简单的 LNMP 开发环境</h1><h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><ol><li>创建 nginx 容器</li><li>创建 phpfpm 容器</li><li>创建自定义网络</li><li>配置 nginx 和 phpfpm 容器通过自定义网络通信</li><li>创建 mysql 容器</li><li>联通 mysql、phpfpm、nginx 容器间的互通</li><li>测试</li></ol><h3 id="配置-nginx-容器"><a href="#配置-nginx-容器" class="headerlink" title="配置 nginx 容器"></a>配置 nginx 容器</h3><p>通过 <a href="https://hub.docker.com/_/nginx" target="_blank" rel="noopener">docker 仓库中</a>  nginx 镜像的使用方法介绍我们得知 </p><ul><li>nginx的网站主目录在 <code>/usr/share/nginx/html</code></li><li>nginx 的配置文件位置在 <code>/etc/nginx/</code></li></ul><pre class=" language-bash"><code class="language-bash">// 运行一个临时的 nginx 容器$ docker run --name temp-nginx -d nginx// 在主机上创建 lnmp 目录用于放置相关目录$ <span class="token function">mkdir</span> ~/lnmp$ <span class="token function">mkdir</span> ~/lnmp/wwwroot// 将容器中的 nginx 配置文件复制到主机的 lnmp/nginx 目录下$ docker <span class="token function">cp</span> temp-nginx:/etc/nginx ~/lnmp// 删除临时容器$ docker <span class="token function">rm</span> -f temp-nginx// 在主机上创建 nginx 主目录$ <span class="token function">mkdir</span> ~/lnmp/wwwroot// 创建 nginx 容器并绑定上面配置的主目录、配置文件目录$ docker run -d --name nginx \-p 80:80 \--mount type<span class="token operator">=</span>bind,source<span class="token operator">=</span>/root/lnmp/wwwroot,target<span class="token operator">=</span>/usr/share/nginx/html \--mount type<span class="token operator">=</span>bind,source<span class="token operator">=</span>/root/lnmp/nginx,target<span class="token operator">=</span>/etc/nginx \nginx// 创建测试文件$ <span class="token keyword">echo</span> hello LNMP <span class="token operator">></span> index.html</code></pre><p>测试</p><p><img src="http://static.xiangdangnian.net.cn/20200826092608.png" alt="测试结果"></p><h3 id="配置-phpfpm-容器"><a href="#配置-phpfpm-容器" class="headerlink" title="配置 phpfpm 容器"></a>配置 phpfpm 容器</h3><p>使用 Dockerfile 自定义 phpfpm 镜像</p><pre class=" language-bash"><code class="language-bash">// 创建并进入 easy-php 目录$ <span class="token function">mkdir</span> easy-php <span class="token operator">&amp;&amp;</span> <span class="token function">cd</span> easy-php$ <span class="token function">touch</span> Dockerfile</code></pre><blockquote><p>配置 apt 软件源为阿里云、安装 iconv、gd、 pdo、mysqli、pdo_mysql 扩展</p></blockquote><pre class=" language-ymal"><code class="language-ymal">FROM php:7.2-fpmRUN sed -i "s@http://deb.debian.org@http://mirrors.aliyun.com@g" /etc/apt/sources.list \      && rm -Rf /var/lib/apt/lists/* \      && apt-get update && apt-get install -y \                libfreetype6-dev \                libjpeg62-turbo-dev \                libpng-dev \        && docker-php-ext-install -j$(nproc) iconv \        && docker-php-ext-configure gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ \        && docker-php-ext-install -j$(nproc) gd \   && docker-php-ext-install mysqli pdo pdo_mysql</code></pre><pre class=" language-bash"><code class="language-bash">// 构建镜像$ docker build -t my-phpfpm-7.2 <span class="token keyword">.</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>省略构建过程Removing intermediate container 57a5d1acfb6b ---<span class="token operator">></span> f7d9f204bec3Successfully built f7d9f204bec3Successfully tagged my-phpfpm-7.2:latest$ docker image <span class="token function">ls</span>REPOSITORY              TAG                 IMAGE ID            CREATED              SIZEmy-phpfpm-7.2           latest              f7d9f204bec3        About a minute ago   423MB//使用创建好的镜像构建容器$ docker run -d --name phpfpm \--mount type<span class="token operator">=</span>bind,source<span class="token operator">=</span>/root/lnmp/wwwroot,target<span class="token operator">=</span>/usr/share/nginx/html \my-phpfpm-7.2// 创建一个 lnmp 网络$ docker network create lnmp// 将 nginx 容器和 phpfpm 容器加入 lnmp 网络$ docker network connect lnmp nginx$ docker network connect lnmp phpfpm// 修改 nginx 配置文件用于支持 php// 首先备份一下配置文件$ <span class="token function">cd</span> /root/lnmp/nginx/conf.d$ <span class="token function">cp</span> default.conf default.conf.bak$ vim default.conf // 修改后的内容如下</code></pre><p><img src="http://static.xiangdangnian.net.cn/20200826104323.png" alt=""></p><p>创建测试文件</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">touch</span> ~/lnmp/wwwroot/info.php$ <span class="token keyword">echo</span> <span class="token string">"&lt;?php phpinfo(); ?>"</span> <span class="token operator">></span> ~/lnmp/wwwroot/info.php</code></pre><p>访问测试</p><p><img src="http://static.xiangdangnian.net.cn/20200826104727.png" alt="测试结果"></p><h3 id="配置-MySQL-容器"><a href="#配置-MySQL-容器" class="headerlink" title="配置 MySQL 容器"></a>配置 MySQL 容器</h3><pre class=" language-bash"><code class="language-bash">// 创建 mysql 容器$ docker run --name mysql -e MYSQL_ROOT_PASSWORD<span class="token operator">=</span>root -d -p 3306:3306  mysql:5.7// 将 mysql 容器加入自定义网路 lnmp 中$ docker network connect lnmp mysql// 创建 mysql 文件链接 mysql $ <span class="token function">touch</span> /root/lnmp/wwwroot/mysql.php      // 内容如下</code></pre><p><img src="http://static.xiangdangnian.net.cn/20200826112942.png" alt="mysql 文件内容"></p><p>测试（看到如下页面则表示成功）</p><p><img src="http://static.xiangdangnian.net.cn/20200826113009.png" alt="测试结果"></p><p>进入 mysql 容器验证</p><pre class=" language-bash"><code class="language-bash">$ docker <span class="token function">exec</span> -it mysql <span class="token function">bash</span><span class="token comment" spellcheck="true"># mysql -uroot -proot</span>mysql<span class="token operator">></span> show databases<span class="token punctuation">;</span>+--------------------+<span class="token operator">|</span> Database           <span class="token operator">|</span>+--------------------+<span class="token operator">|</span> information_schema <span class="token operator">|</span><span class="token operator">|</span> mysql              <span class="token operator">|</span><span class="token operator">|</span> performance_schema <span class="token operator">|</span><span class="token operator">|</span> sys                <span class="token operator">|</span><span class="token operator">|</span> <span class="token function">test</span>               <span class="token operator">|</span>+--------------------+5 rows <span class="token keyword">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span>0.01 sec<span class="token punctuation">)</span></code></pre><p>大功告成，通过上面的内容就可以配置一个简单的 lnmp 的开发环境了，下集见。</p><p><img src="http://static.xiangdangnian.net.cn/4vB3ZRunrw8VzSW6cLpJyaibKfYTNCU0.png" alt="程序员的艺术人生"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 学习笔记（六）</title>
      <link href="/2020/08/24/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD%EF%BC%88dockerfile%20%E5%AE%9A%E5%88%B6%E9%95%9C%E5%83%8F%EF%BC%89/"/>
      <url>/2020/08/24/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD%EF%BC%88dockerfile%20%E5%AE%9A%E5%88%B6%E9%95%9C%E5%83%8F%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-Dockerfile-定制镜像"><a href="#使用-Dockerfile-定制镜像" class="headerlink" title="使用 Dockerfile 定制镜像"></a>使用 Dockerfile 定制镜像</h1><blockquote><p>什么是 Dockerfile 呢？</p></blockquote><p>Dockerfile 是一个文本文档，其中包含用户可以在命令行上调用以组装映像的所有命令。Docker 可以通过阅读该文件中的指令来自动构建映像。（类似于 Linux 上的 bash 脚本，Docker 通过该脚本构建镜像）</p><h2 id="使用-dockerfile-制作一个-nginx-镜像"><a href="#使用-dockerfile-制作一个-nginx-镜像" class="headerlink" title="使用 dockerfile 制作一个 nginx 镜像"></a>使用 dockerfile 制作一个 nginx 镜像</h2><pre class=" language-bash"><code class="language-bash">$ <span class="token function">mkdir</span> mynginx$ <span class="token function">cd</span> mynginx$ <span class="token function">touch</span> Dockerfile   //首字母必须大写</code></pre><p>Dockerfile 文件内容如下</p><pre><code>FROM nginxRUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html</code></pre><p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，FROM 和 RUN。</p><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>功能：指定基础镜像</p><blockquote><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 FROM 就是指定 基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。</p></blockquote><p>一般使用中我们通过 <a href="https://hub.docker.com/search?q=&amp;type=image&amp;image_filter=official" target="_blank" rel="noopener">Docker Hub</a> 来查找相关镜像。如下图所示，红标中标识的为官方镜像<br><img src="http://static.xiangdangnian.net.cn/20200826144635.png" alt="docker hub"></p><p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 scratch（该镜像不能通过 docker pull 命令直接拉取）。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p><p><em>因为本人只对 PHP 较为熟悉，没有使用过 go，这个也不是很了解，就先跳过了</em></p><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>功能：执行命令</p><blockquote><p>用来执行命令行命令的</p></blockquote><p>实际使用下有两种格式</p><ol><li>shell 格式： <code>RUN &lt;命令&gt;</code></li><li>exec 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code></li></ol><p>Dockerfile 中每一个指令都会建立一层，RUN 也不例外。每一个 RUN 执行结束后，都会 commit 这一层的修改，构成新的镜像。所以在使用中尽力减少指令。</p><pre><code>FROM debian:stretchRUN apt-get updateRUN apt-get install -y gcc libc6-dev make wgetRUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;RUN mkdir -p /usr/src/redisRUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1RUN make -C /usr/src/redisRUN make -C /usr/src/redis install</code></pre><p>上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。我们在以后的使用应该避免。正确的写法如下所示：</p><pre><code>FROM debian:stretchRUN buildDeps=&#39;gcc libc6-dev make wget&#39; \    &amp;&amp; apt-get update \    &amp;&amp; apt-get install -y $buildDeps \    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot; \    &amp;&amp; mkdir -p /usr/src/redis \    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \    &amp;&amp; make -C /usr/src/redis \    &amp;&amp; make -C /usr/src/redis install \    &amp;&amp; rm -rf /var/lib/apt/lists/* \    &amp;&amp; rm redis.tar.gz \    &amp;&amp; rm -r /usr/src/redis \    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</code></pre><p>在上一个 Dockerfile 中所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里我们仅仅使用一个 RUN 指令，并使用 &amp;&amp; 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。</p><p><strong>在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</strong></p><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>命里格式： <code>docker build [选项] &lt;上下文路径/URL/-&gt;</code></p><pre class=" language-bash"><code class="language-bash">$ docker build -t mynginx:v1 <span class="token keyword">.</span>Sending build context to Docker daemon  2.048kBStep 1/2 <span class="token keyword">:</span> FROM nginx ---<span class="token operator">></span> 08393e824c32Step 2/2 <span class="token keyword">:</span> RUN <span class="token keyword">echo</span> <span class="token string">'&lt;h1>Hello, Docker!&lt;/h1>'</span> <span class="token operator">></span> /usr/share/nginx/html/index.html ---<span class="token operator">></span> Running <span class="token keyword">in</span> 1d7edd724b5fRemoving intermediate container 1d7edd724b5f ---<span class="token operator">></span> e29ba82c8e43Successfully built e29ba82c8e43Successfully tagged mynginx:v1// 查看刚刚创建的镜像$ docker image <span class="token function">ls</span>REPOSITORY              TAG                 IMAGE ID            CREATED             SIZEmynginx                 v1                  e29ba82c8e43        3 minutes ago       132MB</code></pre><ol><li>-t 表示指定镜像的名称和标签，格式为 name:tag</li><li>最后有个点，表示构建的上下文路径为当前目录</li></ol><h2 id="其他构建方式"><a href="#其他构建方式" class="headerlink" title="其他构建方式"></a>其他构建方式</h2><ol><li>通过 Git repo 进行构建</li><li>使用 tar 包进行构建</li></ol><h2 id="常用指令介绍"><a href="#常用指令介绍" class="headerlink" title="常用指令介绍"></a>常用指令介绍</h2><h4 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h4><p>格式：</p><ul><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt; &lt;目标路径&gt;</code>  (常用)</li><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;, &quot;&lt;目标路径&gt;&quot;]</code></li></ul><p>构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置。</p><pre class=" language-bash"><code class="language-bash">COPY package.json /usr/src/app/</code></pre><p>加上 –chown=<user>:<group> 选项来改变文件的所属用户及所属组</group></user></p><pre class=" language-bash"><code class="language-bash">COPY --chown<span class="token operator">=</span>55:mygroup files* /mydir/COPY --chown<span class="token operator">=</span>bin files* /mydir/COPY --chown<span class="token operator">=</span>1 files* /mydir/COPY --chown<span class="token operator">=</span>10:11 files* /mydir/</code></pre><h4 id="ADD-更高级的复制"><a href="#ADD-更高级的复制" class="headerlink" title="ADD 更高级的复制"></a>ADD 更高级的复制</h4><p>和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。</p><ul><li>&lt;源路径&gt; 可以是一个 URL。Docker 引擎会试图去下载这个链接的文件放到 &lt;目标路径&gt; 去。下载后的文件权限自动设置为 600</li><li>&lt;源路径&gt; 为一个 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，ADD 指令将会自动解压缩这个压缩文件到 &lt;目标路径&gt; 去。</li></ul><p><strong>在 Docker 官方的 Dockerfile 最佳实践文档 中要求，尽可能的使用 COPY，因为 COPY 的语义很明确，就是复制文件而已，而 ADD 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 ADD 的场合，就是所提及的需要自动解压缩的场合。</strong></p><h4 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h4><blockquote><p>Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。CMD 指令就是用于指定默认的容器主进程的启动命令的。</p></blockquote><p>格式：</p><ul><li>shell 格式：CMD &lt;命令&gt;</li><li>exec 格式：CMD [“可执行文件”, “参数1”, “参数2”…]   （推荐，一定要使用双引号）</li></ul><h4 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h4><blockquote><p>用于设置环境变量，无论是后面的其它指令，如 RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。</p></blockquote><p>格式：</p><ul><li>ENV <code>&lt;key&gt; &lt;value&gt;</code></li><li>ENV <code>&lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li></ul><h4 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h4><p>格式：</p><ul><li><code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></li></ul><blockquote><p>与 ENV 指令一样，都是设置环境变量。所不同的是，ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。</p></blockquote><p>Dockerfile 中的 ARG 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 docker build 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p><h4 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h4><p>格式：</p><ul><li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li><li><code>VOLUME &lt;路径&gt;</code></li></ul><p>示例：</p><p>容器中的 /data 目录自动挂载到匿名卷中</p><pre class=" language-bash"><code class="language-bash">VOLUME /data</code></pre><p><strong>该指令可以在运行时被覆盖</strong></p><pre class=" language-bash"><code class="language-bash">docker run -d -v mydata:/data xxxx</code></pre><h4 id="EXPOSE-暴露端口"><a href="#EXPOSE-暴露端口" class="headerlink" title="EXPOSE 暴露端口"></a>EXPOSE 暴露端口</h4><p>格式：</p><ul><li><code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></li></ul><p>声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明就会开启这个端口的服务。</p><p><strong>写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</strong></p><h4 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h4><p>格式：</p><ul><li>WORKDIR &lt;工作目录路径&gt;。</li></ul><p>使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。</p><pre class=" language-bash"><code class="language-bash">RUN <span class="token function">cd</span> /appRUN <span class="token keyword">echo</span> <span class="token string">"hello"</span> <span class="token operator">></span> world.txt</code></pre><p>使用上面的内容构建镜像后会发现根本找不到 <code>/app/world.txt</code> 文件。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 Dockerfile 中，这两行 RUN 命令的执行环境根本不同，是两个完全不同的容器。这就是对 Dockerfile 构建分层存储的概念不了解所导致的错误。</p><p><strong>因此如果需要改变以后各层的工作目录的位置，那么应该使用 WORKDIR 指令。</strong></p><h4 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h4><p>格式：</p><ul><li><code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></li></ul><p>USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。WORKDIR 是改变工作目录，USER 则是改变之后层的执行 RUN, CMD 以及 ENTRYPOINT 这类命令的身份。当然，和 WORKDIR 一样，USER 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p><p><em>其他指令参考官方文档</em></p><p><img src="http://static.xiangdangnian.net.cn/4vB3ZRunrw8VzSW6cLpJyaibKfYTNCU0.png" alt="程序员的艺术人生"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 学习笔记（五）</title>
      <link href="/2020/08/22/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94%EF%BC%88%E6%95%B0%E6%8D%AE%E5%8D%B7%EF%BC%89/"/>
      <url>/2020/08/22/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94%EF%BC%88%E6%95%B0%E6%8D%AE%E5%8D%B7%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>这一集下先从一张图开始<br><img src="http://static.xiangdangnian.net.cn/7oOkIDb8rW10LGfRNhsvdp5MYcqltBXT.png" alt="数据管理"></p><p>这张图来自于 docker 官方，主要描述了主机和 docker 间的数据沟通的 3 种方式。分别是 <strong>bind mount</strong>、<strong>volume</strong>、<strong>tmpfs mount</strong>。这次主要学习前两种方式。让我们开始吧~</p><h2 id="volume-数据卷"><a href="#volume-数据卷" class="headerlink" title="volume (数据卷)"></a>volume (数据卷)</h2><p>以下内容摘抄自 <a href="https://docs.docker.com/storage" target="_blank" rel="noopener">docker 官方文档</a> </p><p>我们知道默认情况下，在容器内创建的所有文件都存储在可写容器层上，这意味着：</p><ul><li>当容器不再存在时，数据不会持久存在，而且如果另一个进程需要数据，就很难从容器中取出数据。</li><li>容器可写层与容器运行的主机紧密耦合。您不能轻易地将数据移动到其他地方。</li><li>写入到容器的可写层需要一个存储驱动程序来管理文件系统。存储驱动程序提供使用Linux内核的联合文件系统。与使用直接写入主机文件系统的数据卷相比，这种额外的抽象降低了性能。</li></ul><p>通过上面的内容告诉我们，<strong>不要在容器内容写入数据,而要使用 volume</strong>。</p><p>那么数据卷是怎么存储数据的呢？</p><blockquote><p>docker 默认在主机上会有一个特定的区域 /var/lib/docker/volumes/ (Linux)，该区域用来存放 volume。</p></blockquote><h3 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h3><pre class=" language-bash"><code class="language-bash">// 创建一个 volume 名为 my-data$ docker volume create my-datamy-data// 创建一个 名为 nginx1 的 nginx 容器并使用 my-data 为 nginx 的主目录$ docker run -d -p 8080:80 --name nginx1  --mount source<span class="token operator">=</span>nginx-data,target<span class="token operator">=</span>/usr/share/nginx/html nginx814dea34b7dbf2afd724d12ad50254e2a749f0b65684f04c730ac04181857d04// 查看容器的状态$ docker container <span class="token function">ls</span> --format <span class="token string">"table {{.Image}}\t{{.ID}}\t{{.Status}}\t{{.Names}}"</span>IMAGE                   CONTAINER ID        STATUS              NAMESnginx                   814dea34b7db        Up 3 minutes        nginx1// 进入 nginx1 容器$ docker <span class="token function">exec</span> -it nginx1 <span class="token function">bash</span>// 修改 index.html 内容为 hello world<span class="token comment" spellcheck="true"># echo hello world > /usr/share/nginx/html/index.html</span>// 访问 http://127.0.0.1:8080 我们可以看到 hello world 页面// 删除 nginx1 容器$ docker <span class="token function">rm</span> -f nginx1// 创建一个 名为 nginx2 的 nginx 容器也使用 my-data 为 nginx 的主目录$ docker run -d -p 8080:80 --name nginx2  --mount source<span class="token operator">=</span>nginx-data,target<span class="token operator">=</span>/usr/share/nginx/html nginx// 访问 http://127.0.0.1:8080 我们也可以看到 hello world 页面（数据共享）</code></pre><p>通过上面的实例我们知道了：</p><ol><li>volume 和容器是分离的，删除容器并不会删除 volume</li><li>多个容器可以加载相同的卷</li><li>volume 在任何系统的容器上都能工作，方便迁移</li></ol><h3 id="数据卷常用命令"><a href="#数据卷常用命令" class="headerlink" title="数据卷常用命令"></a>数据卷常用命令</h3><ul><li>查看所有数据卷  <code>bash docker volume ls</code></li><li>创建数据卷 <code>bash docker volume create [卷名称]</code></li><li>查看卷详情 <code>bash docker volume inspect &lt;卷名称&gt;</code></li><li>删除数据卷 <code>bash docker volume rm &lt;卷名称&gt;</code></li><li>删除无主的卷 <code>bash docker volume prune</code></li></ul><h3 id="温馨提示：-v-和-–mount-的区别-因为官方建议新用户使用-–mount，所以本文只记录-–mount-的使用方式"><a href="#温馨提示：-v-和-–mount-的区别-因为官方建议新用户使用-–mount，所以本文只记录-–mount-的使用方式" class="headerlink" title="温馨提示：-v 和 –mount 的区别 (因为官方建议新用户使用 –mount，所以本文只记录 –mount 的使用方式)"></a>温馨提示：-v 和 –mount 的区别 (因为官方建议新用户使用 –mount，所以本文只记录 –mount 的使用方式)</h3><blockquote><p>在查看网上的各种资料的时候发现有人用 -v 参数而有的人又用 –mount 参数，为了确认他们之间的区别我特意查了一下 docker 官网，现在把内容放出来</p></blockquote><ul><li>最初，-v 或–volume 参数用于独立容器，而 –mount 参数用于群服务。 但是，从 Docker 17.06 开始，您也可以将 –mount 用于独立容器。 通常，–mount 更为明确和详细。 他们直接最大的区别是 -v 语法在一个字段中将所有选项组合在一起，而 –mount 语法将它们分开。 </li><li>新用户应该尝试—mount语法，它比—卷语法更简单。</li></ul><hr><p><strong>上面的内容主要讲述的是 local 驱动下的 volume，实际上 volume 还可以使用其他的驱动，这里先记录一下，后面在在继续学习。</strong></p><h2 id="bind-mount-挂载主机目录"><a href="#bind-mount-挂载主机目录" class="headerlink" title="bind mount 挂载主机目录"></a>bind mount 挂载主机目录</h2><blockquote><p>该方式实际上是将主机上的一个目录映射到容器中的一个目录。（使用过虚拟机的朋友应该比较熟悉）</p></blockquote><p><strong>如果将空文件或目录挂载到容器，容器中的该目录又有文件，那么，这些文件将会被复制到主机上的目录中。如果将非空的文件或目录挂载到容器，容器中的该目录也有文件，那么，容器中的文件将会被隐藏。</strong></p><h3 id="实例演示-1"><a href="#实例演示-1" class="headerlink" title="实例演示"></a>实例演示</h3><pre class=" language-bash"><code class="language-bash">// 在主机上创建一个 my-data 目录$ <span class="token function">mkdir</span> ~/my-data// 创建一个 名为 nginx3 的 nginx 容器并挂载 my-data 为 nginx 的主目录$ <span class="token function">cd</span> ~$ docker run -d -p 8080:80 --name nginx3 --mount type<span class="token operator">=</span>bind,source<span class="token operator">=</span><span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>"</span>/my-data,target<span class="token operator">=</span>/usr/share/nginx/html nginx// 在 my-data 目录中创建 index.html 并写入内容$ <span class="token function">touch</span> my-data/index.html$ <span class="token keyword">echo</span> hello bind <span class="token function">type</span> <span class="token operator">></span> my-data/index.html// 使用浏览器访问 http://127.0.0.1:8080  可以正常显示 hello bind <span class="token function">type</span>// 查看 nginx3 容器的详情，注意 mounts 部分，很清晰的显示了绑定的关系$ docker inspect nginx3<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token string">"Mounts"</span>:<span class="token punctuation">[</span>    <span class="token punctuation">{</span>        <span class="token string">"Type"</span><span class="token keyword">:</span><span class="token string">"bind"</span>,        <span class="token string">"Source"</span><span class="token keyword">:</span><span class="token string">"/Users/cc/my-data"</span>,        <span class="token string">"Target"</span><span class="token keyword">:</span><span class="token string">"/usr/share/nginx/html"</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span></code></pre><h2 id="tmpfs-方式-（以后学习）"><a href="#tmpfs-方式-（以后学习）" class="headerlink" title="tmpfs 方式 （以后学习）"></a>tmpfs 方式 （以后学习）</h2><blockquote><p>tmpfs，仅存储在主机系统的内存中，不会写入主机的文件系统。</p></blockquote><hr><p><img src="http://static.xiangdangnian.net.cn/4vB3ZRunrw8VzSW6cLpJyaibKfYTNCU0.png" alt="程序员的艺术人生"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开源艺术二维码在线生成器工具</title>
      <link href="/2020/08/19/%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"/>
      <url>/2020/08/19/%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<h1 id="开源艺术二维码在线生成器工具"><a href="#开源艺术二维码在线生成器工具" class="headerlink" title="开源艺术二维码在线生成器工具"></a>开源艺术二维码在线生成器工具</h1><p><img src="http://static.xiangdangnian.net.cn/I75nBYMS8XAVlLxEzvDiFT4gfotU1dQG.jpg" alt="艺术二维码"></p><blockquote><p>上图中的二维码大家觉得怎么样？是不是非常漂亮，有没有眼前一亮呢？</p></blockquote><p>今天给大家推荐一款在线生成各种艺术二维码的工具。</p><p>首先把工具的地址告诉大家：<a href="https://qrbtf.com" target="_blank" rel="noopener">https://qrbtf.com</a></p><p>怎么使用呢？</p><p>非常简单，一共就四步</p><ol><li>把需要生成二维码的链接复制进去</li><li>选择对应的模板</li><li>填写相应的参数</li><li>下载</li></ol><p>是不是非常简单，大家赶紧试试吧。</p><p>另外，QRBTF 相比绝大多数“在线二维码制作器”的项目，最大的特色在于它完全是使用 Javascript 前端生成的，有着丰富的参数化样式设置。它不仅能生成矢量的 SVG 格式图片，甚至也提供了 API，适合开发者、网站站长在各类 WEB 项目中调用实现 二维码生成。</p><p>另外，因为 QRBTF 是开源的，所以如果你有自己的服务器，也可以自建一个属于自己的二维码制作网站。而有意学习前端知识和 Javascript 开发的同学，也可以借这个项目的代码深入了解。</p><p><img src="http://static.xiangdangnian.net.cn/4vB3ZRunrw8VzSW6cLpJyaibKfYTNCU0.png" alt="程序员的艺术人生"></p>]]></content>
      
      
      <categories>
          
          <category> 应用推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 学习笔记（四）</title>
      <link href="/2020/08/19/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%EF%BC%88%E7%BD%91%E7%BB%9C%EF%BC%89/"/>
      <url>/2020/08/19/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%EF%BC%88%E7%BD%91%E7%BB%9C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="docker-网络"><a href="#docker-网络" class="headerlink" title="docker 网络"></a>docker 网络</h1><blockquote><p>通过前面的学习，我们已经可以通过 image 来创建相关的容器，例如：创建一个 mysql 容器，nginx 容器、php-fpm 容器。但是我们想要使用这些容器作为开发或者生产的环境还缺少关键的一步，那就是容器间的通信。这一集我们来学习容器间的网络通信</p></blockquote><h2 id="容器间网络互连"><a href="#容器间网络互连" class="headerlink" title="容器间网络互连"></a>容器间网络互连</h2><p>Docker 默认提供了三种网络模式、分别是bridge、host、none。可以使用如下命令查看</p><pre class=" language-bash"><code class="language-bash">$ docker network <span class="token function">ls</span>NETWORK ID          NAME                DRIVER              SCOPEb7ad6ddfa6be        bridge              bridge              local8eceb8218986        host                host                local0cedda606a66        none                null                local</code></pre><h3 id="bridge-桥接模式"><a href="#bridge-桥接模式" class="headerlink" title="bridge 桥接模式"></a>bridge 桥接模式</h3><p>原理：在主机上虚拟出一个docker0 的<a href="https://baike.baidu.com/item/%E7%BD%91%E6%A1%A5" target="_blank" rel="noopener">网桥</a>，默认创建的容器都会虚拟出网卡和这个网桥连接，容器的 ip 地址从 172.17.0.0/16 地址段生成。</p><p><img src="http://static.xiangdangnian.net.cn/16828bdd2287ee1c.png" alt="网络连接示意图"></p><p><img src="http://static.xiangdangnian.net.cn/FyD8K1folZQ95m6XHPLwTkOzuVJWpaIn.png" alt="docker0"></p><blockquote><p>由于在 mac 和 windows 系统上，docker 的运行方式不太一样（在win、mac 上安装 docker，实际上是安装了一个 docker 虚拟机，而我们创建的容器都是跑在 docker 虚拟机中的）。</p></blockquote><p>mac系统下进入docker 虚拟机 命令</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">screen</span> ~/Library/Containers/com.docker.docker/Data/vms/0/tty</code></pre><p>docker 版本小于18.06 则使用如下命令</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">screen</span> ~/Library/Containers/com.docker.docker/Data/com.docker.driver.amd64-linux/tty</code></pre><h4 id="测试桥接模式-提示符为主机、-提示符为容器内"><a href="#测试桥接模式-提示符为主机、-提示符为容器内" class="headerlink" title="测试桥接模式($ 提示符为主机、# 提示符为容器内)"></a>测试桥接模式($ 提示符为主机、# 提示符为容器内)</h4><p>使用 busybox 镜像进行测试。该镜像非常小并且安装了ping、ifconfig等实用工具，非常适合测试。</p><pre class=" language-bash"><code class="language-bash">$ docker run --name box1 -it --rm busybox sh// 测试网络连通/<span class="token comment" spellcheck="true"># ping www.baidu.com  </span>PING www.baidu.com <span class="token punctuation">(</span>180.97.34.96<span class="token punctuation">)</span>: 56 data bytes64 bytes from 180.97.34.96: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>45 time<span class="token operator">=</span>10.489 ms64 bytes from 180.97.34.96: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>45 time<span class="token operator">=</span>10.512 ms64 bytes from 180.97.34.96: seq<span class="token operator">=</span>2 ttl<span class="token operator">=</span>45 time<span class="token operator">=</span>10.424 ms64 bytes from 180.97.34.96: seq<span class="token operator">=</span>3 ttl<span class="token operator">=</span>45 time<span class="token operator">=</span>10.409 ms^C--- www.baidu.com <span class="token function">ping</span> statistics ---4 packets transmitted, 4 packets received, 0% packet lossround-trip min/avg/max <span class="token operator">=</span> 10.409/10.458/10.512 ms// 查看网卡 ip 地址/<span class="token comment" spellcheck="true"># ifconfig</span>eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:07          inet addr:172.17.0.7  Bcast:172.17.255.255  Mask:255.255.0.0          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:16 errors:0 dropped:0 overruns:0 frame:0          TX packets:8 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:0          RX bytes:1421 <span class="token punctuation">(</span>1.3 KiB<span class="token punctuation">)</span>  TX bytes:622 <span class="token punctuation">(</span>622.0 B<span class="token punctuation">)</span>// 退出容器。使用 Ctrl+P+Q 退出容器但是容器不会关闭// 查看 box1 容器的详细信息,只截取了部分内容$ docker inspect box1<span class="token keyword">.</span><span class="token keyword">.</span><span class="token keyword">.</span><span class="token string">"Networks"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>    <span class="token string">"bridge"</span>:<span class="token punctuation">{</span>        <span class="token string">"IPAMConfig"</span>:null,        <span class="token string">"Links"</span>:null,        <span class="token string">"Aliases"</span>:null,        <span class="token string">"NetworkID"</span><span class="token keyword">:</span><span class="token string">"b7ad6ddfa6beac6b0ebf87dcec3d7ee933478592f16d48b3c01b28cd6a48a7f9"</span>,        <span class="token string">"EndpointID"</span><span class="token keyword">:</span><span class="token string">"30eb2f7a0b5e4dbebe8a8f0522a01e105c65fe6a14d0a6ffe02120af009cff27"</span>,        <span class="token string">"Gateway"</span><span class="token keyword">:</span><span class="token string">"172.17.0.1"</span>,        <span class="token string">"IPAddress"</span><span class="token keyword">:</span><span class="token string">"172.17.0.7"</span>,        <span class="token string">"IPPrefixLen"</span>:16,        <span class="token string">"IPv6Gateway"</span><span class="token keyword">:</span><span class="token string">""</span>,        <span class="token string">"GlobalIPv6Address"</span><span class="token keyword">:</span><span class="token string">""</span>,        <span class="token string">"GlobalIPv6PrefixLen"</span>:0,        <span class="token string">"MacAddress"</span><span class="token keyword">:</span><span class="token string">"02:42:ac:11:00:07"</span>,        <span class="token string">"DriverOpts"</span>:null    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">.</span><span class="token keyword">.</span><span class="token keyword">.</span></code></pre><p>通过上面的例子我们可以很直观的看到 box1 容器使用的是 bridge 模式，分配的 ip 地址为 172.17.0.7 并且可以访问互联网。</p><h3 id="Host-主机模式-提示符为主机、-提示符为容器内"><a href="#Host-主机模式-提示符为主机、-提示符为容器内" class="headerlink" title="Host 主机模式($ 提示符为主机、# 提示符为容器内)"></a>Host 主机模式($ 提示符为主机、# 提示符为容器内)</h3><p>原理：容器不会虚拟出自己的网卡，而是使用宿主机的IP。<br><img src="http://static.xiangdangnian.net.cn/16828bdd20dcb5be" alt="示意图"></p><pre class=" language-bash"><code class="language-bash">// 创建一个容器并加入 host 网络$ docker run --name box2 -it --network host busybox// 在容器中查看网卡 eth0<span class="token comment" spellcheck="true"># ifconfig eth0</span>eth0      Link encap:Ethernet  HWaddr FA:16:3E:F4:68:C0          inet addr:192.168.0.3  Bcast:192.168.0.255  Mask:255.255.255.0          inet6 addr: fe80::f816:3eff:fef4:68c0/64 Scope:Link          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:612175 errors:0 dropped:0 overruns:0 frame:0          TX packets:203387 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000          RX bytes:725999816 <span class="token punctuation">(</span>692.3 MiB<span class="token punctuation">)</span>  TX bytes:74349925 <span class="token punctuation">(</span>70.9 MiB<span class="token punctuation">)</span>// 测试网络连通/<span class="token comment" spellcheck="true"># ping www.baidu.com  </span>PING www.baidu.com <span class="token punctuation">(</span>180.97.34.96<span class="token punctuation">)</span>: 56 data bytes64 bytes from 180.97.34.96: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>45 time<span class="token operator">=</span>10.489 ms64 bytes from 180.97.34.96: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>45 time<span class="token operator">=</span>10.512 ms64 bytes from 180.97.34.96: seq<span class="token operator">=</span>2 ttl<span class="token operator">=</span>45 time<span class="token operator">=</span>10.424 ms64 bytes from 180.97.34.96: seq<span class="token operator">=</span>3 ttl<span class="token operator">=</span>45 time<span class="token operator">=</span>10.409 ms// 退出容器。使用 Ctrl+P+Q 退出容器但是容器不会关闭//在宿主机上查看网卡 eth0          $ <span class="token function">ifconfig</span> eth0eth0: flags<span class="token operator">=</span>4163<span class="token operator">&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class="token operator">></span>  mtu 1500        inet 192.168.0.3  netmask 255.255.255.0  broadcast 192.168.0.255        inet6 fe80::f816:3eff:fef4:68c0  prefixlen 64  scopeid 0x20<span class="token operator">&lt;</span>link<span class="token operator">></span>        ether fa:16:3e:f4:68:c0  txqueuelen 1000  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>        RX packets 612230  bytes 726004260 <span class="token punctuation">(</span>726.0 MB<span class="token punctuation">)</span>        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 203435  bytes 74354859 <span class="token punctuation">(</span>74.3 MB<span class="token punctuation">)</span>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><p>通过上面的例子我们可以很直观的看到 box2 容器使用的是 host 模式，ip 地址和宿主机一致，也能访问外网。</p><h3 id="none-无网络模式"><a href="#none-无网络模式" class="headerlink" title="none 无网络模式"></a>none 无网络模式</h3><p>不给容器提供任何网络配置，只有lo 网络接口。需要我们自己为Docker容器添加网卡、配置IP等。<br><img src="http://static.xiangdangnian.net.cn/16828bdd222d2bbb.png" alt="示意图"></p><pre class=" language-bash"><code class="language-bash">$ docker run --name box3 -it --network none --rm  busybox<span class="token comment" spellcheck="true"># ifconfig</span>lo        Link encap:Local Loopback          inet addr:127.0.0.1  Mask:255.0.0.0          UP LOOPBACK RUNNING  MTU:65536  Metric:1          RX packets:0 errors:0 dropped:0 overruns:0 frame:0          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000          RX bytes:0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>  TX bytes:0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>$ docker inspect box3<span class="token keyword">.</span><span class="token keyword">.</span><span class="token keyword">.</span><span class="token string">"Networks"</span>:<span class="token punctuation">{</span>    <span class="token string">"none"</span>:<span class="token punctuation">{</span>        <span class="token string">"IPAMConfig"</span>:null,        <span class="token string">"Links"</span>:null,        <span class="token string">"Aliases"</span>:null,        <span class="token string">"NetworkID"</span><span class="token keyword">:</span><span class="token string">"0cedda606a66614ba025ff7a992cb0d405fb567ff8da240310b96fa59f5fe99a"</span>,        <span class="token string">"EndpointID"</span><span class="token keyword">:</span><span class="token string">"e4fd85c2629d2524928f34fb428305bf4cf2d99195ff5ce7d428a9cff14902c0"</span>,        <span class="token string">"Gateway"</span><span class="token keyword">:</span><span class="token string">""</span>,        <span class="token string">"IPAddress"</span><span class="token keyword">:</span><span class="token string">""</span>,        <span class="token string">"IPPrefixLen"</span>:0,        <span class="token string">"IPv6Gateway"</span><span class="token keyword">:</span><span class="token string">""</span>,        <span class="token string">"GlobalIPv6Address"</span><span class="token keyword">:</span><span class="token string">""</span>,        <span class="token string">"GlobalIPv6PrefixLen"</span>:0,        <span class="token string">"MacAddress"</span><span class="token keyword">:</span><span class="token string">""</span>,        <span class="token string">"DriverOpts"</span>:null    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">.</span><span class="token keyword">.</span><span class="token keyword">.</span></code></pre><p>通过上面的例子我们可以很直观的看到 box3 容器使用的是 none 模式，没有网卡，只有 lo 网络接口。</p><h2 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h2><blockquote><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 -P 或 -p 参数来指定端口映射。</p></blockquote><ol><li>当使用 -P(大写) 标记时，Docker 会随机映射一个 49000~49900 的端口到内部容器开放的网络端口。</li><li>-p 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort。</li></ol><p>创建一个 nginx 容器，使用 -P 随机产生一个端口号</p><pre class=" language-bash"><code class="language-bash">$ docker run --name <span class="token function">test</span> -P -d  nginx769acc819c0dc26848b93c3e39040ba410385c8c7536a39c2a586896e120ae86$ docker container <span class="token function">ls</span>IMAGE       CONTAINER ID        STATUS         PORTS                  NAMESnginx       769acc819c0d        Up 4 minutes   0.0.0.0:32769-<span class="token operator">></span>80/tcp  <span class="token function">test</span></code></pre><p>本机访问结果<br><img src="http://static.xiangdangnian.net.cn/WX20200819-145535.png" alt="结果"></p><p><strong>其他端口映射配置可以查看链接</strong> <a href="https://yeasy.gitbook.io/docker_practice/network/port_mapping" target="_blank" rel="noopener">https://yeasy.gitbook.io/docker_practice/network/port_mapping</a></p><h2 id="使用自定义网络实现容器间的互连"><a href="#使用自定义网络实现容器间的互连" class="headerlink" title="使用自定义网络实现容器间的互连"></a>使用自定义网络实现容器间的互连</h2><blockquote><p>在实际应用中各容器间的通信不是通过 ip 地址，而是通过容器名称来连接的，那么这种事如何实现的呢？继续往下看吧。</p></blockquote><h3 id="创建一个自定义网络"><a href="#创建一个自定义网络" class="headerlink" title="创建一个自定义网络"></a>创建一个自定义网络</h3><pre class=" language-bash"><code class="language-bash">$ docker network create my-neta4806e9a4874118f1269992086dbe4137024b53603a4ac68cd6c0c548257b6b7 $ docker network <span class="token function">ls</span>NETWORK ID          NAME                DRIVER              SCOPEa4806e9a4874        my-net              bridge              local</code></pre><h3 id="创建-2-个容器将其加入自定义网络"><a href="#创建-2-个容器将其加入自定义网络" class="headerlink" title="创建 2 个容器将其加入自定义网络"></a>创建 2 个容器将其加入自定义网络</h3><pre class=" language-bash"><code class="language-bash">$ docker run --name box1 -it --rm  --network my-net busybox sh<span class="token comment" spellcheck="true"># //退出容器。使用 Ctrl+P+Q 退出容器但是容器不会关闭</span>$ docker run --name box2 -it --rm  --network my-net busybox sh<span class="token comment" spellcheck="true"># //退出容器。使用 Ctrl+P+Q 退出容器但是容器不会关闭</span>$ docker container <span class="token function">ls</span> --format <span class="token string">"table {{.Image}}\t{{.ID}}\t{{.Status}}\t{{.Names}}"</span> --allIMAGE                   CONTAINER ID        STATUS                      NAMESbusybox                 5e6a4861f857        Up About a minute           box2busybox                 1d7fa8762b4d        Up 2 minutes                box1</code></pre><h3 id="通过容器名称进行通信"><a href="#通过容器名称进行通信" class="headerlink" title="通过容器名称进行通信"></a>通过容器名称进行通信</h3><pre class=" language-bash"><code class="language-bash">// 进入 box2 容器进行 <span class="token function">ping</span> 测试连通$ docker <span class="token function">exec</span> -it box2 sh<span class="token comment" spellcheck="true"># ping box1</span>PING box1 <span class="token punctuation">(</span>172.19.0.2<span class="token punctuation">)</span>: 56 data bytes64 bytes from 172.19.0.2: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.049 ms64 bytes from 172.19.0.2: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.063 ms64 bytes from 172.19.0.2: seq<span class="token operator">=</span>2 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.057 ms64 bytes from 172.19.0.2: seq<span class="token operator">=</span>3 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.061 ms^C<span class="token comment" spellcheck="true">#</span></code></pre><p>好了，今天的网络相关内容就到这里啦，下集见。</p><p><img src="http://static.xiangdangnian.net.cn/4vB3ZRunrw8VzSW6cLpJyaibKfYTNCU0.png" alt="程序员的艺术人生"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 学习笔记（三）</title>
      <link href="/2020/08/17/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89%EF%BC%88%E5%AE%B9%E5%99%A8%EF%BC%89/"/>
      <url>/2020/08/17/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89%EF%BC%88%E5%AE%B9%E5%99%A8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="docker-容器"><a href="#docker-容器" class="headerlink" title="docker 容器"></a>docker 容器</h2><p>容器是通过 image 创建的进程。</p><blockquote><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p></blockquote><h3 id="新建并启动容器"><a href="#新建并启动容器" class="headerlink" title="新建并启动容器"></a>新建并启动容器</h3><p>下面的命令的含义：通过 Ubuntu:18.04 这个 image 创建一个容器并运行 /bin/echo ‘Hello world’，完成后停止该容器。</p><pre class=" language-bash"><code class="language-bash">$ docker run ubuntu:18.04 /bin/echo <span class="token string">'Hello world'</span>Hello world</code></pre><p>使用 docker run 命令，后台实际上执行的内容为：</p><ol><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层（后面会学）</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去（后面会学）</li><li>从地址池配置一个 ip 地址给容器（后面会学）</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ol><p>上面的示例执行完以后会终止，但是一般我们在使用一个提供服务的容器的时候，不想让它停止，那么可以使用 -d 参数，使容器保持在后台运行。但是需要注意——<strong>容器是否会长久运行，是和 docker run 指定的命令有关，和 -d 参数无关</strong></p><p>如下命令执行完后，容器依然会停止</p><pre class=" language-bash"><code class="language-bash">$ docker run -d ubuntu</code></pre><p><img src="http://static.xiangdangnian.net.cn/XF6zB8vbNWw9uPLGrSkiIt3YdZaHc0K7.png" alt="已停止"></p><p>而如下命令执行完后，容器则在后台保持运行</p><pre class=" language-bash"><code class="language-bash">$ docker run -d ubuntu /bin/sh -c <span class="token string">"while true; do echo hello world; sleep 1; done"</span></code></pre><p><img src="http://static.xiangdangnian.net.cn/VcoLwKIYlG65etAO1bCWNfHUES9FpBza.png" alt="运行中"></p><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><h4 id="attach-命令"><a href="#attach-命令" class="headerlink" title="attach 命令"></a>attach 命令</h4><pre class=" language-bash"><code class="language-bash">$ docker run -dit ubuntuffff9516c6151ef3b436df1bccc70ba9da2d0f57bbec5afe19353fe481e12702$ docker container <span class="token function">ls</span>CONTAINER ID        IMAGE                   COMMAND                  CREATED             STATUS              PORTS                                      NAMESffff9516c615        ubuntu                  <span class="token string">"/bin/bash"</span>              7 seconds ago       Up 6 seconds                                                   elegant_hypatia$ docker attach ffff9516c615root@ffff9516c615:/<span class="token comment" spellcheck="true">#</span></code></pre><p><strong>注意： 如果从这个 stdin 中 exit，会导致容器的停止。</strong></p><h4 id="exec-命令-推荐使用，一般配合-it-参数"><a href="#exec-命令-推荐使用，一般配合-it-参数" class="headerlink" title="exec 命令(推荐使用，一般配合 -it 参数)"></a>exec 命令(推荐使用，一般配合 -it 参数)</h4><pre class=" language-bash"><code class="language-bash">$ docker run -dit ubuntu15fc4d97c1b4ea25d76e568fb4e695d5b48d7f13ebbb6d718a80b86a4764a005// 只用 -i 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。$ docker <span class="token function">exec</span> -i 15fc4d97c1b4ea25 <span class="token function">bash</span><span class="token function">ls</span>binbootdevetc<span class="token punctuation">..</span>.//当 -i -t 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。$ docker <span class="token function">exec</span> -it 15fc4d97c1b4ea25 <span class="token function">bash</span>root@15fc4d97c1b4:/<span class="token comment" spellcheck="true">#</span></code></pre><p><strong>注意：如果从这个 stdin 中 exit，不会导致容器的停止。</strong></p><h4 id="容器常用命令"><a href="#容器常用命令" class="headerlink" title="容器常用命令"></a>容器常用命令</h4><ol><li>docker container ls –all        <strong>查看当前系统中的所有（运行中、已停止的）容器</strong> </li><li>docker container start XXX       <strong>把已经停止的 XXX 容器启动</strong></li><li>docker container stop XXX        <strong>把运行总的 XXX 容器停止</strong> </li><li>docker container restart XXX     <strong>重新启动运行中的 XXX 容器</strong></li><li>docker container prune           <strong>删除所有处于停止状态的容器</strong></li></ol><p><img src="http://static.xiangdangnian.net.cn/4vB3ZRunrw8VzSW6cLpJyaibKfYTNCU0.png" alt="程序员的艺术人生"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 学习笔记（二）</title>
      <link href="/2020/08/10/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%88image%EF%BC%89/"/>
      <url>/2020/08/10/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%EF%BC%88image%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="镜像-Image"><a href="#镜像-Image" class="headerlink" title="镜像 Image"></a>镜像 Image</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p></blockquote><p>上面是比较官方的解释，估计大部分也没看太懂，那么我就用我自己理解的方式说一下吧。</p><p>image 类似于我们安装系统的镜像文件，通过 image 文件我们可以生成容器文件。一般镜像文件是分层存储的，使用了Union Fs 的技术（具体是个啥我也不太懂🤦‍♂️），也就说一个镜像文件是很多块组成的，有点类似于现在前端的组件化开发，是一组文件组成的。镜像可以向面向对象的类一样可以进行继承，通过一些基础镜像来构建属于我们自己的镜像。</p><p>上面说了一大堆好像还不是很明白的样子，下面还是用例子来说明吧。go go go~~~</p><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><blockquote><p>通过 docker pull 命令从 Docker Hub 仓库获取镜像。</p></blockquote><pre class=" language-bash"><code class="language-bash">docker pull <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token punctuation">[</span>Docker Registry 地址<span class="token punctuation">[</span>:端口号<span class="token punctuation">]</span>/<span class="token punctuation">]</span>仓库名<span class="token punctuation">[</span>:标签<span class="token punctuation">]</span></code></pre><p>具体的选项可以通过 docker pull –help 查看</p><ol><li>地址的格式一般是 &lt;域名/IP&gt;[:端口号] 默认地址是 Docker Hub, 可以省略</li><li>仓库名：这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。</li><li>标签： 一般为版本号</li></ol><p><strong>这里穿插一个镜像急速的内容</strong><br>由于国内网络的问题我们需要对拉取镜像的地址镜像更改，使用国内的镜像地址来加快拉取速度。</p><h3 id="linux-系统（已测试）"><a href="#linux-系统（已测试）" class="headerlink" title="linux 系统（已测试）"></a>linux 系统（已测试）</h3><p>在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"registry-mirrors"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token string">"https://hub-mirror.c.163.com"</span><span class="token punctuation">,</span>    <span class="token string">"https://mirror.baidubce.com"</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>重启服务</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">sudo</span> systemctl daemon-reload$ <span class="token function">sudo</span> systemctl restart docker</code></pre><h3 id="Windows-10（未测试）"><a href="#Windows-10（未测试）" class="headerlink" title="Windows 10（未测试）"></a>Windows 10（未测试）</h3><p>在任务栏托盘 Docker 图标内右键菜单选择 Settings，打开配置窗口后在左侧导航菜单选择 Docker Engine，在右侧像下边一样编辑 json 文件，之后点击 Apply &amp; Restart 保存后 Docker 就会重启并应用配置的镜像地址了。</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"registry-mirrors"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token string">"https://hub-mirror.c.163.com"</span><span class="token punctuation">,</span>    <span class="token string">"https://mirror.baidubce.com"</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h3 id="macOS。（已测试）"><a href="#macOS。（已测试）" class="headerlink" title="macOS。（已测试）"></a>macOS。（已测试）</h3><p>在任务栏点击 Docker Desktop 应用图标 -&gt; Perferences，在左侧导航菜单选择 Docker Engine，在右侧像下边一样编辑 json 文件。修改完成之后，点击 Apply &amp; Restart 按钮，Docker 就会重启并应用配置的镜像地址了。</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"registry-mirrors"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token string">"https://hub-mirror.c.163.com"</span><span class="token punctuation">,</span>    <span class="token string">"https://mirror.baidubce.com"</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>执行 <strong>$ docker info</strong>如果从结果中看到如下内容，说明配置成功。</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">..</span>.Registry Mirrors: https://hub-mirror.c.163.com/<span class="token punctuation">..</span>.</code></pre><h2 id="继续镜像的拉取"><a href="#继续镜像的拉取" class="headerlink" title="继续镜像的拉取"></a>继续镜像的拉取</h2><p>使用 docker pull 拉取Ubuntu 镜像</p><pre class=" language-bash"><code class="language-bash">$ docker pull ubuntu:18.0418.04: Pulling from library/ubuntu7595c8c21622: Pull completed13af8ca898f: Pull complete70799171ddba: Pull completeb6c12202c5ef: Pull completeDigest: sha256:a61728f6128fb4a7a20efaa7597607ed6e69973ee9b9123e3b4fd28b7bba100bStatus: Downloaded newer image <span class="token keyword">for</span> ubuntu:18.04docker.io/library/ubuntu:18.04</code></pre><p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 ubuntu:18.04，因此将会获取官方镜像 library/ubuntu 仓库中标签为 18.04 的镜像。</p><p>从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。</p><h2 id="以镜像为基础启动容器"><a href="#以镜像为基础启动容器" class="headerlink" title="以镜像为基础启动容器"></a>以镜像为基础启动容器</h2><pre class=" language-bash"><code class="language-bash">$ docker run -i -t --rm ubuntu:18.04 <span class="token function">bash</span>root@94053f3fa153:/<span class="token comment" spellcheck="true"># cat /etc/os-release</span>NAME<span class="token operator">=</span><span class="token string">"Ubuntu"</span>VERSION<span class="token operator">=</span><span class="token string">"18.04.4 LTS (Bionic Beaver)"</span>ID<span class="token operator">=</span>ubuntuID_LIKE<span class="token operator">=</span>debianPRETTY_NAME<span class="token operator">=</span><span class="token string">"Ubuntu 18.04.4 LTS"</span>VERSION_ID<span class="token operator">=</span><span class="token string">"18.04"</span>HOME_URL<span class="token operator">=</span><span class="token string">"https://www.ubuntu.com/"</span>SUPPORT_URL<span class="token operator">=</span><span class="token string">"https://help.ubuntu.com/"</span>BUG_REPORT_URL<span class="token operator">=</span><span class="token string">"https://bugs.launchpad.net/ubuntu/"</span>PRIVACY_POLICY_URL<span class="token operator">=</span><span class="token string">"https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"</span>VERSION_CODENAME<span class="token operator">=</span>bionicUBUNTU_CODENAME<span class="token operator">=</span>bionicroot@94053f3fa153:/<span class="token comment" spellcheck="true">#</span></code></pre><p>docker run 就是运行容器的命令，具体格式在后面容器相关章节进行详细介绍。这里简单解释一下</p><ul><li>-i 交互式操作，让容器的标准输入保持打开。</li><li>-t 选项让 Docker 分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上。</li><li>–rm 容器退出后随之将其删除。（默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 –rm 可以避免浪费空间。）</li><li>ubuntu：18.04  使用 ubuntu:18.04 镜像为基础来启动容器。</li><li>bash 放在镜像名后的是 命令，这里我们希望有个交互式 Shell，因此用的是 bash。</li></ul><p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 cat /etc/os-release，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 Ubuntu 18.04.1 LTS 系统。</p><p>最后我们通过 exit 退出了这个容器。</p><h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2><p>使用 docker image ls 列出已经下载了的镜像文件</p><pre class=" language-bash"><code class="language-bash">$ docker image <span class="token function">ls</span>REPOSITORY           TAG                 IMAGE ID            CREATED             SIZEredis                latest              5f515359c7f8        5 days ago          183 MBnginx                latest              05a60462f8ba        5 days ago          181 MBmongo                3.2                 fe9198c04d62        5 days ago          342 MB<span class="token operator">&lt;</span>none<span class="token operator">></span>               <span class="token operator">&lt;</span>none<span class="token operator">></span>              00285df0df87        5 days ago          342 MBubuntu               18.04               f753707788c5        4 weeks ago         127 MBubuntu               latest              f753707788c5        4 weeks ago         127 MB</code></pre><p>列表包含了 仓库名、标签、镜像 ID、创建时间 以及 所占用的空间。</p><ul><li><p>镜像 ID 则是镜像的唯一标识，因为一个镜像可以对应多个标签。因此，在上面的例子中，我们可以看到 ubuntu:18.04 和 ubuntu:latest 拥有相同的 ID，因为它们对应的是同一个镜像。</p></li><li><p>镜像的体积跟 Docker Hub 上的不一致是因为 Docker Hub 中显示的体积是压缩后的体积。而 docker image ls 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和。</p></li><li><p>另外一个需要注意的问题是，docker image ls 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p></li></ul><p>使用以下命令查看镜像、容器、数据卷所占用的空间。</p><pre class=" language-bash"><code class="language-bash">$ docker system <span class="token function">df</span>TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLEImages              24                  0                   1.992GB             1.992GB <span class="token punctuation">(</span>100%<span class="token punctuation">)</span>Containers          1                   0                   62.82MB             62.82MB <span class="token punctuation">(</span>100%<span class="token punctuation">)</span>Local Volumes       9                   0                   652.2MB             652.2MB <span class="token punctuation">(</span>100%<span class="token punctuation">)</span>Build Cache                                                 0B                  0B</code></pre><h3 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h3><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>none<span class="token operator">></span>               <span class="token operator">&lt;</span>none<span class="token operator">></span>              00285df0df87        5 days ago          342 MB</code></pre><p>既没有仓库名，也没有标签,显示为 none 的就是虚悬镜像</p><p>个镜像原本是有镜像名和标签的，原来为 mongo:3.2，随着官方镜像维护，发布了新版本后，重新 docker pull mongo:3.2 时，mongo:3.2 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <none>。除了 docker pull 可能导致这种情况，docker build 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <none> 的镜像。这类无标签镜像也被称为 虚悬镜像(dangling image) ，可以用下面的命令专门显示这类镜像：</none></none></p><pre class=" language-bash"><code class="language-bash">$ docker image <span class="token function">ls</span> -f dangling<span class="token operator">=</span>trueREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<span class="token operator">&lt;</span>none<span class="token operator">></span>              <span class="token operator">&lt;</span>none<span class="token operator">></span>              00285df0df87        5 days ago          342 MB</code></pre><p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。</p><pre class=" language-bash"><code class="language-bash">$ docker image prune</code></pre><h3 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h3><p>为了加速镜像构建、重复利用资源，Docker 会利用 中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 docker image ls 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。</p><pre class=" language-bash"><code class="language-bash">$ docker image <span class="token function">ls</span> -a</code></pre><p><strong>这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错</strong></p><h3 id="常用列出镜像的命令"><a href="#常用列出镜像的命令" class="headerlink" title="常用列出镜像的命令"></a>常用列出镜像的命令</h3><h4 id="根据仓库名列出镜像"><a href="#根据仓库名列出镜像" class="headerlink" title="根据仓库名列出镜像"></a>根据仓库名列出镜像</h4><pre class=" language-bash"><code class="language-bash">$ docker image <span class="token function">ls</span> ubuntuREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              18.04               f753707788c5        4 weeks ago         127 MBubuntu              latest              f753707788c5        4 weeks ago         127 MB</code></pre><h4 id="列出特定的某个镜像"><a href="#列出特定的某个镜像" class="headerlink" title="列出特定的某个镜像"></a>列出特定的某个镜像</h4><pre class=" language-bash"><code class="language-bash">$ docker image <span class="token function">ls</span> ubuntu:18.04REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              18.04               f753707788c5        4 weeks ago         127 MB</code></pre><h4 id="只查看镜像ID"><a href="#只查看镜像ID" class="headerlink" title="只查看镜像ID"></a>只查看镜像ID</h4><pre class=" language-bash"><code class="language-bash">$ docker image <span class="token function">ls</span> -q5f515359c7f805a60462f8bafe9198c04d6200285df0df87f753707788c5f753707788c51e0c3dd64ccd</code></pre><h4 id="以表格等距显示，并且有标题行"><a href="#以表格等距显示，并且有标题行" class="headerlink" title="以表格等距显示，并且有标题行"></a>以表格等距显示，并且有标题行</h4><pre class=" language-bash"><code class="language-bash">$ docker image <span class="token function">ls</span> --format <span class="token string">"table {{.ID}}\t{{.Repository}}\t{{.Tag}}"</span>IMAGE ID            REPOSITORY          TAG5f515359c7f8        redis               latest05a60462f8ba        nginx               latestfe9198c04d62        mongo               3.200285df0df87        <span class="token operator">&lt;</span>none<span class="token operator">></span>              <span class="token operator">&lt;</span>none<span class="token operator">></span>f753707788c5        ubuntu              18.04f753707788c5        ubuntu              latest</code></pre><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><blockquote><p>格式</p><pre class=" language-bash"><code class="language-bash">$ docker image <span class="token function">rm</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token operator">&lt;</span>镜像1<span class="token operator">></span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>镜像2<span class="token operator">></span> <span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre><p><strong>其中，&lt;镜像&gt; 可以是 镜像短 ID、镜像长 ID、镜像名 或者 镜像摘要。</strong></p></blockquote><h3 id="Untagged-和-Deleted"><a href="#Untagged-和-Deleted" class="headerlink" title="Untagged 和 Deleted"></a>Untagged 和 Deleted</h3><p>因为一个镜像可以有多个标签，当我们执行 <code>docker image rm</code> 命令时，如果如果还有其他标签指向这个镜像，那么就不会产生 Delete 操作。</p><h3 id="用-docker-image-ls-命令来配合删除"><a href="#用-docker-image-ls-命令来配合删除" class="headerlink" title="用 docker image ls 命令来配合删除"></a>用 docker image ls 命令来配合删除</h3><p>以下命令可以删除所有仓库名为 redis 的镜像</p><pre class=" language-bash"><code class="language-bash">$ docker image <span class="token function">rm</span> <span class="token variable"><span class="token variable">$(</span>docker image <span class="token function">ls</span> -q redis<span class="token variable">)</span></span></code></pre><p><img src="http://static.xiangdangnian.net.cn/4vB3ZRunrw8VzSW6cLpJyaibKfYTNCU0.png" alt="程序员的艺术人生"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 学习笔记（一）</title>
      <link href="/2020/08/09/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%88%E7%AE%80%E4%BB%8B%EF%BC%89/"/>
      <url>/2020/08/09/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%88%E7%AE%80%E4%BB%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="docker-介绍"><a href="#docker-介绍" class="headerlink" title="docker 介绍"></a>docker 介绍</h2><p>docker 这个东西应该做开发的应该都有听说过，但是不知道大家有没有详细的了解过。反正我是属于听说过，大概知道是个什么东西，能特别简单的使用。但是一直没有深入的学习过，今天在这里我想把学习 docker 的过程记录下来，方便日后查找。</p><p>那么下面开始啦。~~~</p><h2 id="为啥要使用-docker"><a href="#为啥要使用-docker" class="headerlink" title="为啥要使用 docker"></a>为啥要使用 docker</h2><blockquote><p>在我电脑上运行的是正常的啊？怎么到了别人的电脑上就不能正常运行了呢？</p></blockquote><p>如果你也碰到上面的问题了，那么请你也开始 docker 的学习吧。这个时候有人会说为啥不用虚拟机呢，因为虚拟机是完全模拟一台正常运行的。就算你只是需要运行一个 php 的环境，那么系统默认的一些其他进程也是会启动的，这样就会降低我们电脑的利用率。还有一点就是虚拟机一般是不能再生产环境中使用的。但是 docker 没有问题。总而言之一句话，虚拟机不好，我们要用 docker 。</p><h2 id="docker-的用途"><a href="#docker-的用途" class="headerlink" title="docker 的用途"></a>docker 的用途</h2><ol><li>提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</li><li>提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</li><li>组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</li></ol><h2 id="docker-的安装"><a href="#docker-的安装" class="headerlink" title="docker 的安装"></a>docker 的安装</h2><p>docker 分为社区版（CE）、企业版本（EE）<br>win 和 mac 安装很简单，就是正常的安装软件的方法，而用能用 linux 系统的，相信你也有办法找到安装的方法的。</p><p>安装完成之后使用如下命令验证是否安装成功</p><pre class=" language-bash"><code class="language-bash">$ docker version<span class="token comment" spellcheck="true"># 或者</span>$ docker info</code></pre><p><strong>Docker 需要用户具有 sudo 权限，为了避免每次命令都输入sudo，可以把用户加入 Docker 用户组</strong></p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">usermod</span> -aG docker <span class="token variable">$USER</span></code></pre><p>使用如下命令启动 docker</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># service 命令的用法</span>$ <span class="token function">sudo</span> <span class="token function">service</span> docker start<span class="token comment" spellcheck="true"># systemctl 命令的用法</span>$ <span class="token function">sudo</span> systemctl start docker</code></pre><h2 id="第一个实例-hello-world"><a href="#第一个实例-hello-world" class="headerlink" title="第一个实例 hello world"></a>第一个实例 hello world</h2><pre class=" language-bash"><code class="language-bash">$ docker container run hello-world</code></pre><p>如果运行成功，你会在屏幕上读到下面的输出。</p><pre class=" language-bash"><code class="language-bash">$ docker container run hello-worldHello from Docker<span class="token operator">!</span>This message shows that your installation appears to be working correctly.<span class="token punctuation">..</span>. <span class="token punctuation">..</span>.</code></pre><p>上面命令的过程就是：</p><ol><li>从 docker 的官方仓库拉取 hello world image 文件到本地</li><li>使用 image 文件 生成 容器文件</li><li>运行 hello world 容器 —&gt; 输出相关内容  —&gt; 容器自动终止（有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。）</li></ol><p>通过上面的实例大概知道了 docker 的是怎么回事了。主要就是需要明白两个文件，image文件和容器文件。接下来我们制作一个 image 文件，并通过该文件生成容器并运行。</p><h2 id="制作自己的-docker-容器"><a href="#制作自己的-docker-容器" class="headerlink" title="制作自己的 docker 容器"></a>制作自己的 docker 容器</h2><ol><li>新建一个目录<pre class=" language-bash"><code class="language-bash">$ <span class="token function">mkdir</span> hello <span class="token operator">&amp;&amp;</span> <span class="token function">cd</span> hello </code></pre></li><li>在目录中新建 .dockerignore 文件（该文件类似于 git 项目中的 .gitignore 文件）</li><li><p>在目录中新建 Dockerfile 文件,内容如下所示<br><img src="http://static.xiangdangnian.net.cn/blog/2020/08/10/20-29-32-9faae2396ce4759958aee55bfcabc924-f01fa1.png" alt=""></p></li><li><p>运行命令，进行 image 的构建</p><pre class=" language-bash"><code class="language-bash">$ docker build -t nginx:v1 <span class="token keyword">.</span></code></pre><p>看到如下内容则表示 image 构建成功。<br><img src="http://static.xiangdangnian.net.cn/blog/2020/08/10/20-30-47-a92e94e81727959af077be139e676ed6-044d5a.png" alt=""></p></li><li><p>通过 image 文件生成容器文件</p><pre class=" language-bash"><code class="language-bash">$ docker run --name webserver -p 9527:80 nginx:v1</code></pre></li><li>通过浏览器访问 localhost:9527,如果可以看到如下内容则成功<br><img src="http://static.xiangdangnian.net.cn/blog/2020/08/10/20-35-50-6f66e88683370b594f2ec01744c008cf-0c3367.png" alt=""></li></ol><p>一个简单的容器就完成了。通过这个例子我们可以大概了解 docker 的配置，运行， 后面会深入 docker 相关的概念进行学习，并定下第一个计划 ———— 配置一个属于自己的 LNMP docker 测试环境。</p><p><img src="http://static.xiangdangnian.net.cn/4vB3ZRunrw8VzSW6cLpJyaibKfYTNCU0.png" alt="程序员的艺术人生"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《被讨厌的勇气》读后感</title>
      <link href="/2020/06/09/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
      <url>/2020/06/09/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>自从从外地回到家里，感觉焦虑的情绪比之前更深了。就这本读后感来记录一下近期的情况吧。</p></blockquote><p>发现这本书也是一个偶然的机会吧。因为已经30岁了还没有结婚，而且也从来没有谈过恋爱，那么从回到家开始家里人就一直在张罗相亲的事情。最近认识了一个女生，也见过几面，聊的也算还行，就是比较客气的问候以及随便的闲聊。大概持续了得有2个月左右吧。近期感觉在微信上聊得非常不错，本想着约出来表白一下。也不知道那天是什么原因，吃饭的时候来到一家刚开也的烧烤店，因为刚开业在做活动，外面不停的有人在唱歌，声音很大听不清说话的那种。然后这顿饭就吃的不是很愉快，期间也没怎么聊。饭后大家就坐车回去了。到家后我就感觉不知道为什么都认识也算挺久的了，怎么在一起的时候还是像普通人一样，非常的客气、生疏，完全不像微信里聊天的那种感觉，更别说恋爱的感觉了。</p><p>后来我就这反思，究竟什么原因造成了现在的这种局面。我承认自己性格内向，不善于表达。但是平常在一些朋友同、事面前表现的也还好。然后就在网络上查这是怎么回事。有人提到了「社交恐惧症」。</p><p>之前也知道这么个词语，但真的没往自己身上想，就是觉得自己有点内向，不爱说话罢了。然而仔细看了下社恐的症状——可能我真的有些轻微的社恐了。</p><p>下面讲下重点——《被讨厌的勇气》这本书。</p><ul><li><p>本书主要通过哲人和以为青年之间的对话的方式引出了阿德勒心理学的相关内容。</p></li><li><p>首先颠覆了弗洛伊德的原因论。</p></li><li><p>接下来是人生的烦恼和自卑都是来自有人际关系。</p></li><li><p>第三教会我们如何把自己和别人的人生课题分开。</p></li><li><p>第四就是标题所讲的内容，要有被讨厌的勇气。</p></li><li><p>最后告知我们要活在当下，即不要纠结过去的原因，也不要畅享未来的美好，过好人生的每一个刹那。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 观后感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 websocket 简单模拟直播效果（初级版）</title>
      <link href="/2020/02/28/%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E7%9B%B4%E6%92%AD/"/>
      <url>/2020/02/28/%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E7%9B%B4%E6%92%AD/</url>
      
        <content type="html"><![CDATA[<blockquote><p>基于 swoole 通过 websocket 简单实现直播效果。（主要学习一下 websocket 相关知识点）</p></blockquote><p><img src="http://static.xiangdangnian.net.cn/blog/wesocket.jpg" alt="流程图"></p><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><ol><li>在直播页使用视频的方式模拟摄像头</li><li>利用 canvas 绘制视频内容</li><li>通过 canvas 将绘制的图片转化为 base64 格式</li><li>使用 settimeout 定时执行，通过 websocket 将 base64 格式图片传递到服务端</li><li>服务端接收到数据之后，通过广播的形式进行推送</li><li>客户端页面通过 websocket 接收服务端发来的数据在页面上循环展示</li><li>完成</li></ol><h2 id="直播页"><a href="#直播页" class="headerlink" title="直播页"></a>直播页</h2><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Title<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>video</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xszr.mp4<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>video<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>400<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>400<span class="token punctuation">"</span></span> <span class="token attr-name">autoplay</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">controls</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>video</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>canvas</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>canvas<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1280<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>720<span class="token punctuation">"</span></span> <span class="token attr-name">hidden</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>canvas</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    ws <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSocket</span><span class="token punctuation">(</span><span class="token string">"ws://test.test/ws"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> video <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'video'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> canvas <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'canvas'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> context <span class="token operator">=</span> canvas<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token string">'2d'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        context<span class="token punctuation">.</span><span class="token function">drawImage</span><span class="token punctuation">(</span>video<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ws<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>canvas<span class="token punctuation">.</span><span class="token function">toDataURL</span><span class="token punctuation">(</span><span class="token string">'image/jpeg'</span><span class="token punctuation">,</span><span class="token number">0.4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span>draw<span class="token punctuation">,</span><span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ws<span class="token punctuation">.</span>onopen <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><h2 id="websocket-服务端"><a href="#websocket-服务端" class="headerlink" title="websocket 服务端"></a>websocket 服务端</h2><pre class=" language-php"><code class="language-php"><span class="token variable">$ws</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">swoole_websocket_server</span><span class="token punctuation">(</span><span class="token string">'0.0.0.0'</span><span class="token punctuation">,</span><span class="token number">9527</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//监听WebSocket消息事件</span><span class="token variable">$ws</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token variable">$ws</span><span class="token punctuation">,</span> <span class="token variable">$frame</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$ws</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">connections</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$ws</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">connections</span> <span class="token keyword">as</span> <span class="token variable">$fd</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token variable">$ws</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">push</span><span class="token punctuation">(</span><span class="token variable">$fd</span><span class="token punctuation">,</span><span class="token variable">$frame</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">data</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//监听WebSocket连接关闭事件</span><span class="token variable">$ws</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'close'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token variable">$ws</span><span class="token punctuation">,</span> <span class="token variable">$fd</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">"client-{$fd} is closed\n"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$ws</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Title<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>img<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1280<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>720<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    ws <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSocket</span><span class="token punctuation">(</span><span class="token string">"ws://test.test/ws"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    img <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ws<span class="token punctuation">.</span>onmessage <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        img<span class="token punctuation">.</span>src <span class="token operator">=</span> event<span class="token punctuation">.</span>data    <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="http://static.xiangdangnian.net.cn/blog/fdssddsfsdfsdf.gif" alt="最终效果"></p><h3 id="nginx-配置"><a href="#nginx-配置" class="headerlink" title="nginx 配置"></a>nginx 配置</h3><pre class=" language-nginx"><code class="language-nginx"><span class="token keyword">upstream</span> test <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true"># 因为使用的laradock 所以是workspace，其他环境根据具体情况填写对应 ip 地址</span>    <span class="token keyword">server</span> workspace<span class="token punctuation">:</span><span class="token number">9527</span> weight<span class="token operator">=</span><span class="token number">5</span> max_fails<span class="token operator">=</span><span class="token number">3</span> fail_timeout<span class="token operator">=</span>30s<span class="token punctuation">;</span>    <span class="token keyword">keepalive</span> <span class="token number">16</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">server</span> <span class="token punctuation">{</span>    <span class="token keyword">listen</span> <span class="token number">80</span><span class="token punctuation">;</span>    <span class="token keyword">server_name</span> test<span class="token punctuation">.</span>test<span class="token punctuation">;</span>    <span class="token keyword">root</span> <span class="token operator">/</span>var<span class="token operator">/</span>www<span class="token operator">/</span>test<span class="token punctuation">;</span>    <span class="token keyword">index</span> <span class="token keyword">index</span><span class="token punctuation">.</span>php <span class="token keyword">index</span><span class="token punctuation">.</span>html <span class="token keyword">index</span><span class="token punctuation">.</span>htm<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true"># 因为 laradock 开启其他端口比较麻烦，所以使用该方法进行转发</span>    <span class="token keyword">location</span> <span class="token operator">=</span><span class="token operator">/</span>ws <span class="token punctuation">{</span>        <span class="token keyword">proxy_http_version</span> <span class="token number">1.1</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Real<span class="token operator">-</span>IP <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Real<span class="token operator">-</span>PORT <span class="token variable">$remote_port</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Forwarded<span class="token operator">-</span>For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> Host <span class="token variable">$http_host</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> Scheme <span class="token variable">$scheme</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> <span class="token keyword">Server</span><span class="token operator">-</span><span class="token keyword">Protocol</span> <span class="token variable">$server_protocol</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> <span class="token keyword">Server</span><span class="token operator">-</span>Name <span class="token variable">$server_name</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> <span class="token keyword">Server</span><span class="token operator">-</span>Addr <span class="token variable">$server_addr</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> <span class="token keyword">Server</span><span class="token operator">-</span>Port <span class="token variable">$server_port</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> Upgrade <span class="token variable">$http_upgrade</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> Connection <span class="token variable">$connection_upgrade</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>test<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> swoole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《但是还有书籍》观后感</title>
      <link href="/2020/02/01/%E4%BD%86%E6%98%AF%E8%BF%98%E6%9C%89%E4%B9%A6%E7%B1%8D%E8%A7%82%E5%90%8E%E6%84%9F/"/>
      <url>/2020/02/01/%E4%BD%86%E6%98%AF%E8%BF%98%E6%9C%89%E4%B9%A6%E7%B1%8D%E8%A7%82%E5%90%8E%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天在 B 站上看了一部人文类的纪录片《但是还有书籍》，看过后激发了我内心深处那一丝文艺青年的骚动。(😓)所以就有了下面的内容。</p></blockquote><h2 id="第一集「书海编舟记」"><a href="#第一集「书海编舟记」" class="headerlink" title="第一集「书海编舟记」"></a>第一集「书海编舟记」</h2><p><em>一群隐身于书背后的人，他们穿梭于字里行间，钻研着逗号、句号的学问，他们以敏锐的眼光探寻文学的矿脉，他们以细微琐碎的工作搭建起跨越语言的桥梁，摆渡于作者和读者之间，编织着航行于浩瀚文海中的思想之舟。</em></p><p>上面的文字是这一集的开篇语，读过上面的文字相信大家应该已经知道这一集讲述的是什么内容了吧。没错！就是书籍编辑者和书籍翻译者。</p><p>这一集主要讲述了3个人的故事。</p><p>第一位叫做朱岳，是后浪文学的一名主编也是一名作者。主要是将一些台湾、新加坡之类的华语类文学引入国内，让国内的我们也可以读到这些地方的作品。第二位叫做俞国林，是中华书局学术著作出版中心的主任。通过他的努力，历时十三年的时间终于在2018年1月出版了《郑天挺西南联大日记》一书，该书的出版对研究西南联大校史、近代学术史都是极为重要的史料。第三位叫做范晔是北京大学外国语学院西葡语系的系主任。他是《百年孤独》中文版的译者，为了能够更好的表达作者的意思且可以在10个月内完成翻译，他翻遍了马尔克斯其他的作品，一遍一遍的查字典、翻阅资料，终于在2011年6月花了11月翻译的作品出版了。</p><p>虽然三位平凡的文字工作者在平凡的工作 岗位上做着平凡的事情，但是因为他们的努力我们才能看到其他地区华语文学作品，让我们得以了解他们的生活、文化。也是他们的努力让我可以了解历史，获悉曾经发生的故事。还是他们的努力让我们可以看到其他外国文学。</p><h2 id="第二集「二手书的奇幻漂流」"><a href="#第二集「二手书的奇幻漂流」" class="headerlink" title="第二集「二手书的奇幻漂流」"></a>第二集「二手书的奇幻漂流」</h2><p><em>书籍从一诞生便开始了他的奇幻之旅。从书店到读书人手中，从一个书房到另一个书房，他们在漫长的岁月中辗转流徙，不断增添新的痕迹与记忆，与人共同书写着一段段故事与传奇</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 观后感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>laravel通过关联模型实现无限极分类</title>
      <link href="/2020/01/15/laravel%E9%80%9A%E8%BF%87%E5%85%B3%E8%81%94%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%99%90%E6%9E%81%E5%88%86%E7%B1%BB/"/>
      <url>/2020/01/15/laravel%E9%80%9A%E8%BF%87%E5%85%B3%E8%81%94%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%99%90%E6%9E%81%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Laravel-通过关联模型实现无限极分类"><a href="#Laravel-通过关联模型实现无限极分类" class="headerlink" title="Laravel 通过关联模型实现无限极分类"></a>Laravel 通过关联模型实现无限极分类</h1><blockquote><p>这个内容是在 Laravel-China 论坛上看到的，怕以后不好找，这里记录一下。原文地址为：<a href="https://learnku.com/articles/14068/simple-practice-of-laravel-infinite-class-classification" target="_blank" rel="noopener">https://learnku.com/articles/14068/simple-practice-of-laravel-infinite-class-classification</a></p></blockquote><h2 id="数据库结构"><a href="#数据库结构" class="headerlink" title="数据库结构"></a>数据库结构</h2><p>这里使用省市区结构</p><pre class=" language-php"><code class="language-php"><span class="token keyword">class</span> <span class="token class-name">CreateAreasTable</span> <span class="token keyword">extends</span> <span class="token class-name">Migration</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span>    <span class="token punctuation">.</span>    <span class="token punctuation">.</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Schema<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">'areas'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>Blueprint <span class="token variable">$table</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token variable">$table</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">unsignedInteger</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token variable">$table</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">comment</span><span class="token punctuation">(</span><span class="token string">'城市名称'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token variable">$table</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">unsignedInteger</span><span class="token punctuation">(</span><span class="token string">'pid'</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token keyword">default</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">comment</span><span class="token punctuation">(</span><span class="token string">'父级id'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span>    <span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><h2 id="Area-模型增加关联方法"><a href="#Area-模型增加关联方法" class="headerlink" title="Area 模型增加关联方法"></a>Area 模型增加关联方法</h2><pre class=" language-php"><code class="language-php"><span class="token keyword">class</span> <span class="token class-name">Area</span> <span class="token keyword">extends</span> <span class="token class-name">Model</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span>    <span class="token punctuation">.</span>    <span class="token punctuation">.</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">childArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">hasMany</span><span class="token punctuation">(</span>Area<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token string">'pid'</span><span class="token punctuation">,</span><span class="token string">'id'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">allChildArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">childArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">with</span><span class="token punctuation">(</span><span class="token string">'allChildArea'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span>    <span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><blockquote><p>通过如下代码可以得到所有地区的无限极分类结构。更改条件可以查看某个地区及其子地区的无限极分类结构</p></blockquote><pre class=" language-php"><code class="language-php"><span class="token variable">$res</span> <span class="token operator">=</span> Area<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">with</span><span class="token punctuation">(</span><span class="token string">'allChildArea'</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">where</span><span class="token punctuation">(</span><span class="token string">'pid'</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token variable">$res</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ipad-mini2 降级记录</title>
      <link href="/2020/01/13/%E9%99%8D%E7%BA%A7%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/01/13/%E9%99%8D%E7%BA%A7%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>主要记录下 Ipad mini2 ios12.3.1 降级为 ios10.3.3 的过程</p></blockquote><p>最近因为想着手好好读读书，翻出了压箱底的ipad。（因为曾经手欠，把系统升级成了 ios12.3.1 导致巨卡无比，只能压箱底了）。然后用<a href="https://www.dogedoge.com" target="_blank" rel="noopener">狗子</a>搜索了一下。竟然让我找到了<a href="https://www.v2ex.com/t/608874" target="_blank" rel="noopener">V2ex上的一个讨论</a>，仔细一看感觉挺靠谱，接下来就搞了。</p><blockquote><p>下面基本上都是废话，会玩直接看 v2 的帖子应该就可以搞定了，上面贴出了 GitHub 上项目的地址，基本上就是一键操作。</p></blockquote><p>根据的帖子给出的 github 链接查看项目，发现该项目已经不再维护了，但是好在项目又给出了一个新的地址。赶紧进入新的项目看一下。</p><p>项目提示中指明了可以降级到10.3.3 的设备为 iPhone 5s, iPad Air, iPad Mini 2 (Not iPad4,6)。</p><p>其他还有可以降级到8.4.1 的设备为iPhone 5, iPhone 4s, iPad 2, iPad 3, iPad 4, iPad Mini 1, iPod 5。</p><p>以及可以降级到 6.1.3 的设备 iPhone 4s, iPad 2 (Not iPad2,4)。</p><p>需要的小伙伴们自取。我只实验了ipad mini2 可以成功降级，其他的大家烧香祷告吧。^_^</p><p>首先将项目克隆到本地，接着进入项目目录，并执行 <code>pip3 install -r requirements.txt</code> 安装项目需要的扩展。（确保当前系统中已经安装了python3，至少为3.5）</p><p>下载 ios 10.3.3 的镜像文件。可以使用<a href="https://www.i4.cn/firmware_iPad_iPad%20mini%202__A1489_10.3.3__.html" target="_blank" rel="noopener">爱思助手</a>提供的镜像，下载速度那是杠杠的。</p><p>接下来就是将 ipad 进入 DFU 模式。（这里吐槽一下，因为我不怎么用 ios 的设备，不知道 DFU 到底是个什么鬼，搜索了半天，很多人给出的方法根本不是进入 DFU的方法，最后还是在刚才那个 V2 讨论里面看到有朋友的回复，才明白了该怎么进入 DFU 模式。）</p><p><strong> 这里说一下进入 DFU 模式的方法， </strong></p><ol><li>将 ipad 链接电脑</li><li>经 ipad 关机</li><li>长按电源键和 home 键 10 秒以上然后只松开电源键并保持 home 一直按着，当电脑上提示已经进入恢复模式则可以松开 home 键了。这个时候 ipad 屏幕是黑的。</li></ol><p><img src="http://static.xiangdangnian.net.cn/blog/sssdfsdfsdjkl23jk23j4lk23j423lklkwfjs.png" alt="DFU 模式"></p><p>然后在项目里面执行 <code>./vieux -i .....ipsw</code>。 后面的省略号表示刚才下载的 ios10.3.3 的镜像文件。</p><p>最后尽是等待了。</p><p>我的一次成功，所以也没有什么好分享的啦，就先记录到这里啦。</p><p>对了，最后说一下这个项目应该是只能在 macOS 下操作，windows 是不支持的。在一个就是最好可以使用梯子，要不然项目下载的一下东西可能会很慢，或者完全下不来。</p><p>最后感谢 V2ex，啦啦啦啦又可以愉快地使用 Ipad 啦。</p>]]></content>
      
      
      <categories>
          
          <category> ios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis学习笔记-----基本数据类型之有序集合</title>
      <link href="/2019/12/26/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/"/>
      <url>/2019/12/26/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="有序集合（sort-sets）"><a href="#有序集合（sort-sets）" class="headerlink" title="有序集合（sort sets）"></a>有序集合（sort sets）</h1><ul><li>与集合类型，区别是集合不能字段排序，而有序集合可以设置额外的优先级(score)参数来为成员排序。</li><li>使用场景：当你需要一个有序并且不重复的集合列表的时候，使用有序集合。 </li></ul><h2 id="ZADD"><a href="#ZADD" class="headerlink" title="ZADD"></a>ZADD</h2><ul><li>将一个或多个元素以及其 score 值加入到 key 中。</li><li>如果某个元素已经在有序集合中，则更新该元素的 score 值。</li><li>score 值可以是整数或双精度浮点数。</li></ul><pre><code>127.0.0.1:6379&gt; zadd language 100 php 90 java 80 js(integer) 3</code></pre><h2 id="ZCARD"><a href="#ZCARD" class="headerlink" title="ZCARD"></a>ZCARD</h2><ul><li>返回有序集合 key 的值得个数</li><li>如果 key 不存在，则返回 0</li></ul><pre><code>127.0.0.1:6379&gt; zcard language(integer) 3127.0.0.1:6379&gt; zcard xxxxx(integer) 0</code></pre><h2 id="ZCOUNT"><a href="#ZCOUNT" class="headerlink" title="ZCOUNT"></a>ZCOUNT</h2><ul><li>返回有序集合 key 中，score 的值在 min 和 max 直接的成员个数。（包含 min 和 max）</li><li>如果在统计时，不需要包含某个 score时 ，则添加一个 ( 即可。<br><code>`</code><br>127.0.0.1:6379&gt; zcount language 80 100<br>(integer) 3</li></ul><p>127.0.0.1:6379&gt; zcount language 80 (100<br>(integer) 2</p><pre><code>## ZSCORE- 返回有序集合 key 中，成员的score值</code></pre><p>127.0.0.1:6379&gt; zscore language php<br>“100”</p><pre><code>## ZRANGE- 格式：zrange key start stop [withscores]- 根据索引返回元素- withscores 参数可以连同元素的 score 一起返回。- start 为 0，stop 为 -1，即可返回整个有序集合。</code></pre><p>127.0.0.1:6379&gt; zrange language 0 2<br>1) “js”<br>2) “java”<br>3) “php”</p><p>127.0.0.1:6379&gt; zrange language 0 2 withscores<br>1) “js”<br>2) “80”<br>3) “java”<br>4) “90”<br>5) “php”<br>6) “100”</p><pre><code>## ZREVRANGE- 同 zrange 基本一致，区别是 zrevrange 是反者来的。</code></pre><p>127.0.0.1:6379&gt; zrevrange language 0 2<br>1) “php”<br>2) “java”<br>3) “js”</p><p>127.0.0.1:6379&gt; zrevrange language 0 2 withscores<br>1) “php”<br>2) “100”<br>3) “java”<br>4) “90”<br>5) “js”<br>6) “80”</p><pre><code>## ZRANGEBYSCORE- 返回有序集合 key 中，score 的值在 min 和 max 直接的成员。（包含 min 和 max）- 如果不需要包含某个 score时 ，则添加一个 ( 即可。</code></pre><p>127.0.0.1:6379&gt; zrangebyscore language 80 100<br>1) “js”<br>2) “java”<br>3) “php”</p><p>127.0.0.1:6379&gt; zrangebyscore language 80 100 withscores<br>1) “js”<br>2) “80”<br>3) “java”<br>4) “90”<br>5) “php”<br>6) “100”</p><p>127.0.0.1:6379&gt; zrangebyscore language 80 (100<br>1) “js”<br>2) “java”</p><pre><code>## ZRANK- 返回有序集合 key 中成员 member 在集合中的排名序号。（排名按 score 值从小到大的顺序）。- 排名序号从 0 开始。(即 序号为 0 的 score 值最小)</code></pre><p>127.0.0.1:6379&gt; zrank language php<br>(integer) 2</p><p>127.0.0.1:6379&gt; zrank language js<br>(integer) 0</p><p>127.0.0.1:6379&gt; zrank language java<br>(integer) 1</p><pre><code>## ZREVRANK - 同上面的 zrank。区别是 zrevrank 的排序是从大到小</code></pre><p>127.0.0.1:6379&gt; zrevrank language php<br>(integer) 0</p><p>127.0.0.1:6379&gt; zrevrank language js<br>(integer) 2</p><p>127.0.0.1:6379&gt; zrevrank language java<br>(integer) 1</p><pre><code>## ZINCRBY- 格式：zincrby key increment member- 向有序集合 key 中的成员 member 的 score 值进行增加。- 如果 key 中不存在 member，则在 key 中创建一个 member，并且该 member 的 score 为 设置的值。</code></pre><p>127.0.0.1:6379&gt; zincrby language 100 php<br>“200”</p><p>127.0.0.1:6379&gt; zincrby language 100 python<br>“100”</p><pre><code>## ZREM- 从集合中删除指定 member。</code></pre><p> 127.0.0.1:6379&gt; zrem language python<br>(integer) 1</p><p>127.0.0.1:6379&gt; zrange language 0 -1 withscores<br>1) “js”<br>2) “80”<br>3) “java”<br>4) “90”<br>5) “php”<br>6) “200”<br> <code>`</code></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis学习笔记-----基本数据类型之哈希（HASH）</title>
      <link href="/2019/12/12/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%93%88%E5%B8%8C%EF%BC%88HASH%EF%BC%89/"/>
      <url>/2019/12/12/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%93%88%E5%B8%8C%EF%BC%88HASH%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="哈希（HASH）"><a href="#哈希（HASH）" class="headerlink" title="哈希（HASH）"></a>哈希（HASH）</h1><blockquote><p>哈希就像是一个微缩版的 redis。由键值对组成。一般讲数据库中的记录取出直接放入 redis 中使用。</p></blockquote><h2 id="HSET、HMSET"><a href="#HSET、HMSET" class="headerlink" title="HSET、HMSET"></a>HSET、HMSET</h2><ul><li>设置单个key</li><li>一次设置多个key</li></ul><blockquote><p>经过测试当前版本5.0.4，hset 也可以一次设置多个 key</p></blockquote><h3 id="hset-设置多个-key"><a href="#hset-设置多个-key" class="headerlink" title="hset 设置多个 key"></a>hset 设置多个 key</h3><pre><code>&gt; hset user:1 name jack email jack@qq.com(integer) 2&gt; hget user:1 name&quot;jack&quot;&gt; hget user:1 email&quot;jack@qq.com&quot;</code></pre><h3 id="hset-设置单个-key"><a href="#hset-设置单个-key" class="headerlink" title="hset 设置单个 key"></a>hset 设置单个 key</h3><pre><code>&gt; hset user:2 name tom email tom@qq.com(integer) 2&gt; hget user:2 name&quot;tom&quot;&gt; hget user:2 email&quot;tom@qq.com&quot;</code></pre><h2 id="HGET、HMGET"><a href="#HGET、HMGET" class="headerlink" title="HGET、HMGET"></a>HGET、HMGET</h2><ul><li>hget 获取单个 key 的值</li><li>hmget 一次获取多个 key 的值</li></ul><pre><code>&gt; hmget user:2 name email1) &quot;tom&quot;2) &quot;tom@qq.com&quot;</code></pre><h2 id="HEDL"><a href="#HEDL" class="headerlink" title="HEDL"></a>HEDL</h2><ul><li>删除一个或多个指定的key</li></ul><pre><code>&gt; hdel user:2 name(integer) 1&gt; hget user:2 name(nil)&gt; hget user:2 email&quot;tom@qq.com&quot;</code></pre><h2 id="HSETNX"><a href="#HSETNX" class="headerlink" title="HSETNX"></a>HSETNX</h2><ul><li>设置指定key的值，如果可以已经存在，则不进行任何操作</li></ul><pre><code>&gt; hsetnx user:2 email 2@qq.com(integer) 0&gt; hsetnx user:2 name tome(integer) 1&gt; hmget user:2 name email1) &quot;tome&quot;2) &quot;tom@qq.com&quot;</code></pre><h2 id="HVALS"><a href="#HVALS" class="headerlink" title="HVALS"></a>HVALS</h2><p>-返回所有格值</p><pre><code>&gt; hvals user:21) &quot;tom@qq.com&quot;2) &quot;tome&quot;</code></pre><h2 id="HKEYS"><a href="#HKEYS" class="headerlink" title="HKEYS"></a>HKEYS</h2><ul><li>返回所有的键</li></ul><pre><code>&gt; hkeys user:21) &quot;email&quot;2) &quot;name&quot;</code></pre><h2 id="HGETALL"><a href="#HGETALL" class="headerlink" title="HGETALL"></a>HGETALL</h2><ul><li>返回所有的键和值</li><li>返回值中，每个字段名的下一个就是他的值</li></ul><pre><code>&gt; hgetall user:21) &quot;email&quot;2) &quot;tom@qq.com&quot;3) &quot;name&quot;4) &quot;tome&quot;</code></pre><h2 id="HEXISTS"><a href="#HEXISTS" class="headerlink" title="HEXISTS"></a>HEXISTS</h2><ul><li>检查指定键是否存在</li></ul><pre><code>&gt; hexists user:2 class(integer) 0&gt; hexists user:2 email(integer) 1</code></pre><h2 id="HINCRBY"><a href="#HINCRBY" class="headerlink" title="HINCRBY"></a>HINCRBY</h2><ul><li>对哈希中指定的键进行自增操作，如果对应的键不存在，则创建。如果存在，直接新增</li><li>所操作的键的值必须为整型</li></ul><pre><code>&gt; hincrby user:2 old 1(integer) 1&gt; hgetall user:21) &quot;email&quot;2) &quot;tom@qq.com&quot;3) &quot;name&quot;4) &quot;tome&quot;5) &quot;sex&quot;6) &quot;man&quot;7) &quot;old&quot;8) &quot;1&quot;&gt; hincrby user:2 old 2(integer) 3&gt; hgetall user:21) &quot;email&quot;2) &quot;tom@qq.com&quot;3) &quot;name&quot;4) &quot;tome&quot;5) &quot;sex&quot;6) &quot;man&quot;7) &quot;old&quot;8) &quot;3&quot;&gt; hincrby user:2 name 1(error) ERR hash value is not an integer</code></pre><h2 id="HINCRBYFLOAT"><a href="#HINCRBYFLOAT" class="headerlink" title="HINCRBYFLOAT"></a>HINCRBYFLOAT</h2><ul><li>同上面的 hincrby，只不过支持的值是 float 类型</li></ul><h2 id="HLEN"><a href="#HLEN" class="headerlink" title="HLEN"></a>HLEN</h2><ul><li>返回指定哈希所包含的字段数量（key 的数量）</li></ul><pre><code>&gt; hlen user:2(integer) 4&gt; hgetall user:21) &quot;email&quot;2) &quot;tom@qq.com&quot;3) &quot;name&quot;4) &quot;tome&quot;5) &quot;sex&quot;6) &quot;man&quot;7) &quot;old&quot;8) &quot;3&quot;</code></pre><h2 id="HSTRLEN"><a href="#HSTRLEN" class="headerlink" title="HSTRLEN"></a>HSTRLEN</h2><ul><li>返回指定 key 的 value 的字符串长度</li><li>如果 value 或 哈希不存在，则返回0</li></ul><pre><code>&gt; hstrlen user:2 name(integer) 4&gt; hget user:2 name&quot;tome&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis学习笔记-----基本数据类型之集合</title>
      <link href="/2019/12/10/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%9B%86%E5%90%88/"/>
      <url>/2019/12/10/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="集合（Set）"><a href="#集合（Set）" class="headerlink" title="集合（Set）"></a>集合（Set）</h1><blockquote><p>与 list 类似，区别是 set 中的值是不重复的。</p></blockquote><h2 id="SADD"><a href="#SADD" class="headerlink" title="SADD"></a>SADD</h2><ul><li>将一个或多个member元素加入到集合key当中，已经存在于集合的member元素将被忽略。</li><li>假如key不存在，则创建一个只包含member元素作成员的集合。</li><li>当key不是集合类型时，返回一个错误。</li></ul><pre><code>&gt; sadd k1 v1 v2 v3(integer) 3</code></pre><h2 id="SMEMBERS"><a href="#SMEMBERS" class="headerlink" title="SMEMBERS"></a>SMEMBERS</h2><ul><li>返回集合key中的所有成员。</li></ul><pre><code>&gt; smembers k11) &quot;v2&quot;2) &quot;v3&quot;3) &quot;v1&quot;</code></pre><h2 id="SREM"><a href="#SREM" class="headerlink" title="SREM"></a>SREM</h2><ul><li>移除集合key中的一个或多个member元素，不存在的member元素会被忽略。</li><li>当key不是集合类型，返回一个错误。</li></ul><pre><code>&gt; srem k1 v2 v1(integer) 2&gt; smembers k11) &quot;v3&quot;</code></pre><h2 id="SISMEMBER"><a href="#SISMEMBER" class="headerlink" title="SISMEMBER"></a>SISMEMBER</h2><ul><li>判断 member 元素是否是集合 key 的成员。</li><li>返回 1，则 member 元素在集合中。返回 0，则不在集合中。</li></ul><pre><code>&gt; sismember k1 v3(integer) 1&gt; sismember k1 v2(integer) 0</code></pre><h2 id="SCARD"><a href="#SCARD" class="headerlink" title="SCARD"></a>SCARD</h2><ul><li>返回集合key的基数(集合中元素的数量)。</li></ul><pre><code>&gt; scard k1(integer) 1&gt; sadd k1 v4 v5(integer) 2&gt; scard k1(integer) 3</code></pre><h2 id="SMOVE"><a href="#SMOVE" class="headerlink" title="SMOVE"></a>SMOVE</h2><ul><li>将 member 元素从 source 集合移动到 destination 集合。</li><li>如果 source 集合不存在或不包含指定的 member 元素，则命令不执行任何操作，仅返回0。</li><li>当 destination 集合已经包含 member 元素时，则命令只是简单地将 source 集合中的 member 元素删除。</li><li>当source或destination不是集合类型时，返回一个错误。</li></ul><pre><code>&gt; smembers k11) &quot;v4&quot;2) &quot;v5&quot;3) &quot;v3&quot;&gt; smembers k2(empty list or set)&gt; smove k1 k2 v4(integer) 1&gt; smembers k11) &quot;v5&quot;2) &quot;v3&quot;&gt; smembers k21) &quot;v4&quot;</code></pre><h2 id="SPOP"><a href="#SPOP" class="headerlink" title="SPOP"></a>SPOP</h2><ul><li>移除并返回集合中的一个随机元素。</li><li>被移除的随机元素。</li><li>当key不存在或key是空集时，返回nil。</li></ul><pre><code>&gt; smembers k11) &quot;v5&quot;2) &quot;v3&quot;&gt; spop k1&quot;v3&quot;&gt; smembers k11) &quot;v5&quot;&gt; spop k1&quot;v5&quot;&gt; smembers k1(empty list or set)&gt; spop k1(nil)</code></pre><h2 id="SRANDMEMBER"><a href="#SRANDMEMBER" class="headerlink" title="SRANDMEMBER"></a>SRANDMEMBER</h2><ul><li>返回集合中的一个随机元素。(不删除)</li><li>返回值为被选中的随机元素。 当 key 不存在或 key 是空集时，返回nil。</li></ul><pre><code>&gt; sadd k1 v1 v2 v3(integer) 3&gt; smembers k11) &quot;v2&quot;2) &quot;v3&quot;3) &quot;v1&quot;&gt; srandmember k1&quot;v3&quot;&gt; smembers k11) &quot;v2&quot;2) &quot;v3&quot;3) &quot;v1&quot;</code></pre><h2 id="SINTER"><a href="#SINTER" class="headerlink" title="SINTER"></a>SINTER</h2><ul><li>返回给定的集合的交集。</li><li>当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。</li></ul><pre><code>&gt; smembers k11) &quot;v2&quot;2) &quot;v3&quot;3) &quot;v1&quot;&gt; smembers k21) &quot;v4&quot;2) &quot;v1&quot;3) &quot;v2&quot;4) &quot;v5&quot;5) &quot;v6&quot;&gt; sinter k1 k21) &quot;v2&quot;2) &quot;v1&quot;</code></pre><h2 id="SINTERSTORE"><a href="#SINTERSTORE" class="headerlink" title="SINTERSTORE"></a>SINTERSTORE</h2><ul><li>基本等同于 sinter 命令，但它将结果保存在一个新的集合里。</li><li>如果要保存的集合已经存在，则将其覆盖。</li><li>返回结果集合中成员的数量。</li></ul><pre><code>&gt; smembers k11) &quot;v2&quot;2) &quot;v3&quot;3) &quot;v1&quot;&gt; smembers k21) &quot;v4&quot;2) &quot;v1&quot;3) &quot;v2&quot;4) &quot;v5&quot;5) &quot;v6&quot;&gt; sinterstore k3 k1 k2(integer) 2&gt; smembers k31) &quot;v2&quot;2) &quot;v1&quot;</code></pre><h2 id="SUNION"><a href="#SUNION" class="headerlink" title="SUNION"></a>SUNION</h2><ul><li>返回给定的所有集合的并集。</li></ul><pre><code>&gt; smembers k11) &quot;v2&quot;2) &quot;v3&quot;3) &quot;v1&quot;&gt; smembers k21) &quot;v4&quot;2) &quot;v1&quot;3) &quot;v2&quot;4) &quot;v5&quot;5) &quot;v6&quot;&gt; sunion k1 k21) &quot;v4&quot;2) &quot;v3&quot;3) &quot;v1&quot;4) &quot;v2&quot;5) &quot;v5&quot;6) &quot;v6&quot;</code></pre><h2 id="SUNIONSTORE"><a href="#SUNIONSTORE" class="headerlink" title="SUNIONSTORE"></a>SUNIONSTORE</h2><ul><li>基本等同于 sunion 命令，但它将结果保存在一个新的集合里。</li><li>如果要保存的集合已经存在，则将其覆盖。</li><li>返回结果集合中成员的数量。</li></ul><pre><code>&gt; smembers k11) &quot;v2&quot;2) &quot;v3&quot;3) &quot;v1&quot;&gt; smembers k21) &quot;v4&quot;2) &quot;v1&quot;3) &quot;v2&quot;4) &quot;v5&quot;5) &quot;v6&quot;&gt; sunionstore k4 k1 k2(integer) 6&gt; smembers k41) &quot;v4&quot;2) &quot;v3&quot;3) &quot;v1&quot;4) &quot;v2&quot;5) &quot;v5&quot;6) &quot;v6&quot;</code></pre><h2 id="SDIFF"><a href="#SDIFF" class="headerlink" title="SDIFF"></a>SDIFF</h2><ul><li>返回给定的所有集合的差集。</li></ul><pre><code>&gt; smembers tom1) &quot;orange&quot;2) &quot;banner&quot;3) &quot;apple&quot;&gt; smembers jack1) &quot;pants&quot;2) &quot;t-shirt&quot;3) &quot;apple&quot;&gt; sdiff tom jack1) &quot;orange&quot;2) &quot;banner&quot;</code></pre><p>SDIFFSTORE</p><ul><li>基本等同于 sdiff 命令，但它将结果保存在一个新的集合里。</li><li>如果要保存的集合已经存在，则将其覆盖。</li><li>返回结果集合中成员的数量。</li></ul><pre><code>&gt; smembers tom1) &quot;orange&quot;2) &quot;banner&quot;3) &quot;apple&quot;&gt; smembers jack1) &quot;pants&quot;2) &quot;t-shirt&quot;3) &quot;apple&quot;&gt; sdiffstore new tom jack(integer) 2&gt; smembers new1) &quot;orange&quot;2) &quot;banner&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis学习笔记-----基本数据类型之列表</title>
      <link href="/2019/12/01/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%88%97%E8%A1%A8/"/>
      <url>/2019/12/01/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="List-列表"><a href="#List-列表" class="headerlink" title="List 列表"></a>List 列表</h1><h2 id="LPUSH、RPUSH、LRANGE"><a href="#LPUSH、RPUSH、LRANGE" class="headerlink" title="LPUSH、RPUSH、LRANGE"></a>LPUSH、RPUSH、LRANGE</h2><ul><li>lpush 可以将一个或多个值插入到列表的头部</li><li>rpush 可以将一个或多个值插入到列表的头部</li><li>lrange 从列表的头部查看列表，元素下标从 0 开始，-1 表示最后一个元素，-2 表示倒数第二个元素，以此类推</li></ul><pre><code>&gt; rpush mylist A    //将 A 插入到 mylist 列表的尾部(integer) 1&gt; rpush mylist B    //将 B 插入到 mylist 列表的尾部(integer) 2&gt; lpush mylist first    //将 first 插入到 mylist 列表的头部(integer) 3&gt; rpush mylist C D E    //将 C、D、E 插入到列表 mylist 的尾部(integer) 6&gt; lrange mylist 0 -1    //从列表的头部查看列表的全部内容1) &quot;first&quot;2) &quot;A&quot;3) &quot;B&quot;4) &quot;C&quot;5) &quot;D&quot;6) &quot;E&quot;&gt; lrange mylist 0 2 //从列表的头部查看 mylist 列表，从 0 开始，到 2 结束（元素下标从 0 开始，-1 表示最后一个元素，-2 表示倒数第二个元素，以此类推）1) &quot;first&quot;2) &quot;A&quot;3) &quot;B&quot;</code></pre><h2 id="LPOP、RPOP"><a href="#LPOP、RPOP" class="headerlink" title="LPOP、RPOP"></a>LPOP、RPOP</h2><ul><li>lpop 移除并返回头部元素</li><li>rpop 移除并返回尾部元素</li></ul><pre><code>&gt; lrange mylist 0 -11) &quot;first&quot;2) &quot;A&quot;3) &quot;B&quot;4) &quot;C&quot;5) &quot;D&quot;6) &quot;E&quot;&gt; lpop mylist       //移除头部元素，并返回该元素&quot;first&quot;&gt; lrange mylist 0 -11) &quot;A&quot;2) &quot;B&quot;3) &quot;C&quot;4) &quot;D&quot;5) &quot;E&quot;&gt; rpop mylist   //移除尾部元素，并返回该元素&quot;E&quot;&gt; lrange mylist 0 -11) &quot;A&quot;2) &quot;B&quot;3) &quot;C&quot;4) &quot;D&quot;&gt; rpop abc  //当 abc 列表不存在时，返回 nil(nil)</code></pre><h2 id="LINDEX"><a href="#LINDEX" class="headerlink" title="LINDEX"></a>LINDEX</h2><ul><li>返回列表指定下标的元素（下标从0开始，-1 为最后一个元素）</li></ul><pre><code>&gt; lrange mylist 0 -11) &quot;A&quot;2) &quot;B&quot;3) &quot;C&quot;4) &quot;D&quot;&gt; lindex mylist -1&quot;D&quot;&gt; lindex mylist 2&quot;C&quot;</code></pre><h2 id="LTRIM"><a href="#LTRIM" class="headerlink" title="LTRIM"></a>LTRIM</h2><ul><li>让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。下标与之前介绍的写法都一致，这里不赘述</li></ul><pre><code>&gt; lrange mylist 0 -11) &quot;A&quot;2) &quot;B&quot;3) &quot;C&quot;4) &quot;D&quot;&gt; ltrim mylist 0 1OK&gt; lrange mylist 0 -11) &quot;A&quot;2) &quot;B&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1、Redis 学习笔记————基本数据类型之字符串</title>
      <link href="/2019/11/27/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2019/11/27/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串（string）"><a href="#字符串（string）" class="headerlink" title="字符串（string）"></a>字符串（string）</h2><h3 id="SET、GET-基本操作"><a href="#SET、GET-基本操作" class="headerlink" title="SET、GET |基本操作"></a>SET、GET |基本操作</h3><ul><li>使用 set 关键字设置</li><li>使用 get 关键字获取字符串</li><li>值可以是任何类型的字符串（包括二进制，例如图片），值不能超过512 MB</li></ul><pre><code>&gt; set key valueOK&gt; get key&quot;value&quot;</code></pre><h3 id="APPEND-追加值"><a href="#APPEND-追加值" class="headerlink" title="APPEND |追加值"></a>APPEND |追加值</h3><ul><li>append 命令，如果 key 存在，则在 value 后追加值，不存在，则先创建一个 value 为空字符串的 key，然后在追加。</li></ul><pre><code>&gt; append haha 123(integer) 3&gt; get haha&quot;123&quot;&gt; append haha 456(integer) 6&gt; get haha&quot;123456&quot;</code></pre><h3 id="MSET-一次存储或获取多个-key"><a href="#MSET-一次存储或获取多个-key" class="headerlink" title="MSET |一次存储或获取多个 key"></a>MSET |一次存储或获取多个 key</h3><pre><code>&gt; mset a 10 b 20 c 30OK&gt; mget a b c1) &quot;10&quot;2) &quot;20&quot;3) &quot;30&quot;</code></pre><h3 id="GETSET-获取原值并赋予新值"><a href="#GETSET-获取原值并赋予新值" class="headerlink" title="GETSET |获取原值并赋予新值"></a>GETSET |获取原值并赋予新值</h3><ul><li>获取 key 原有的值，并赋予新值</li></ul><pre><code>&gt; set num 100OK&gt; getset num 50&quot;100&quot;&gt; get num&quot;50&quot;</code></pre><h3 id="EXISTS、DEL-删除键、检查键是否存在"><a href="#EXISTS、DEL-删除键、检查键是否存在" class="headerlink" title="EXISTS、DEL |删除键、检查键是否存在"></a>EXISTS、DEL |删除键、检查键是否存在</h3><ul><li>删除成功返回 1，失败返回 0</li><li>存在返回 1，不存在返回 0</li></ul><pre><code>&gt; set abc 123OK&gt; exists def(integer) 0&gt; exists abc(integer) 1&gt; del def(integer) 0&gt; del abc(integer) 1</code></pre><h3 id="TYPE-查看数据类型操作命令"><a href="#TYPE-查看数据类型操作命令" class="headerlink" title="TYPE |查看数据类型操作命令"></a>TYPE |查看数据类型操作命令</h3><ul><li>查询的键存在返回相应的数据类型，不存在返回 none</li></ul><pre><code>&gt; set hello wordOK&gt; type hellostring&gt; type wordnone</code></pre><h3 id="SETEX、TTL、PSETEX、PTTL-设置过期时间（1-秒-1000-毫秒）"><a href="#SETEX、TTL、PSETEX、PTTL-设置过期时间（1-秒-1000-毫秒）" class="headerlink" title="SETEX、TTL、PSETEX、PTTL |设置过期时间（1 秒 = 1000 毫秒）"></a>SETEX、TTL、PSETEX、PTTL |设置过期时间（1 秒 = 1000 毫秒）</h3><ul><li>使用 setex 设置以秒为单位的过期时间</li><li>使用 psetex 设置以毫秒为单位的过期时间</li><li>使用 ttl 获取以秒为单位的剩余时间</li><li>使用 pttl 获取以毫秒为单位的剩余时间<blockquote><p><strong>使用 ttl 和 pttl 查询键的过期时间，键不存在返回 -2，没有设置过期时间返回 -1，其他情况返回以秒为单位的剩余时间</strong></p></blockquote></li></ul><pre><code>// 秒为单位&gt; setex hello 10 11111OK&gt; ttl hello(integer) 6&gt; ttl hello(integer) 4&gt; ttl hello(integer) 3&gt; get hello(nil)</code></pre><pre><code>//毫秒为单位&gt; psetex test 10000 1111OK&gt; pttl test(integer) 8455&gt; pttl test(integer) 7430&gt; pttl test(integer) 6733&gt; get test(nil)</code></pre><h3 id="INCR、INCRBY、DECR、DECRBY-原子递增递减"><a href="#INCR、INCRBY、DECR、DECRBY-原子递增递减" class="headerlink" title="INCR、INCRBY、DECR、DECRBY |原子递增递减"></a>INCR、INCRBY、DECR、DECRBY |原子递增递减</h3><ul><li>set 一个值为整型的字符串，可以使用 incr 操作命令自增</li><li>可以使用 incrby 操作命令指定步长自增</li><li>incr 是原子操作。也就是说客户端 1 和客户端 2 同时读出10，他们俩都对其加 1 操作，最终的值一定是12。</li><li>相应的有 decr 和 decrby 操作命令进行递减操作</li></ul><pre><code>&gt; set count 100OK&gt; incr count(integer) 101&gt; incr count(integer) 102&gt; incrby count 100(integer) 202</code></pre><h3 id="SETNX-不存在则设置，存在则不进行任何操作"><a href="#SETNX-不存在则设置，存在则不进行任何操作" class="headerlink" title="SETNX |不存在则设置，存在则不进行任何操作"></a>SETNX |不存在则设置，存在则不进行任何操作</h3><ul><li>set 命令在执行的时候，如果 key 已经存在，则新值会覆盖旧值。</li><li>setnx 命令，如果 key 存在，则不做任何操作，否则等同于 set。</li></ul><pre><code>&gt; set test 123OK&gt; set test 456OK&gt; get test&quot;456&quot;&gt; setnx test aaa(integer) 0&gt; get test&quot;456&quot;</code></pre><h3 id="STRLEN-计算-value-的长度"><a href="#STRLEN-计算-value-的长度" class="headerlink" title="STRLEN | 计算 value 的长度"></a>STRLEN | 计算 value 的长度</h3><pre><code>&gt; set xixi abc123OK&gt; strlen xixi(integer) 6</code></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的三十岁</title>
      <link href="/2019/09/27/%E6%88%91%E7%9A%84%E4%B8%89%E5%8D%81%E5%B2%81/"/>
      <url>/2019/09/27/%E6%88%91%E7%9A%84%E4%B8%89%E5%8D%81%E5%B2%81/</url>
      
        <content type="html"><![CDATA[<blockquote><p>没有想到时间过的这么快，就这么来到了三十岁的生日，总觉得需要记录点什么。</p></blockquote><p>没有想三十岁来的这么快，自己还没有完全做好准备。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用LaraDock配置laravel-echo-sever遇到的坑</title>
      <link href="/2019/08/15/%E4%BD%BF%E7%94%A8LaraDock%E9%85%8D%E7%BD%AElaravel-echo-sever%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
      <url>/2019/08/15/%E4%BD%BF%E7%94%A8LaraDock%E9%85%8D%E7%BD%AElaravel-echo-sever%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前情提要：项目需要使用 webSocket 进行通信，并且使用的是 <a href="https://laradock.io/" target="_blank" rel="noopener">LaraDock</a> 作为环境。所以使用 laravel-echo-server、laravel-horizon、php-worker 容器进行环境的部署。因为对 Docker 并不懂，仅仅只是使用 LaraDock，所以过程中遇到了很多问题，特此记录下来。</p></blockquote><h2 id="坑二-参考资料"><a href="#坑二-参考资料" class="headerlink" title="坑二 参考资料"></a>坑二 <a href="https://github.com/laradock/laradock/issues/1340#issuecomment-390484505" target="_blank" rel="noopener">参考资料</a></h2><blockquote><p>LaraDock 的 Nginx 使用多站点配置的时候，laravel-echo-server 无法链接到 web 进行认证。</p></blockquote><p>通过在 nginx 容器配置中添加别名 <strong> laradock/docker-compose.yml </strong></p><pre class=" language-yml"><code class="language-yml">### NGINX Server #########################################    nginx:      build:        context: ./nginx        args:          - PHP_UPSTREAM_CONTAINER=${NGINX_PHP_UPSTREAM_CONTAINER}          - PHP_UPSTREAM_PORT=${NGINX_PHP_UPSTREAM_PORT}      volumes:        - ${APP_CODE_PATH_HOST}:${APP_CODE_PATH_CONTAINER}        - ${NGINX_HOST_LOG_PATH}:/var/log/nginx        - ${NGINX_SITES_PATH}:/etc/nginx/sites-available      ports:        - "${NGINX_HOST_HTTP_PORT}:80"        - "${NGINX_HOST_HTTPS_PORT}:443"      depends_on:        - php-fpm      networks:        # before ----        # - frontend        # - backend        # end before ----        frontend:        backend:            aliases:              - my-site.com    ##别名地址，在laravel-echo-server.json 中填写该地址就可以了</code></pre><p>更改完配置之后需要重新构建 nginx 和 laravel-echo-server 容器。<br>并重新开启。</p><h2 id="坑二"><a href="#坑二" class="headerlink" title="坑二"></a>坑二</h2><blockquote><p>larave-echo-server 的 ssl 证书</p></blockquote><ol><li>直接配置 ssl 证书。（不明白证书需要发在目录的什么位置，所以 google 了很多内容之后选择了下面的方法。以后如果有机会补充第一点）</li><li>配置 nginx 反向代理。 <a href="https://github.com/tlaverdure/laravel-echo-server" target="_blank" rel="noopener">laravel-echo-server</a></li></ol><pre class=" language-nginx"><code class="language-nginx"><span class="token comment" spellcheck="true">#以下内容需要在你的 nginx 站点配置文件的 server{} 块之内</span><span class="token keyword">location</span> <span class="token operator">/</span>socket<span class="token punctuation">.</span>io <span class="token punctuation">{</span>        <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>laravel<span class="token operator">-</span>echo<span class="token operator">-</span><span class="token keyword">server</span><span class="token punctuation">:</span><span class="token number">6001</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">#填写非 https 的地址进行反向代理，如果 Echo 和 Nginx 在同一个服务器可以填写 localhost</span>        <span class="token keyword">proxy_http_version</span> <span class="token number">1.1</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> Upgrade <span class="token variable">$http_upgrade</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> Connection <span class="token string">"Upgrade"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ol start="3"><li>配置 laravel-echo-server 配置文件 laravel-echo-server.json 为如下内容</li></ol><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>        <span class="token property">"authHost"</span><span class="token operator">:</span> <span class="token string">"https://laravel-echo-server"</span><span class="token punctuation">,</span> //注意：改地址指向 web 站点，即 echo-server 想web端认证的地址        <span class="token property">"authEndpoint"</span><span class="token operator">:</span> <span class="token string">"/broadcasting/auth"</span><span class="token punctuation">,</span>        <span class="token property">"clients"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token property">"database"</span><span class="token operator">:</span> <span class="token string">"redis"</span><span class="token punctuation">,</span>        <span class="token property">"databaseConfig"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                <span class="token property">"redis"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                        <span class="token property">"port"</span><span class="token operator">:</span> <span class="token string">"6379"</span><span class="token punctuation">,</span>                        <span class="token property">"host"</span><span class="token operator">:</span> <span class="token string">"redis"</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token property">"devMode"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token property">"host"</span><span class="token operator">:</span> <span class="token null">null</span><span class="token punctuation">,</span>        <span class="token property">"port"</span><span class="token operator">:</span> <span class="token string">"6001"</span><span class="token punctuation">,</span>        <span class="token property">"protocol"</span><span class="token operator">:</span> <span class="token string">"http"</span><span class="token punctuation">,</span>        <span class="token property">"socketio"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token property">"sslCertPath"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>        <span class="token property">"sslKeyPath"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">}</span></code></pre><h2 id="操作技巧"><a href="#操作技巧" class="headerlink" title="操作技巧"></a>操作技巧</h2><ol><li>不使用 -d 参数可以更好的进行调试<pre class=" language-shell"><code class="language-shell">docker-compose up laravel-echo-server</code></pre></li><li>使用 logs 参数可以查看详情的日志输出<pre class=" language-shell"><code class="language-shell">docker-compose logs laravel-echo-server</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaraDock </tag>
            
            <tag> 开发环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel学习笔记</title>
      <link href="/2019/06/18/Laravel%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/06/18/Laravel%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="第一步：了解几个常用名称"><a href="#第一步：了解几个常用名称" class="headerlink" title="第一步：了解几个常用名称"></a>第一步：了解几个常用名称</h2><blockquote><p>代码基于 Laravel-5.8 部分内容给其他版本不一致，但整体逻辑是没有太大差别的。</p></blockquote><blockquote><p>Service Container、Service Provider、Facades、Contracts。当第一次使用 Laravel 框架的时候被这几个词直接搞蒙圈了，完全不知道是什么意思，尤其是在看完文档之后，真的想说 WTF 。不过不知道也不会太影响使用。（😅有个朋友说过，不管用着在 NB 的框架，依然可以写出屎一样的代码）</p></blockquote><h3 id="Service-Container"><a href="#Service-Container" class="headerlink" title="Service Container"></a>Service Container</h3><p>中文解释：服务容器 （😂 是不是看完这个翻译更不知道是啥了）</p><p>我的理解：一个装着各种各样的服务实例的容器。这些服务就是 Laravel 中的各种模块，如 Redis、Route 等等。</p><p>实现一个简单的容器：</p><pre class=" language-php"><code class="language-php"><span class="token keyword">class</span> <span class="token class-name">Container</span><span class="token punctuation">{</span>  <span class="token keyword">protected</span> <span class="token variable">$binds</span><span class="token punctuation">;</span>  <span class="token keyword">protected</span> <span class="token variable">$instances</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token variable">$abstract</span><span class="token punctuation">,</span> <span class="token variable">$concrete</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//Todo: 向 container 添加一种对象的的生产方式</span>    <span class="token comment" spellcheck="true">//$abstract: 第一个参数 $abstract, 一般为一个字符串(有时候也会是一个接口), 当你需要 make 这个类的对象的时候, 传入这个字符串(或者接口), 这样make 就知道制造什么样的对象了</span>    <span class="token comment" spellcheck="true">//$concrete: 第二个参数 $concrete, 一般为一个 Closure 或者 一个单例对象, 用于说明制造这个对象的方式</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$concrete</span> <span class="token keyword">instanceof</span> <span class="token class-name">Closure</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">binds</span><span class="token punctuation">[</span><span class="token variable">$abstract</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$concrete</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">instances</span><span class="token punctuation">[</span><span class="token variable">$abstract</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$concrete</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token variable">$abstract</span><span class="token punctuation">,</span> <span class="token variable">$parameters</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//Todo: 生产一种对象</span>    <span class="token comment" spellcheck="true">//$abstract: 在bind方法中已经介绍过</span>    <span class="token comment" spellcheck="true">//$parameters: 生产这种对象所需要的参数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">instances</span><span class="token punctuation">[</span><span class="token variable">$abstract</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">instances</span><span class="token punctuation">[</span><span class="token variable">$abstract</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">array_unshift</span><span class="token punctuation">(</span><span class="token variable">$parameters</span><span class="token punctuation">,</span> <span class="token variable">$this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">call_user_func_array</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">binds</span><span class="token punctuation">[</span><span class="token variable">$abstract</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token variable">$parameters</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="为什么理解-IOC-Container-对于理解-Laravel-架构是如此的重要？"><a href="#为什么理解-IOC-Container-对于理解-Laravel-架构是如此的重要？" class="headerlink" title="为什么理解 IOC Container 对于理解 Laravel 架构是如此的重要？"></a>为什么理解 IOC Container 对于理解 Laravel 架构是如此的重要？</h4><blockquote><p>因为在 Laravel 中，你所能使用到的 Laravel 的特性和功能几乎全部是由 IOC Container 实现的。</p></blockquote><pre class=" language-php"><code class="language-php">Cache<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> Route<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token string">'HomeController@index'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面的 Cache、Route 都是通过把各自类的实现 bind 到 Container 中，然后 Container make 出的一个实例。<br>那么它们是在哪里进行的 bind 呢？没错就是 Service Provider 中。</p><h3 id="Service-Provider"><a href="#Service-Provider" class="headerlink" title="Service Provider"></a>Service Provider</h3><p>在 Laravel 中有两种方式来使用 IOC Container：</p><ol><li>通过 Service Provider</li><li>不通过 Service Provider<blockquote><p>一般情况都是使用第一种方式。</p></blockquote></li></ol><h4 id="不通过-Service-Provider-来使用-IOC-Container"><a href="#不通过-Service-Provider-来使用-IOC-Container" class="headerlink" title="不通过 Service Provider 来使用 IOC Container"></a>不通过 Service Provider 来使用 IOC Container</h4><p>实例：</p><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">//web.php</span><span class="token comment" spellcheck="true">//创建一个类</span><span class="token keyword">class</span> <span class="token class-name">Apple</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token variable">$id</span> <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Route<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//使用 app() 辅助方法将 Apple 类 bind 到 IOC Container 中  </span>  App<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Apple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//使用 App() 辅助方法将 Apple 实例 make 出来</span>  <span class="token variable">$apple</span> <span class="token operator">=</span> App<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//使用 Apple 类中的属性</span>  <span class="token keyword">return</span> <span class="token variable">$apple</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">id</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="通过-Service-Provider-来使用-IOC-Container"><a href="#通过-Service-Provider-来使用-IOC-Container" class="headerlink" title="通过 Service Provider 来使用 IOC Container"></a>通过 Service Provider 来使用 IOC Container</h4><blockquote><p>原因：我们知道，有时候我们的类、模块会有需要其他类和组件的情况，为了保证初始化阶段不会出现所需要的模块和组件没有注册的情况，laravel 将注册和初始化行为进行拆分，注册的时候就只能注册，初始化的时候就是初始化。拆分后的产物就是现在的 服务提供者。<br>可以想象这样一个场景，你要绑定 3 个类 A B C 到 IOC Container 中。 A，B，C 都是非常复杂的类。在 bind A 时，引用了一个类 B 的实例，那么想要获得类 B 的实例，就需要 B 已经被 bind，只有这样，我们的 IOC Container 才有能力 make 出一个 B 的实例。 而在 bind B 时，恰好又需要 C 的实例.<br>如果是这样的逻辑，那么在 bind A B C 时，就必须手动的严格安排 bind 的次序，而且这只是 3 个类的情况，如果有几十个类的话，人工已经无法完成了.<br>而这时就需要 Service Provider 的作用了。</p><blockquote><p>引用自——<a href="https://learnku.com/laravel/t/3361/starting-with-the-1-line-of-code-with-a-systematic-understanding-of-the-core-concepts-of-service-container#e9b441" target="_blank" rel="noopener">从 1 行代码开始，带你系统性地理解 Service Container 核心概念</a></p></blockquote></blockquote><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token comment" spellcheck="true">// 1. 创建一个 Apple 类 app/Test/Apple.php</span><span class="token keyword">namespace</span> <span class="token package">App<span class="token punctuation">\</span>Test</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Apple</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token variable">$id</span> <span class="token operator">=</span> <span class="token string">'agg'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//2. 使用 php artisan make:provider AppleProvider 生成 provider</span><span class="token keyword">namespace</span> <span class="token package">App<span class="token punctuation">\</span>Providers</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token package">Illuminate<span class="token punctuation">\</span>Support<span class="token punctuation">\</span>ServiceProvider</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token package">App<span class="token punctuation">\</span>Test<span class="token punctuation">\</span>Apple</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">AppleProvider</span> <span class="token keyword">extends</span> <span class="token class-name">ServiceProvider</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * Register services.     *     * @return void     */</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">register</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">app</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">singleton</span><span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token variable">$app</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Apple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Bootstrap services.     *     * @return void     */</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">boot</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 3. 在 config/app.php 中注册 APPServiceProvider</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token string">'providers'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    App\<span class="token package">Providers<span class="token punctuation">\</span>AppleProvider</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">class</span><span class="token punctuation">,</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment" spellcheck="true">// 4. 最终在 route/web.php 中使用</span>Route<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">app</span><span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">app</span><span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*输出结果，因为使用了单例的模式进行绑定所以输出的两个实例的编号是一致的object(App\Test\Apple)#206 (1) { ["id"]=> string(3) "agg" } object(App\Test\Apple)#206 (1) { ["id"]=> string(3) "agg" }*/</span></code></pre><h3 id="Facades"><a href="#Facades" class="headerlink" title="Facades"></a>Facades</h3><pre class=" language-php"><code class="language-php">Route<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token string">'HomeController@index'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>想必大家在第一使用 Laravel 的时候一定会注意到这行代码。在使用 phpStorm 之类的 IDE 工具是无法跳转到对应的类文件。那么这是为啥呢？</p></blockquote><p>你是无法找到对 Route 类的声明的，是因为使用了别名。别名是 PHP 的一个特性（ <a href="https://www.php.net/manual/zh/function.class-alias.php" target="_blank" rel="noopener">class_alias</a> 方法 ）。</p><p>别名在哪里设置呢——app/config/app.php</p><pre class=" language-php"><code class="language-php"><span class="token string">'aliases'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token string">'Route'</span> <span class="token operator">=</span><span class="token operator">></span> Illuminate\<span class="token package">Support<span class="token punctuation">\</span>Facades<span class="token punctuation">\</span>Route</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">class</span><span class="token punctuation">,</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><p>查看 <em>vendor/laravel/framework/src/Illuminate/Support/Facades/Route.php</em> 文件….哎？怎么只有这么点东西，get 呢？</p><pre class=" language-php"><code class="language-php"><span class="token keyword">namespace</span> <span class="token package">Illuminate<span class="token punctuation">\</span>Support<span class="token punctuation">\</span>Facades</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*   通过这行注释可以找到真实的 Route 类在什么地方 * @see \Illuminate\Routing\Router */</span><span class="token keyword">class</span> <span class="token class-name">Route</span> <span class="token keyword">extends</span> <span class="token class-name">Facade</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * Get the registered name of the component.     *     * @return string     */</span>    <span class="token keyword">protected</span> <span class="token keyword">static</span> <span class="token keyword">function</span> <span class="token function">getFacadeAccessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">'router'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>首先要知道 Facade 的作用：使用一个简单的语法，让你从 Laravel 的 IOC Container 中方便的 make 出你想要的对象。</p></blockquote><h4 id="Facade-实现原理（make）"><a href="#Facade-实现原理（make）" class="headerlink" title="Facade 实现原理（make）"></a>Facade 实现原理（make）</h4><ol><li>首先 Route 继承自 <code>Illuminate\Support\Facades</code>。</li><li><code>Illuminate\Support\Facades</code> 里也没有 get 静态方法。</li><li>使用了 <a href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.callstatic" target="_blank" rel="noopener">__callStatic()</a> 魔术方法。</li><li>在 Route 中调用静态的 get 方法，实际上 Illuminate\Support\Facades 中的 <code>__callStatic</code> 魔术方法被调用。</li><li>在 <a href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.callstatic" target="_blank" rel="noopener">__callStatic()</a> 方法中调用了静态的 getFaRoot 方法。</li><li>在 <code>getFacadeRoot</code> 方法中调用了静态的 <code>resolveFacadeInstance</code> 方法。</li><li><code>resolveFacadeInstance</code> 方法需要传递一个参数，该参数通过静态 <code>getFacadeAccessor</code> 方法获得。</li><li><code>getFacadeAccessor</code> 该方法在 Route 类中实现了 <code>getFacadeAccessor</code>并返回 route。</li><li><code>resolveFacadeInstance</code> 方法接收 route 字符串参数。首先判断是否为对象，当然不是啦，$name 是字符串。 然后判断该 <code>resolvedInstance</code> 数组中是否存在 route 相关信息，因为我们的程序是第一次运行当然也是没有的。 最后返回 <code>static::$app[&#39;route&#39;]</code>,同时把结果保存到 <code>resolvedInstance</code> 数组中。</li><li>$app 其实就是前面说的 Application 类的实例对象，这个类是一个 IOC Container，实例化过程在 Laravel 最开始的时候。Facade 初始化的时候也让自己有了一个 $app,这个就是 Application 类的实例化对象。</li><li>其实此时 $app 中并没有 ‘route’ 属性，那么为什么可以调用呢？因为 Application 继承了 Container, 而 Container 又继承了 ArrayAccess 类,并实现了 offsetGet 方法。 该方法的内容为 <code>return $this-&gt;make($key);</code> 这里就很明显了，直接make 出了一个 route 实例。</li><li>最终相当于 <code>$instance = static::getFacadeRoot();</code> 与 <code>$instance = $app-&gt;make(&#39;router&#39;);</code> 是相等的。</li></ol><pre class=" language-php"><code class="language-php">    <span class="token comment" spellcheck="true">//Illuminate\Support\Facades\Facades.php;</span>    <span class="token comment" spellcheck="true">//以上内容省略</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">function</span> <span class="token function">getFacadeRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">static</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">resolveFacadeInstance</span><span class="token punctuation">(</span><span class="token keyword">static</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getFacadeAccessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">//该方法被子类复写</span>    <span class="token keyword">protected</span> <span class="token keyword">static</span> <span class="token keyword">function</span> <span class="token function">getFacadeAccessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">'Facade does not implement getFacadeAccessor method.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> <span class="token keyword">static</span> <span class="token keyword">function</span> <span class="token function">resolveFacadeInstance</span><span class="token punctuation">(</span><span class="token variable">$name</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_object</span><span class="token punctuation">(</span><span class="token variable">$name</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token variable">$name</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token keyword">static</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$resolvedInstance</span><span class="token punctuation">[</span><span class="token variable">$name</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">static</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$resolvedInstance</span><span class="token punctuation">[</span><span class="token variable">$name</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">static</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$resolvedInstance</span><span class="token punctuation">[</span><span class="token variable">$name</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">static</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$app</span><span class="token punctuation">[</span><span class="token variable">$name</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">//以下内容省略 </span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">function</span> <span class="token function">__callStatic</span><span class="token punctuation">(</span><span class="token variable">$method</span><span class="token punctuation">,</span> <span class="token variable">$args</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$instance</span> <span class="token operator">=</span> <span class="token keyword">static</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getFacadeRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token variable">$instance</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">'A facade root has not been set.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token variable">$instance</span><span class="token operator">-</span><span class="token operator">></span><span class="token variable">$method</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token variable">$args</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h4 id="Facade-实现原理（bind）"><a href="#Facade-实现原理（bind）" class="headerlink" title="Facade 实现原理（bind）"></a>Facade 实现原理（bind）</h4><blockquote><p>在最开始就了解到，既然要 make，必须首先 bind。而且最好的方式是通过 serviceProvider 来 bind 类。 而且不论是 make 还是 bind 都需要一个 key，用来在容器中保存和查找这个类。上面讲的是使用 route 关键字进行 make 的过程。那么我们可以肯定在之前一定有一个使用 route 进行 bind 的操作。下面就进行 bind 的讲解。</p></blockquote><ol><li>首先 ServiceProvider 需要在 <code>config/app.php</code> 进行注册，我们在文件中找到对应 route 相关的内容，就是 <code>App\Providers\RouteServiceProvider::class,</code>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网易云音乐评论摘录</title>
      <link href="/2019/05/28/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E8%AF%84%E8%AE%BA%E6%91%98%E5%BD%95/"/>
      <url>/2019/05/28/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E8%AF%84%E8%AE%BA%E6%91%98%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>网易云音乐里有才的人实在太多，写出来的歌词或评论是真的不错。这里就把我觉得还不错的收藏一波吧（不定期更新）。</p><h2 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h2><blockquote><p>人会长大三次：<br>第一次是在发现自己不是世界的中心的时候。<br>第二次是在发现即使在怎么努力，终究还是有些事令人无能为力的时候。<br>第三次是在，明知道有些事可能会无能为力，但还是会尽力争取的时候。<br>————《一如少年模样》</p></blockquote><blockquote><p>白天要好好读书 书里有您不知道的<br>夜里要好好睡觉 梦里有你想要的<br>————《他》</p></blockquote><blockquote><p>你哭的最伤心的那个晚上变成大人了么？不是，是我忍住没哭的那个晚上。<br>————林宥嘉《天真有邪》</p></blockquote><blockquote><p>小时候，把一片口香糖掰成两块儿，很舍不得吃。那时候就天真的想，等我长大了，有钱了，就一口气嚼一包！一定特别甜！今天突然想到了儿时的这个梦想，就买了一包，当我把口香糖一片片塞进嘴里的时候，我的眼泪夺目而出。。。我哽咽着大口的嚼着。。。心里却满是酸楚，我想，这时光一点也不甜。。。<br>————周传雄《黄昏》 </p></blockquote><blockquote><p>爱上一个人，始于颜值，陷于才华，忠于人品；爱上一首歌，始于歌名，陷于旋律，忠于词义。</p></blockquote><blockquote><p>当我孑然一身的时候，贫穷与我不过是晚上吃馒头还是牛排的问题，无损我的快乐，当但我爱上一个姑娘的时候，我才深深感受到了贫穷所带来的自卑。</p></blockquote><blockquote><p>古代药房门口会挂着：<br>但愿世上无疾苦，宁可架上药生尘。<br>现在药房门口贴着：<br>会员积分，买十赠五，消费满58送20个鸡蛋。<br>————《只要平凡》</p></blockquote><blockquote><p>月老，麻烦下次为我牵红线的时候能换成钢丝吗，红线老TM断。<br>————《猫都瞧不起我》</p></blockquote><blockquote><p>我告诉你我喜欢你，并不是一定要和你在一起，只是希望今后的您，在遭遇人生低谷的时候，不要灰心，至少曾经有人被你的魅力所吸引，曾经是，以后也会是。<br>————《我要你》</p></blockquote><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><blockquote><p>你是我患得患失的梦 我是你可有可无的人 毕竟这穿越山河的剑 刺的都是用情至极的人 你是我辗转反侧的梦 我是你如梦山河的古人<br>————解忧少帅《写给黄淮》</p></blockquote><blockquote><p>像我这样优秀的人 本该灿烂过一生 怎么二十多年到头来 还在人海里浮沉<br>———— 毛不易《像我这样的人》</p></blockquote><blockquote><p>可是你曾经的那些梦，都已变得模糊看不见，那些为了理想的战斗，也不过是为了钱。<br>我不要在失败孤独中死去，我不要一直活在地下里，物质的骗局，匆匆的蚂蚁，没有文化的人不伤心。<br>———— 新裤子乐队《没有理想的人不伤心》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令总结</title>
      <link href="/2019/04/06/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2019/04/06/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>内容不定期更新</p></blockquote><h2 id="自己常用的-git-alias-可以在命令行中更好的显示-log-信息"><a href="#自己常用的-git-alias-可以在命令行中更好的显示-log-信息" class="headerlink" title="自己常用的 git alias 可以在命令行中更好的显示 log 信息"></a>自己常用的 git alias 可以在命令行中更好的显示 log 信息</h2><pre class=" language-shell"><code class="language-shell">alias gl="git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit"alias gll="git log --graph --abbrev-commit --decorate --all --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(dim white) - %an%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n %C(white)%s%C(reset)'"</code></pre><h2 id="1-git-commit-–amend"><a href="#1-git-commit-–amend" class="headerlink" title="1. git commit –amend"></a>1. git commit –amend</h2><pre class=" language-git"><code class="language-git">git commit --amend</code></pre><blockquote><p>解释：当第一次 commit 之后，发现没有修改正确，但是又不想在 git log 中出现两次提交记录，那么在第二次修改后，可以使用 git commit –amend 命令进行修改提交。此时提交成功后就只有一条 commit 记录了。</p></blockquote><h2 id="2-gitignore-生效"><a href="#2-gitignore-生效" class="headerlink" title="2. gitignore 生效"></a>2. gitignore 生效</h2><blockquote><p>解释: .gitignore 文件是忽略 git 项目中不需要提交的内容的配置文件。但是当某次提交的时候把不需要的内容提交到 git 版本控制中了之后。再想修改 .gitignore 文件来忽略那个文件的话是不会生效的。需要先想文件在 git 缓存中删除，然后在进行提交。就可以了。（下面是操作步骤）</p></blockquote><pre class=" language-git"><code class="language-git">git rm -r --cached .   //如何是目录的话，增加 -r 参数git add .git commit -m <span class="token string">'fix ignore'</span>//删除指定文件的缓存git rm --cached xx.html</code></pre><h2 id="3-git-reset-–soft-hard-hash"><a href="#3-git-reset-–soft-hard-hash" class="headerlink" title="3. git reset –soft/hard  hash*"></a>3. git reset –soft/hard  <strong>hash*</strong></h2><pre class=" language-git"><code class="language-git">git reset --soft  **hash***git reset --hard  **hash***</code></pre><blockquote><p>解释：当执行 git commit 之后，想回到之前的版本，可以使用 git reset 进行版本回退。–sorf 参数的意思是，git log 撤销版本，但代码中的内容没有回退。 –hard 参数的意思是，git log 中的记录和 文件内容完全回退到选的的版本。（–hard 更常用）</p></blockquote><h2 id="4-git-stash"><a href="#4-git-stash" class="headerlink" title="4. git stash"></a>4. git stash</h2><pre class=" language-git"><code class="language-git">git stash           //将当前工作去内容进行暂存，然后就进行切换分支或其他的操作了git stash list      //查看当前已经暂存的记录列表git stash pop       //将当前暂存内容回复到工作区并删除暂存记录列表中的内容git stash apply     //将当前暂存内容回复到工作区，不删除记录</code></pre><h2 id="5-git-rebase-变基"><a href="#5-git-rebase-变基" class="headerlink" title="5. git rebase (变基)"></a>5. git rebase (变基)</h2><blockquote><p>解释：当在两个分支进行操作的时候，一般我们使用 merge 将两个分支进行合并，但是这样会产生一个新的提交，并且另一个分支的提交记录在当前分支是不存在的。为了解决这个问题，可以使用 rebase。</p></blockquote><pre class=" language-git"><code class="language-git">//前提：master 分支和 new-feature 分支都进行了多次提交git checkout new-feature        //首先切换到新分支git rebase master               //将 master 分支的提交记录添加到当前分支git checkout master             //切换回 master 分支git merge new-feature           //将 new-feature 分支合并入master，此时 master 分支中就有了 new-feature 分支的提交记录，但是不会产生新的提交记录。此命令可以使提交历史更为整洁。</code></pre>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用frp搭建本地微信开发环境</title>
      <link href="/2019/03/08/%E4%BD%BF%E7%94%A8frp%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2019/03/08/%E4%BD%BF%E7%94%A8frp%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>2019-3-10</strong> 更新记录</p></blockquote><p>再使用 TP5 进行开发的时候需要注意一下几点</p><ol><li>关闭 trace 调试模式。</li><li>在使用路由的时候尽量确定对应接口请求的类型，如果不知道类型建议使用 <strong>Route::any()</strong>;</li></ol><p><em>可以使用 <a href="http://www.fangbei.org/tool/message" target="_blank" rel="noopener">微信消息测试工具</a>进行测试</em>。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>之前在做相关微信开发时，因为需要验证公网可以访问的到的域名，所以总是将代码推到线上服务器进行相关的测试。每次有些小改动也要进本地代码推送到服务器，服务器拉取最新代码这种重复性的操作，感觉十分繁琐，一直想找一个简单方便的方式进行微信本地环境的开发。😓 无奈之前自己太懒了……总是拖。最近几天好好研究了下特此记录下来。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>一台公网可以访问的服务器（或使用海外服务器）。</li><li>一个已经备案的域名。</li><li>内网穿透工具 <a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">frp</a></li></ol><h2 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h2><h3 id="下载-frp"><a href="#下载-frp" class="headerlink" title="下载 frp"></a>下载 frp</h3><p>下载对应系统的 <a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">frp</a> 包。因为我的公网服务器是 centOS6-x64 所以下载了 <code>frp_0.24.1_linux_amd64.tar.gz</code> 包。</p><h3 id="配置-frp-服务端"><a href="#配置-frp-服务端" class="headerlink" title="配置 frp 服务端"></a>配置 frp 服务端</h3><ol><li>在服务器上解压下载好的 frp 包。</li></ol><pre class=" language-bash"><code class="language-bash"> <span class="token function">tar</span> zxvf frp_0.24.1_linux_amd64.tar.gz</code></pre><ol start="2"><li><p>进入解压好的目录，编辑 frp 服务器端配置文件 <strong>frps.ini</strong>。</p><pre class=" language-ini"><code class="language-ini"><span class="token selector">[common]</span><span class="token constant">bind_port</span> <span class="token attr-value"><span class="token punctuation">=</span> 7000             #frp 绑定的端口</span><span class="token constant">vhost_http_port</span> <span class="token attr-value"><span class="token punctuation">=</span> 8000       #http 访问端口</span></code></pre><ol start="3"><li>启动服务端 frp</li></ol><pre class=" language-bash"><code class="language-bash">./frps -c ./frps.ini</code></pre></li></ol><h2 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h2><p>在域名服务商配置域名解析，将域名解析到上面的服务器 ip 地址上。</p><h2 id="配置-nginx-反向代理进行-frp-端口的转发"><a href="#配置-nginx-反向代理进行-frp-端口的转发" class="headerlink" title="配置 nginx 反向代理进行 frp 端口的转发"></a>配置 nginx 反向代理进行 frp 端口的转发</h2><ol><li>配置 nginx </li></ol><pre class=" language-nginx"><code class="language-nginx"><span class="token keyword">server</span> <span class="token punctuation">{</span>    <span class="token keyword">listen</span> <span class="token number">80</span><span class="token punctuation">;</span>    <span class="token keyword">server_name</span> wx<span class="token punctuation">.</span>domain<span class="token punctuation">.</span>com<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 绑定域名</span>    <span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">{</span>        <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token punctuation">:</span><span class="token number">8000</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 转发至本机8000,即在frps.ini中配置>的vhost_http_port</span>        <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Real<span class="token operator">-</span>IP <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> Host <span class="token variable">$host</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Forwarded<span class="token operator">-</span>For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol start="2"><li>重启 nginx</li></ol><h2 id="本地端配置"><a href="#本地端配置" class="headerlink" title="本地端配置"></a>本地端配置</h2><blockquote><p> 本地使用的是 vagrant 虚拟机。使用的同样是 centOS6-x64。在配置 frp 客户端之前需要将项目代码在 nginx 中正确配置，指定的域名就是上面解析的域名。</p></blockquote><ol><li>根据本地系统环境下载对应的  <a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">frp</a> 包。</li><li><p>编辑 frp 客户端配置文件 <strong>frpc.ini</strong>。</p><pre class=" language-ini"><code class="language-ini"><span class="token selector">[common]</span><span class="token constant">server_addr</span> <span class="token attr-value"><span class="token punctuation">=</span> x.x.x.x     #frps 所在的服务器的 IP</span><span class="token constant">server_port</span> <span class="token attr-value"><span class="token punctuation">=</span> 7000        #frps 绑定的端口</span><span class="token constant">use_encryption</span> <span class="token attr-value"><span class="token punctuation">=</span> true     #将 frpc 与 frps 之间的通信内容加密传输，将会有效防止流量被拦截。 </span><span class="token constant">use_compression</span> <span class="token attr-value"><span class="token punctuation">=</span> true     # 对传输内容进行压缩，可以有效减小 frpc 与 frps 之间的网络流量，加快流量转发速度，但是会额外消耗一些 cpu 资源。</span><span class="token selector">[web]</span><span class="token constant">type</span> <span class="token attr-value"><span class="token punctuation">=</span> http</span><span class="token constant">local_port</span> <span class="token attr-value"><span class="token punctuation">=</span> 80   #为本地机器上 web 服务对应的端口</span><span class="token constant">custom_domains</span> <span class="token attr-value"><span class="token punctuation">=</span> wx.domain.com   #上一步中解析好的域名</span></code></pre></li></ol><ol start="3"><li>启动 frp 客户端<pre class=" language-bash"><code class="language-bash">./frpc -c ./frpc.ini</code></pre></li></ol><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>如果一切正常那么现在随便找一台设备，访问刚才的域名就可以访问到本地的项目了。</p>]]></content>
      
      
      <categories>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境 </tag>
            
            <tag> frp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 各种锁的理解</title>
      <link href="/2019/02/14/%E5%90%84%E7%A7%8D%E9%94%81%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2019/02/14/%E5%90%84%E7%A7%8D%E9%94%81%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>之前总是听说 MySQL 中的锁，一直没有具体的看过，晚上抽了空看了一点就先记录了下来，后面有机会在补充。</p></blockquote><h2 id="为什么需要锁"><a href="#为什么需要锁" class="headerlink" title="为什么需要锁"></a>为什么需要锁</h2><p>因为数据库是一个多用户共享的资源，也就是任何人都可以访问数据。当有一个商品表库存为1，当一个用户购买该商品的时候，首先需要查询商品的库存。如果一个人请求是没有任何问题的。但是当两个用户同时购买该商品的时候由于时间比较接近，当第一个用户查询完商品还未进行更新库存的时候，第二个用户就进来了，由于库存还没有更新，所以该用户也可以下单成功。最终将导致库存为-1，破幻了数据的一致性。为了解决这问题才有个锁的概念。</p><h2 id="有哪些锁"><a href="#有哪些锁" class="headerlink" title="有哪些锁"></a>有哪些锁</h2><ul><li>锁的类型<ul><li>读锁</li><li>写锁</li></ul></li><li>锁的粒度<ul><li>行锁</li><li>表锁</li></ul></li><li>持有锁的时间<ul><li>临时锁</li><li>持续锁</li></ul></li></ul><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><blockquote><p>说到锁那么接下来就需要了解隔离级别，了解隔离级别就需要了解数据库的四要素。</p></blockquote><h3 id="数据库四要素（ACID）"><a href="#数据库四要素（ACID）" class="headerlink" title="数据库四要素（ACID）"></a>数据库四要素（ACID）</h3><ul><li>原子性（Atomicity）：要么全部完成，要么全 <strong>不</strong> 完成。</li><li>一致性（Consistency）：一个事务单元提交后才可以被其他事务查看到。</li><li>隔离性（Isolation）：并发事务之间不相互影响。<em>设立了不同的隔离级别，通过适度破坏一致性来提高性能</em></li><li>持久性（Durability）：事物提交之后即持久化到磁盘中不会丢失。</li></ul><p><em><strong>锁只是实现隔离级别的几种方式之一，除了锁，实现并发问题的方式还有时间戳，多版本控制等等，这些也可以称为无锁的并发控制。</strong></em></p><h3 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h3><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> @<span class="token variable">@tx_isolation</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">#查询当前隔离级别</span><span class="token keyword">select</span> @<span class="token variable">@global.tx_isolation</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">#查询全局隔离级别</span><span class="token keyword">set</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation level</span> <span class="token keyword">read</span> <span class="token keyword">uncommitted</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">#设置当前隔离级别为 RU</span><span class="token keyword">set</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation level</span> <span class="token keyword">read</span> <span class="token keyword">committed</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">#设置当前隔离级别为 RC</span><span class="token keyword">set</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation level</span> <span class="token keyword">repeatable</span> <span class="token keyword">read</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">#设置当前隔离级别为 RR</span><span class="token keyword">set</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation level</span> <span class="token keyword">serializable</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">#设置当前隔离级别为 RS</span></code></pre><ul><li>读未提交（Read Uncommitted）：事务的读不阻塞其他事务的读和写，事务的写只阻塞其他事务的写，但不阻塞读。<strong>通过对写操作加“持续 X 锁”，对读操作不加锁实现。</strong></li><li>读已提交（Read Committed）：事务的读不阻塞其他事务的读和写，事务的写也会阻塞其他事务的读和写。<strong>通过对写操作加“持续 X 锁”，对读操作加“临时 S 锁”实现。</strong></li><li>可重复读（Repeatable Read）：事务的读会阻塞其他事务的写，但不阻塞读。事务的写会阻塞其他事务的读和写。<strong>通过对写操作加“持续 X 锁”，对读操作加“持续 S 锁”实现。</strong></li><li>序列化（Serializable）：最安全的一种级别，不会出现脏读、不可重复读、幻读问题。但是可能会导致大量的超时现象和锁竞争。<strong>使用的是表级锁</strong></li></ul><h3 id="可能产生的问题"><a href="#可能产生的问题" class="headerlink" title="可能产生的问题"></a>可能产生的问题</h3><p><img src="http://static.xiangdangnian.net.cn/blog/WX20190219-093153@2x.png" alt="WX20190219-093153@2x.png"></p><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>公司发工资，打了10000万到我的账户，但是该事务没有提交。这时我正好查看账户，发现10000元已经到账，非常开心。可以公司这时又发现发错了，于是回滚事务，修改金额为5000，然后提交事务。最终我实际得到的工资只有5000，空欢喜一场。</p><blockquote><p>这就是脏读，两个并发的事务，其中一个读取到了另一个没有提交的数据。</p></blockquote><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>拿着刚发的工资去买本书看看，付钱时系统读到我卡里有5000元，然而此时女友也拿着我的卡在消费，并花完了卡里的钱，并在我之前提交了事务，当我这边进行扣款的时候系统发现卡里没有钱了，提示扣款失败。我就十分纳闷，明明有钱啊，怎么。。。</p><blockquote><p> 这就是不可重复读，两个并发事务，在一个事务中读取到另一个事务中提交了的结果，第一事务在第二个事务提交前和提交后查看到的结果不一致。（主要是针对更新和删除操作）<strong>当隔离级别设置为Read committed时，避免了脏读，但是可能会造成不可重复读。</strong></p></blockquote><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>我又一个计划任务表，当前为空的。在第一个事务中我查看所有任务显示为空。这时女友在另一个事务增加了一条任务“早上起床做早饭”，并提交了事务。这是我又查看了一下所有任务发现还是空的，我就准备加一个任务“早上起床做早饭”，可是这时却提示我错误。我就纳了闷了，明明没有数据啊，怎么不让我加呢？难道出现了幻觉？</p><blockquote><p>这就是幻读。第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。（主要针对新增操作）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现负载均衡</title>
      <link href="/2019/01/27/%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/2019/01/27/%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="http://static.xiangdangnian.net.cn/blog/2019-01-273.56.02.png" alt="架构图"></p><blockquote><p>简介： 用户访问负载均衡服务器，负载均衡服务器将相应的请求转发至应用服务器APP1或APP2。当前其中一台应用服务器down调的时候，负载均衡服务器将会把请求转发至另一台正常的服务器上。</p></blockquote><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="安装负载均衡服务器"><a href="#安装负载均衡服务器" class="headerlink" title="安装负载均衡服务器"></a>安装负载均衡服务器</h3><h4 id="安装并启动-nginx-或使用-jellybool-的-sh-脚本"><a href="#安装并启动-nginx-或使用-jellybool-的-sh-脚本" class="headerlink" title="安装并启动 nginx (或使用 jellybool 的 sh 脚本)"></a>安装并启动 nginx (<a href="https://github.com/JellyBool/laravel-server-script/blob/master/laravel-nginx-proxy-server.sh" target="_blank" rel="noopener">或使用 jellybool 的 sh 脚本</a>)</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> update<span class="token function">sudo</span> LC_ALL<span class="token operator">=</span>en_US.UTF-8 add-apt-repository ppa:nginx/development -y<span class="token function">sudo</span> <span class="token function">apt-get</span> update<span class="token function">sudo</span> <span class="token function">apt-get</span> -y <span class="token function">install</span> nginx<span class="token function">sudo</span> <span class="token function">cp</span> /etc/nginx/sites-available/default /etc/nginx/sites-available/default.bak<span class="token function">sudo</span> <span class="token function">service</span> nginx start</code></pre><h4 id="配置-nginx-服务器为负载均衡服务器"><a href="#配置-nginx-服务器为负载均衡服务器" class="headerlink" title="配置 nginx 服务器为负载均衡服务器"></a>配置 nginx 服务器为负载均衡服务器</h4><pre class=" language-nginx"><code class="language-nginx"><span class="token keyword">upstream</span> backend <span class="token punctuation">{</span>    <span class="token keyword">server</span> pravite<span class="token operator">-</span>ip<span class="token operator">-</span>address<span class="token number">-1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">#应用服务器ip地址</span>    <span class="token keyword">server</span> pravite<span class="token operator">-</span>ip<span class="token operator">-</span>address<span class="token number">-2</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">#应用服务器ip地址</span><span class="token punctuation">}</span><span class="token keyword">server</span> <span class="token punctuation">{</span>    <span class="token keyword">listen</span> <span class="token number">80</span> default_server<span class="token punctuation">;</span>    <span class="token keyword">listen</span> <span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token number">80</span> default_server<span class="token punctuation">;</span>    <span class="token keyword">server_name</span> nuli<span class="token punctuation">.</span>io www<span class="token punctuation">.</span>nuli<span class="token punctuation">.</span>io<span class="token punctuation">;</span>    <span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">{</span>        <span class="token keyword">add_header</span> X<span class="token operator">-</span>Content<span class="token operator">-</span>Type<span class="token operator">-</span>Options nosniff<span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Scheme <span class="token variable">$scheme</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Real<span class="token operator">-</span>IP <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Forwarded<span class="token operator">-</span>For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> Host <span class="token variable">$http_host</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>NginX<span class="token operator">-</span><span class="token keyword">Proxy</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_hide_header</span> X<span class="token operator">-</span>Powered<span class="token operator">-</span>By<span class="token punctuation">;</span>        <span class="token keyword">proxy_hide_header</span> Vary<span class="token punctuation">;</span>        <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>backend<span class="token punctuation">;</span>        <span class="token keyword">proxy_redirect</span> off<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="检测-nginx-配置并重启-nginx-服务"><a href="#检测-nginx-配置并重启-nginx-服务" class="headerlink" title="检测 nginx 配置并重启 nginx 服务"></a>检测 nginx 配置并重启 nginx 服务</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> nginx -t<span class="token function">sudo</span> <span class="token function">service</span> nginx reload</code></pre><h3 id="安装应用服务器-APP1"><a href="#安装应用服务器-APP1" class="headerlink" title="安装应用服务器 APP1"></a>安装应用服务器 APP1</h3><h4 id="安装-nginx-和-php-以及-php-扩展-或使用-jellybool-的-sh-脚本"><a href="#安装-nginx-和-php-以及-php-扩展-或使用-jellybool-的-sh-脚本" class="headerlink" title="安装 nginx 和 php 以及 php 扩展  或使用 jellybool 的 sh 脚本"></a>安装 nginx 和 php 以及 php 扩展  <a href="https://github.com/JellyBool/laravel-server-script/blob/master/laravel-app-server.sh" target="_blank" rel="noopener">或使用 jellybool 的 sh 脚本</a></h4><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> update<span class="token function">sudo</span> <span class="token function">apt-get</span> -y <span class="token function">install</span> zsh <span class="token function">htop</span> <span class="token function">zip</span> unzip composer<span class="token function">sudo</span> LC_ALL<span class="token operator">=</span>en_US.UTF-8 add-apt-repository ppa:nginx/development -y<span class="token function">sudo</span> <span class="token function">apt-get</span> update<span class="token function">sudo</span> <span class="token function">apt-get</span> -y <span class="token function">install</span> nginx<span class="token function">sudo</span> <span class="token function">service</span> nginx start<span class="token function">sudo</span> LC_ALL<span class="token operator">=</span>en_US.UTF-8 add-apt-repository ppa:ondrej/php -y<span class="token function">sudo</span> <span class="token function">apt-get</span> update<span class="token function">sudo</span> <span class="token function">apt-get</span> -y <span class="token function">install</span> php7.2<span class="token function">sudo</span> <span class="token function">apt-get</span> -y <span class="token function">install</span> php7.2-mysql<span class="token function">sudo</span> <span class="token function">apt-get</span> -y <span class="token function">install</span> php7.2-fpm<span class="token function">sudo</span> <span class="token function">apt-get</span> -y <span class="token function">install</span> php7.2-curl php7.2-xml php7.2-json php7.2-gd php7.2-mbstring php7.2-bcmath<span class="token function">sudo</span> <span class="token function">service</span> php7.2-fpm restart<span class="token function">sudo</span> <span class="token function">cp</span> /etc/nginx/sites-available/default /etc/nginx/sites-available/default.bak</code></pre><h3 id="安装应用服务器-APP2-同-APP1"><a href="#安装应用服务器-APP2-同-APP1" class="headerlink" title="安装应用服务器 APP2 (同 APP1)"></a>安装应用服务器 APP2 (同 APP1)</h3><h3 id="测试负载均衡"><a href="#测试负载均衡" class="headerlink" title="测试负载均衡"></a>测试负载均衡</h3><ol><li>在 APP1 服务器上的 <code>/var/www/html</code> 目录下将 <code>index.html</code>文件内容更改为 APP1。</li><li>在 APP2 服务器上的 <code>/var/www/html</code> 目录下将 <code>index.html</code>文件内容更改为 APP2。</li><li>访问负载均衡服务器 ip 地址或配置的域名。此时页面将交替显示 APP1 和 APP2 。~~~成功。</li></ol><h3 id="使用-Envoy-将-Laravel-项目同时部署在所有负载均衡的机器上"><a href="#使用-Envoy-将-Laravel-项目同时部署在所有负载均衡的机器上" class="headerlink" title="使用 Envoy 将 Laravel 项目同时部署在所有负载均衡的机器上"></a>使用 Envoy 将 Laravel 项目同时部署在所有负载均衡的机器上</h3><ol><li>在本机上创建 Laravel 项目</li><li>将项目提交到 coding 或 github 上</li><li>配置 coding 或 github 的ssh （可选）</li><li>使用 ssh 或 https 的方式将项目部署到 APP1 和 APP2 服务器上</li><li>配置两台服务器的 .env 文件 <strong><strong>保证两台服务器的 APP_KEY 要一直</strong></strong></li><li>测试——<em>访问负载均衡服务器可以看到 Laravel 欢迎语</em></li><li>在本机中的 Laravel 项目中安装 Envoy 扩展  <a href="https://laravel-china.org/docs/laravel/5.7/envoy/2307" target="_blank" rel="noopener">参考文档</a></li><li>在项目根目录新增 <code>Envoy.blade.php</code> 文件并在文件中增加如下内容。「需要注意的是：本机可以通过 ssh 的方式访问对应的服务器」</li></ol><pre class=" language-php"><code class="language-php">@<span class="token function">servers</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'web-1'</span>  <span class="token operator">=</span><span class="token operator">></span>  <span class="token string">'ssh root@192.168.3.11'</span><span class="token punctuation">,</span> <span class="token string">'web-2'</span>  <span class="token operator">=</span><span class="token operator">></span>  <span class="token string">'ssh root@192.168.3.11'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>@<span class="token function">task</span><span class="token punctuation">(</span><span class="token string">'deploy'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'on'</span>  <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token string">'web-1'</span><span class="token punctuation">,</span> <span class="token string">'web-2'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'parallel'</span>  <span class="token operator">=</span><span class="token operator">></span>  <span class="token boolean">true</span><span class="token punctuation">]</span><span class="token punctuation">)</span>cd <span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>www<span class="token operator">/</span>laravel<span class="token operator">-</span>deploy   sudo git pull origin master@endtask</code></pre><ol start="9"><li>运行部署命令 <code>envoy run deploy</code>,如果输出内容没有错误的话，就表示部署成功，就可以在负载均衡服务器上进行查看了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> nginx </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CGI, Fast-CGI，PHP-CGI，PHP-FPM 几个概念的总结</title>
      <link href="/2019/01/24/cgi-fast-cgi-php-cgi-php-fpm%E7%90%86%E8%A7%A3-md/"/>
      <url>/2019/01/24/cgi-fast-cgi-php-cgi-php-fpm%E7%90%86%E8%A7%A3-md/</url>
      
        <content type="html"><![CDATA[<blockquote><p>2020-2-6 更新</p></blockquote><p><strong> 最近又看到一篇<a href="https://segmentfault.com/q/1010000000256516" target="_blank" rel="noopener">文章</a>，讲解的非常到位，在更正一下之前的结论  </strong></p><ol><li><p>cgi、fast-cgi 都是协议，规定了 web server 需要传递那些数据给 php 解释器。他们的区别是 cgi 每次都需要加载配置文件来初始化，而 fast-cgi 会先启一个master，解析配置文件，初始化执行环境，然后再启动多个worker。当请求过来时，master会传递给一个worker，然后立即可以接受下一个请求。这样就避免了重复的劳动，效率自然是高。</p></li><li><p>php-cgi 相当于 php 的一个解释器是一个具体的程序，也就是系统中的进程。而 php-fpm 是一个实现了 fast-cgi 的具体程序，用来管理 php-cgi 进程。</p></li></ol><hr><blockquote><p>2019-6-27 更新</p></blockquote><p><strong> 最近又看到了类似的文章，发现之前记录的好像是不太对。现在也不知道哪个是正确的，就都先记下来吧。</strong> </p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol><li>CGI、FastCGI 只是PHP的的运行方式。其他的还有APACHE2HANDLER、CLI 方式。</li><li>PHP-FPM（FastCGI Process Manager） 只是 FastCGI 的进程管理器。</li><li>PHP-CGI 只是 Fast-CGI 的子进程。</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.jb51.net/article/62554.htm" target="_blank" rel="noopener">php 的4种常见运行方式</a></p><hr><blockquote><p>在开始学php的时候有几个概念一直没有弄明白，最近查了些资料，特此补充记录一下，以防忘记。有不对的地方还请高手指点。</p></blockquote><h2 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h2><ul><li>CGI：WEB 服务器与 WEB 应用程序之间交换数据的一种协议。</li><li>FastCGI：同 CGI 一样，也是一种协议，只是在效率上比 CGI 好一些。</li><li>PHP-CGI：fastCGI 协议的一种实现。(也就是 php 可执行目录下的php-cgi程序)。他有2个问题。<ul><li>更改配置文件后无法平滑重启。</li><li>无法动态调整进制多少。</li></ul></li><li>spawn-fcgi：解决了 php-cgi 出现的问题。但器仅仅是一个进程管理器。</li><li>PHP-FPM：实现了 Fast-CGI 协议并且之前平滑重启，同时还带有进程管理功能。</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.ietf.org/rfc/rfc3875" target="_blank" rel="noopener">CGI 协议内容</a></p><p><a href="http://andylin02.iteye.com/blog/648412" target="_blank" rel="noopener">Fast-CGI 协议内容</a></p><p><a href="http://yongxiong.leanote.com/post/%E4%BB%8ECGI%E5%88%B0FastCGI%E5%88%B0PHP-FPM" target="_blank" rel="noopener">从CGI到FastCGI到PHP-FPM</a></p><p><a href="https://www.awaimai.com/371.html" target="_blank" rel="noopener">CGI、FastCGI和PHP-FPM关系图解</a></p>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇文章</title>
      <link href="/2019/01/21/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2019/01/21/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="我的第一篇文章"><a href="#我的第一篇文章" class="headerlink" title="我的第一篇文章"></a>我的第一篇文章</h1><blockquote><p>这是我的第一篇文章，主要记录一下hexo博客的建立和使用方法。</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/HarleyWang93/blog/issues/1" target="_blank" rel="noopener">搭建参考</a></p><p><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">主题配置</a></p><h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><ol><li>需要安装git和Node.js</li><li>注册Github账号</li></ol><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><ol><li><p>使用npm全局安装hexo</p><pre class=" language-yaml"><code class="language-yaml">sudo npm install <span class="token punctuation">-</span>g hexo<span class="token punctuation">-</span>cli</code></pre></li><li><p>使用hexo init 初始化项目</p><pre class=" language-yaml"><code class="language-yaml">hexo init blog</code></pre></li><li><p>使用hexo s查看状态(默认访问该地址<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000 </a>)</p><pre class=" language-yaml"><code class="language-yaml">hexo s</code></pre></li></ol><h3 id="关联Github"><a href="#关联Github" class="headerlink" title="关联Github"></a>关联Github</h3><ol><li>创建仓库</li><li>开启Github Pages</li><li>选择分支</li></ol><h3 id="修改全局配置-注意：每个冒号后面都有个空格"><a href="#修改全局配置-注意：每个冒号后面都有个空格" class="headerlink" title="修改全局配置(注意：每个冒号后面都有个空格)"></a>修改全局配置(注意：每个冒号后面都有个空格)</h3><p>在项目中找到_config.yml文件，在文件最后添加如下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span> git    <span class="token key atrule">repository</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//github.com/xxx/xxx.github.io.git  <span class="token key atrule">branch</span><span class="token punctuation">:</span> master</code></pre><h3 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a>生成静态页面</h3><ol><li>执行生成静态文件命令</li></ol><pre class=" language-yaml"><code class="language-yaml">hexo g</code></pre><ol start="2"><li>安装git上传插件</li></ol><pre class=" language-yaml"><code class="language-yaml">npm install hexo<span class="token punctuation">-</span>deployer<span class="token punctuation">-</span>git <span class="token punctuation">-</span><span class="token punctuation">-</span>save</code></pre><ol start="3"><li>执行上传静态文件命令</li></ol><pre class=" language-yaml"><code class="language-yaml">hexo d</code></pre><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><pre><code>hexo new &quot;文章标题&quot;         //新建文章hexo new page &quot;页面名&quot;      //新建页面hexo g                     //生成静态文件至public目录hexo server                //开启本地访问hexo deploy                //部署到github</code></pre><h2 id="主题使用"><a href="#主题使用" class="headerlink" title="主题使用"></a>主题使用</h2><blockquote><p>具体详细内容查看项目链接 <a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">hexo-theme-matery</a></p></blockquote><h3 id="文章头部示例"><a href="#文章头部示例" class="headerlink" title="文章头部示例"></a>文章头部示例</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-07 09:25:00</span><span class="token key atrule">author</span><span class="token punctuation">:</span> 赵奇<span class="token key atrule">img</span><span class="token punctuation">:</span> /source/images/xxx.jpg <span class="token comment" spellcheck="true"># 或者:http://xxx.com/xxx.jpg</span><span class="token key atrule">top</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true"># 如果top值为true，则会是首页推荐文章</span><span class="token comment" spellcheck="true"># 如果要对文章设置阅读验证密码的话，就可以在设置password的值，该值必须是用SHA256加密后的密码，防止被他人识破</span><span class="token key atrule">password</span><span class="token punctuation">:</span> 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92<span class="token comment" spellcheck="true"># 本文章是否开启mathjax，且需要在主题的_config.yml文件中也需要开启才行</span><span class="token key atrule">mathjax</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">categories</span><span class="token punctuation">:</span> Markdown<span class="token key atrule">tags</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> Typora  <span class="token punctuation">-</span> Markdown<span class="token punctuation">---</span></code></pre><blockquote><ol><li>如果img属性不填写的话，文章特色图会根据文章标题的hashcode的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。</li><li>date的值尽量保证每篇文章是唯一的，因为本主题中Gitalk和Gitment识别id是通过date的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在Front-matter中设置采用了SHA256加密的password的值，还需要在主题的_config.yml中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
