<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>开源艺术二维码在线生成器工具</title>
      <link href="/2020/08/19/%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"/>
      <url>/2020/08/19/%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<h1 id="开源艺术二维码在线生成器工具"><a href="#开源艺术二维码在线生成器工具" class="headerlink" title="开源艺术二维码在线生成器工具"></a>开源艺术二维码在线生成器工具</h1><p><img src="http://static.xiangdangnian.net.cn/I75nBYMS8XAVlLxEzvDiFT4gfotU1dQG.jpg" alt="艺术二维码"></p><blockquote><p>上图中的二维码大家觉得怎么样？是不是非常漂亮，有没有眼前一亮呢？</p></blockquote><p>今天给大家推荐一款在线生成各种艺术二维码的工具。</p><p>首先把工具的地址告诉大家：<a href="https://qrbtf.com" target="_blank" rel="noopener">https://qrbtf.com</a></p><p>怎么使用呢？</p><p>非常简单，一共就四步</p><ol><li>把需要生成二维码的链接复制进去</li><li>选择对应的模板</li><li>填写相应的参数</li><li>下载</li></ol><p>是不是非常简单，大家赶紧试试吧。</p><p>另外，QRBTF 相比绝大多数“在线二维码制作器”的项目，最大的特色在于它完全是使用 Javascript 前端生成的，有着丰富的参数化样式设置。它不仅能生成矢量的 SVG 格式图片，甚至也提供了 API，适合开发者、网站站长在各类 WEB 项目中调用实现 二维码生成。</p><p>另外，因为 QRBTF 是开源的，所以如果你有自己的服务器，也可以自建一个属于自己的二维码制作网站。而有意学习前端知识和 Javascript 开发的同学，也可以借这个项目的代码深入了解。</p>]]></content>
      
      
      <categories>
          
          <category> 应用推荐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 学习笔记（四）</title>
      <link href="/2020/08/19/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/"/>
      <url>/2020/08/19/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="docker-网络"><a href="#docker-网络" class="headerlink" title="docker 网络"></a>docker 网络</h1><blockquote><p>通过前面的学习，我们已经可以通过 image 来创建相关的容器，例如：创建一个 mysql 容器，nginx 容器、php-fpm 容器。但是我们想要使用这些容器作为开发或者生产的环境还缺少关键的一步，那就是容器间的通信。这一集我们来学习容器间的网络通信</p></blockquote><h2 id="容器间网络互连"><a href="#容器间网络互连" class="headerlink" title="容器间网络互连"></a>容器间网络互连</h2><p>Docker 默认提供了三种网络模式、分别是bridge、host、none。可以使用如下命令查看</p><pre class=" language-bash"><code class="language-bash">$ docker network <span class="token function">ls</span>NETWORK ID          NAME                DRIVER              SCOPEb7ad6ddfa6be        bridge              bridge              local8eceb8218986        host                host                local0cedda606a66        none                null                local</code></pre><h3 id="bridge-桥接模式"><a href="#bridge-桥接模式" class="headerlink" title="bridge 桥接模式"></a>bridge 桥接模式</h3><p>原理：在主机上虚拟出一个docker0 的<a href="https://baike.baidu.com/item/%E7%BD%91%E6%A1%A5" target="_blank" rel="noopener">网桥</a>，默认创建的容器都会虚拟出网卡和这个网桥连接，容器的 ip 地址从 172.17.0.0/16 地址段生成。</p><p><img src="http://static.xiangdangnian.net.cn/16828bdd2287ee1c.png" alt="网络连接示意图"></p><p><img src="http://static.xiangdangnian.net.cn/FyD8K1folZQ95m6XHPLwTkOzuVJWpaIn.png" alt="docker0"></p><blockquote><p>由于在 mac 和 windows 系统上，docker 的运行方式不太一样（在win、mac 上安装 docker，实际上是安装了一个 docker 虚拟机，而我们创建的容器都是跑在 docker 虚拟机中的）。</p></blockquote><p>mac系统下进入docker 虚拟机 命令</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">screen</span> ~/Library/Containers/com.docker.docker/Data/vms/0/tty</code></pre><p>docker 版本小于18.06 则使用如下命令</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">screen</span> ~/Library/Containers/com.docker.docker/Data/com.docker.driver.amd64-linux/tty</code></pre><h4 id="测试桥接模式-提示符为主机、-提示符为容器内"><a href="#测试桥接模式-提示符为主机、-提示符为容器内" class="headerlink" title="测试桥接模式($ 提示符为主机、# 提示符为容器内)"></a>测试桥接模式($ 提示符为主机、# 提示符为容器内)</h4><p>使用 busybox 镜像进行测试。该镜像非常小并且安装了ping、ifconfig等实用工具，非常适合测试。</p><pre class=" language-bash"><code class="language-bash">$ docker run --name box1 -it --rm busybox sh// 测试网络连通/<span class="token comment" spellcheck="true"># ping www.baidu.com  </span>PING www.baidu.com <span class="token punctuation">(</span>180.97.34.96<span class="token punctuation">)</span>: 56 data bytes64 bytes from 180.97.34.96: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>45 time<span class="token operator">=</span>10.489 ms64 bytes from 180.97.34.96: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>45 time<span class="token operator">=</span>10.512 ms64 bytes from 180.97.34.96: seq<span class="token operator">=</span>2 ttl<span class="token operator">=</span>45 time<span class="token operator">=</span>10.424 ms64 bytes from 180.97.34.96: seq<span class="token operator">=</span>3 ttl<span class="token operator">=</span>45 time<span class="token operator">=</span>10.409 ms^C--- www.baidu.com <span class="token function">ping</span> statistics ---4 packets transmitted, 4 packets received, 0% packet lossround-trip min/avg/max <span class="token operator">=</span> 10.409/10.458/10.512 ms// 查看网卡 ip 地址/<span class="token comment" spellcheck="true"># ifconfig</span>eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:07          inet addr:172.17.0.7  Bcast:172.17.255.255  Mask:255.255.0.0          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:16 errors:0 dropped:0 overruns:0 frame:0          TX packets:8 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:0          RX bytes:1421 <span class="token punctuation">(</span>1.3 KiB<span class="token punctuation">)</span>  TX bytes:622 <span class="token punctuation">(</span>622.0 B<span class="token punctuation">)</span>// 退出容器。使用 Ctrl+P+Q 退出容器但是容器不会关闭// 查看 box1 容器的详细信息,只截取了部分内容$ docker inspect box1<span class="token keyword">.</span><span class="token keyword">.</span><span class="token keyword">.</span><span class="token string">"Networks"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>    <span class="token string">"bridge"</span>:<span class="token punctuation">{</span>        <span class="token string">"IPAMConfig"</span>:null,        <span class="token string">"Links"</span>:null,        <span class="token string">"Aliases"</span>:null,        <span class="token string">"NetworkID"</span><span class="token keyword">:</span><span class="token string">"b7ad6ddfa6beac6b0ebf87dcec3d7ee933478592f16d48b3c01b28cd6a48a7f9"</span>,        <span class="token string">"EndpointID"</span><span class="token keyword">:</span><span class="token string">"30eb2f7a0b5e4dbebe8a8f0522a01e105c65fe6a14d0a6ffe02120af009cff27"</span>,        <span class="token string">"Gateway"</span><span class="token keyword">:</span><span class="token string">"172.17.0.1"</span>,        <span class="token string">"IPAddress"</span><span class="token keyword">:</span><span class="token string">"172.17.0.7"</span>,        <span class="token string">"IPPrefixLen"</span>:16,        <span class="token string">"IPv6Gateway"</span><span class="token keyword">:</span><span class="token string">""</span>,        <span class="token string">"GlobalIPv6Address"</span><span class="token keyword">:</span><span class="token string">""</span>,        <span class="token string">"GlobalIPv6PrefixLen"</span>:0,        <span class="token string">"MacAddress"</span><span class="token keyword">:</span><span class="token string">"02:42:ac:11:00:07"</span>,        <span class="token string">"DriverOpts"</span>:null    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">.</span><span class="token keyword">.</span><span class="token keyword">.</span></code></pre><p>通过上面的例子我们可以很直观的看到 box1 容器使用的是 bridge 模式，分配的 ip 地址为 172.17.0.7 并且可以访问互联网。</p><h3 id="Host-主机模式-提示符为主机、-提示符为容器内"><a href="#Host-主机模式-提示符为主机、-提示符为容器内" class="headerlink" title="Host 主机模式($ 提示符为主机、# 提示符为容器内)"></a>Host 主机模式($ 提示符为主机、# 提示符为容器内)</h3><p>原理：容器不会虚拟出自己的网卡，而是使用宿主机的IP。<br><img src="http://static.xiangdangnian.net.cn/16828bdd20dcb5be" alt="示意图"></p><pre class=" language-bash"><code class="language-bash">// 创建一个容器并加入 host 网络$ docker run --name box2 -it --network host busybox// 在容器中查看网卡 eth0<span class="token comment" spellcheck="true"># ifconfig eth0</span>eth0      Link encap:Ethernet  HWaddr FA:16:3E:F4:68:C0          inet addr:192.168.0.3  Bcast:192.168.0.255  Mask:255.255.255.0          inet6 addr: fe80::f816:3eff:fef4:68c0/64 Scope:Link          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:612175 errors:0 dropped:0 overruns:0 frame:0          TX packets:203387 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000          RX bytes:725999816 <span class="token punctuation">(</span>692.3 MiB<span class="token punctuation">)</span>  TX bytes:74349925 <span class="token punctuation">(</span>70.9 MiB<span class="token punctuation">)</span>// 测试网络连通/<span class="token comment" spellcheck="true"># ping www.baidu.com  </span>PING www.baidu.com <span class="token punctuation">(</span>180.97.34.96<span class="token punctuation">)</span>: 56 data bytes64 bytes from 180.97.34.96: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>45 time<span class="token operator">=</span>10.489 ms64 bytes from 180.97.34.96: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>45 time<span class="token operator">=</span>10.512 ms64 bytes from 180.97.34.96: seq<span class="token operator">=</span>2 ttl<span class="token operator">=</span>45 time<span class="token operator">=</span>10.424 ms64 bytes from 180.97.34.96: seq<span class="token operator">=</span>3 ttl<span class="token operator">=</span>45 time<span class="token operator">=</span>10.409 ms// 退出容器。使用 Ctrl+P+Q 退出容器但是容器不会关闭//在宿主机上查看网卡 eth0          $ <span class="token function">ifconfig</span> eth0eth0: flags<span class="token operator">=</span>4163<span class="token operator">&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class="token operator">></span>  mtu 1500        inet 192.168.0.3  netmask 255.255.255.0  broadcast 192.168.0.255        inet6 fe80::f816:3eff:fef4:68c0  prefixlen 64  scopeid 0x20<span class="token operator">&lt;</span>link<span class="token operator">></span>        ether fa:16:3e:f4:68:c0  txqueuelen 1000  <span class="token punctuation">(</span>Ethernet<span class="token punctuation">)</span>        RX packets 612230  bytes 726004260 <span class="token punctuation">(</span>726.0 MB<span class="token punctuation">)</span>        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 203435  bytes 74354859 <span class="token punctuation">(</span>74.3 MB<span class="token punctuation">)</span>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><p>通过上面的例子我们可以很直观的看到 box2 容器使用的是 host 模式，ip 地址和宿主机一致，也能访问外网。</p><h3 id="none-无网络模式"><a href="#none-无网络模式" class="headerlink" title="none 无网络模式"></a>none 无网络模式</h3><p>不给容器提供任何网络配置，只有lo 网络接口。需要我们自己为Docker容器添加网卡、配置IP等。<br><img src="http://static.xiangdangnian.net.cn/16828bdd222d2bbb.png" alt="示意图"></p><pre class=" language-bash"><code class="language-bash">$ docker run --name box3 -it --network none --rm  busybox<span class="token comment" spellcheck="true"># ifconfig</span>lo        Link encap:Local Loopback          inet addr:127.0.0.1  Mask:255.0.0.0          UP LOOPBACK RUNNING  MTU:65536  Metric:1          RX packets:0 errors:0 dropped:0 overruns:0 frame:0          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000          RX bytes:0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>  TX bytes:0 <span class="token punctuation">(</span>0.0 B<span class="token punctuation">)</span>$ docker inspect box3<span class="token keyword">.</span><span class="token keyword">.</span><span class="token keyword">.</span><span class="token string">"Networks"</span>:<span class="token punctuation">{</span>    <span class="token string">"none"</span>:<span class="token punctuation">{</span>        <span class="token string">"IPAMConfig"</span>:null,        <span class="token string">"Links"</span>:null,        <span class="token string">"Aliases"</span>:null,        <span class="token string">"NetworkID"</span><span class="token keyword">:</span><span class="token string">"0cedda606a66614ba025ff7a992cb0d405fb567ff8da240310b96fa59f5fe99a"</span>,        <span class="token string">"EndpointID"</span><span class="token keyword">:</span><span class="token string">"e4fd85c2629d2524928f34fb428305bf4cf2d99195ff5ce7d428a9cff14902c0"</span>,        <span class="token string">"Gateway"</span><span class="token keyword">:</span><span class="token string">""</span>,        <span class="token string">"IPAddress"</span><span class="token keyword">:</span><span class="token string">""</span>,        <span class="token string">"IPPrefixLen"</span>:0,        <span class="token string">"IPv6Gateway"</span><span class="token keyword">:</span><span class="token string">""</span>,        <span class="token string">"GlobalIPv6Address"</span><span class="token keyword">:</span><span class="token string">""</span>,        <span class="token string">"GlobalIPv6PrefixLen"</span>:0,        <span class="token string">"MacAddress"</span><span class="token keyword">:</span><span class="token string">""</span>,        <span class="token string">"DriverOpts"</span>:null    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">.</span><span class="token keyword">.</span><span class="token keyword">.</span></code></pre><p>通过上面的例子我们可以很直观的看到 box3 容器使用的是 none 模式，没有网卡，只有 lo 网络接口。</p><h2 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h2><blockquote><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 -P 或 -p 参数来指定端口映射。</p></blockquote><ol><li>当使用 -P(大写) 标记时，Docker 会随机映射一个 49000~49900 的端口到内部容器开放的网络端口。</li><li>-p 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort。</li></ol><p>创建一个 nginx 容器，使用 -P 随机产生一个端口号</p><pre class=" language-bash"><code class="language-bash">$ docker run --name <span class="token function">test</span> -P -d  nginx769acc819c0dc26848b93c3e39040ba410385c8c7536a39c2a586896e120ae86$ docker container <span class="token function">ls</span>IMAGE       CONTAINER ID        STATUS         PORTS                  NAMESnginx       769acc819c0d        Up 4 minutes   0.0.0.0:32769-<span class="token operator">></span>80/tcp  <span class="token function">test</span></code></pre><p>本机访问结果<br><img src="http://static.xiangdangnian.net.cn/WX20200819-145535.png" alt="结果"></p><p><strong>其他端口映射配置可以查看链接</strong> <a href="https://yeasy.gitbook.io/docker_practice/network/port_mapping" target="_blank" rel="noopener">https://yeasy.gitbook.io/docker_practice/network/port_mapping</a></p><h2 id="使用自定义网络实现容器间的互连"><a href="#使用自定义网络实现容器间的互连" class="headerlink" title="使用自定义网络实现容器间的互连"></a>使用自定义网络实现容器间的互连</h2><blockquote><p>在实际应用中各容器间的通信不是通过 ip 地址，而是通过容器名称来连接的，那么这种事如何实现的呢？继续往下看吧。</p></blockquote><h3 id="创建一个自定义网络"><a href="#创建一个自定义网络" class="headerlink" title="创建一个自定义网络"></a>创建一个自定义网络</h3><pre class=" language-bash"><code class="language-bash">$ docker network create my-neta4806e9a4874118f1269992086dbe4137024b53603a4ac68cd6c0c548257b6b7 $ docker network <span class="token function">ls</span>NETWORK ID          NAME                DRIVER              SCOPEa4806e9a4874        my-net              bridge              local</code></pre><h3 id="创建-2-个容器将其加入自定义网络"><a href="#创建-2-个容器将其加入自定义网络" class="headerlink" title="创建 2 个容器将其加入自定义网络"></a>创建 2 个容器将其加入自定义网络</h3><pre class=" language-bash"><code class="language-bash">$ docker run --name box1 -it --rm  --network my-net busybox sh<span class="token comment" spellcheck="true"># //退出容器。使用 Ctrl+P+Q 退出容器但是容器不会关闭</span>$ docker run --name box2 -it --rm  --network my-net busybox sh<span class="token comment" spellcheck="true"># //退出容器。使用 Ctrl+P+Q 退出容器但是容器不会关闭</span>$ docker container <span class="token function">ls</span> --format <span class="token string">"table {{.Image}}\t{{.ID}}\t{{.Status}}\t{{.Names}}"</span> --allIMAGE                   CONTAINER ID        STATUS                      NAMESbusybox                 5e6a4861f857        Up About a minute           box2busybox                 1d7fa8762b4d        Up 2 minutes                box1</code></pre><h3 id="通过容器名称进行通信"><a href="#通过容器名称进行通信" class="headerlink" title="通过容器名称进行通信"></a>通过容器名称进行通信</h3><pre class=" language-bash"><code class="language-bash">// 进入 box2 容器进行 <span class="token function">ping</span> 测试连通$ docker <span class="token function">exec</span> -it box2 sh<span class="token comment" spellcheck="true"># ping box1</span>PING box1 <span class="token punctuation">(</span>172.19.0.2<span class="token punctuation">)</span>: 56 data bytes64 bytes from 172.19.0.2: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.049 ms64 bytes from 172.19.0.2: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.063 ms64 bytes from 172.19.0.2: seq<span class="token operator">=</span>2 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.057 ms64 bytes from 172.19.0.2: seq<span class="token operator">=</span>3 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.061 ms^C<span class="token comment" spellcheck="true">#</span></code></pre><p>好了，今天的网络相关内容就到这里啦，下集见。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 学习笔记（三）</title>
      <link href="/2020/08/17/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/"/>
      <url>/2020/08/17/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h2 id="docker-容器"><a href="#docker-容器" class="headerlink" title="docker 容器"></a>docker 容器</h2><p>容器是通过 image 创建的进程。</p><blockquote><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p></blockquote><h3 id="新建并启动容器"><a href="#新建并启动容器" class="headerlink" title="新建并启动容器"></a>新建并启动容器</h3><p>下面的命令的含义：通过 Ubuntu:18.04 这个 image 创建一个容器并运行 /bin/echo ‘Hello world’，完成后停止该容器。</p><pre class=" language-bash"><code class="language-bash">$ docker run ubuntu:18.04 /bin/echo <span class="token string">'Hello world'</span>Hello world</code></pre><p>使用 docker run 命令，后台实际上执行的内容为：</p><ol><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层（后面会学）</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去（后面会学）</li><li>从地址池配置一个 ip 地址给容器（后面会学）</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ol><p>上面的示例执行完以后会终止，但是一般我们在使用一个提供服务的容器的时候，不想让它停止，那么可以使用 -d 参数，使容器保持在后台运行。但是需要注意——<strong>容器是否会长久运行，是和 docker run 指定的命令有关，和 -d 参数无关</strong></p><p>如下命令执行完后，容器依然会停止</p><pre class=" language-bash"><code class="language-bash">$ docker run -d ubuntu</code></pre><p><img src="http://static.xiangdangnian.net.cn/XF6zB8vbNWw9uPLGrSkiIt3YdZaHc0K7.png" alt="已停止"></p><p>而如下命令执行完后，容器则在后台保持运行</p><pre class=" language-bash"><code class="language-bash">$ docker run -d ubuntu /bin/sh -c <span class="token string">"while true; do echo hello world; sleep 1; done"</span></code></pre><p><img src="http://static.xiangdangnian.net.cn/VcoLwKIYlG65etAO1bCWNfHUES9FpBza.png" alt="运行中"></p><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><h4 id="attach-命令"><a href="#attach-命令" class="headerlink" title="attach 命令"></a>attach 命令</h4><pre class=" language-bash"><code class="language-bash">$ docker run -dit ubuntuffff9516c6151ef3b436df1bccc70ba9da2d0f57bbec5afe19353fe481e12702$ docker container <span class="token function">ls</span>CONTAINER ID        IMAGE                   COMMAND                  CREATED             STATUS              PORTS                                      NAMESffff9516c615        ubuntu                  <span class="token string">"/bin/bash"</span>              7 seconds ago       Up 6 seconds                                                   elegant_hypatia$ docker attach ffff9516c615root@ffff9516c615:/<span class="token comment" spellcheck="true">#</span></code></pre><p><strong>注意： 如果从这个 stdin 中 exit，会导致容器的停止。</strong></p><h4 id="exec-命令-推荐使用，一般配合-it-参数"><a href="#exec-命令-推荐使用，一般配合-it-参数" class="headerlink" title="exec 命令(推荐使用，一般配合 -it 参数)"></a>exec 命令(推荐使用，一般配合 -it 参数)</h4><pre class=" language-bash"><code class="language-bash">$ docker run -dit ubuntu15fc4d97c1b4ea25d76e568fb4e695d5b48d7f13ebbb6d718a80b86a4764a005// 只用 -i 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。$ docker <span class="token function">exec</span> -i 15fc4d97c1b4ea25 <span class="token function">bash</span><span class="token function">ls</span>binbootdevetc<span class="token punctuation">..</span>.//当 -i -t 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。$ docker <span class="token function">exec</span> -it 15fc4d97c1b4ea25 <span class="token function">bash</span>root@15fc4d97c1b4:/<span class="token comment" spellcheck="true">#</span></code></pre><p><strong>注意：如果从这个 stdin 中 exit，不会导致容器的停止。</strong></p><h4 id="容器常用命令"><a href="#容器常用命令" class="headerlink" title="容器常用命令"></a>容器常用命令</h4><ol><li>docker container ls –all        <strong>查看当前系统中的所有（运行中、已停止的）容器</strong> </li><li>docker container start XXX       <strong>把已经停止的 XXX 容器启动</strong></li><li>docker container stop XXX        <strong>把运行总的 XXX 容器停止</strong> </li><li>docker container restart XXX     <strong>重新启动运行中的 XXX 容器</strong></li><li>docker container prune           <strong>删除所有处于停止状态的容器</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 学习笔记（二）</title>
      <link href="/2020/08/10/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
      <url>/2020/08/10/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="镜像-Image"><a href="#镜像-Image" class="headerlink" title="镜像 Image"></a>镜像 Image</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p></blockquote><p>上面是比较官方的解释，估计大部分也没看太懂，那么我就用我自己理解的方式说一下吧。</p><p>image 类似于我们安装系统的镜像文件，通过 image 文件我们可以生成容器文件。一般镜像文件是分层存储的，使用了Union Fs 的技术（具体是个啥我也不太懂🤦‍♂️），也就说一个镜像文件是很多块组成的，有点类似于现在前端的组件化开发，是一组文件组成的。镜像可以向面向对象的类一样可以进行继承，通过一些基础镜像来构建属于我们自己的镜像。</p><p>上面说了一大堆好像还不是很明白的样子，下面还是用例子来说明吧。go go go~~~</p><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><blockquote><p>通过 docker pull 命令从 Docker Hub 仓库获取镜像。</p></blockquote><pre class=" language-bash"><code class="language-bash">docker pull <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token punctuation">[</span>Docker Registry 地址<span class="token punctuation">[</span>:端口号<span class="token punctuation">]</span>/<span class="token punctuation">]</span>仓库名<span class="token punctuation">[</span>:标签<span class="token punctuation">]</span></code></pre><p>具体的选项可以通过 docker pull –help 查看</p><ol><li>地址的格式一般是 &lt;域名/IP&gt;[:端口号] 默认地址是 Docker Hub, 可以省略</li><li>仓库名：这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。</li><li>标签： 一般为版本号</li></ol><p><strong>这里穿插一个镜像急速的内容</strong><br>由于国内网络的问题我们需要对拉取镜像的地址镜像更改，使用国内的镜像地址来加快拉取速度。</p><h3 id="linux-系统（已测试）"><a href="#linux-系统（已测试）" class="headerlink" title="linux 系统（已测试）"></a>linux 系统（已测试）</h3><p>在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"registry-mirrors"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token string">"https://hub-mirror.c.163.com"</span><span class="token punctuation">,</span>    <span class="token string">"https://mirror.baidubce.com"</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>重启服务</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">sudo</span> systemctl daemon-reload$ <span class="token function">sudo</span> systemctl restart docker</code></pre><h3 id="Windows-10（未测试）"><a href="#Windows-10（未测试）" class="headerlink" title="Windows 10（未测试）"></a>Windows 10（未测试）</h3><p>在任务栏托盘 Docker 图标内右键菜单选择 Settings，打开配置窗口后在左侧导航菜单选择 Docker Engine，在右侧像下边一样编辑 json 文件，之后点击 Apply &amp; Restart 保存后 Docker 就会重启并应用配置的镜像地址了。</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"registry-mirrors"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token string">"https://hub-mirror.c.163.com"</span><span class="token punctuation">,</span>    <span class="token string">"https://mirror.baidubce.com"</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h3 id="macOS。（已测试）"><a href="#macOS。（已测试）" class="headerlink" title="macOS。（已测试）"></a>macOS。（已测试）</h3><p>在任务栏点击 Docker Desktop 应用图标 -&gt; Perferences，在左侧导航菜单选择 Docker Engine，在右侧像下边一样编辑 json 文件。修改完成之后，点击 Apply &amp; Restart 按钮，Docker 就会重启并应用配置的镜像地址了。</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"registry-mirrors"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token string">"https://hub-mirror.c.163.com"</span><span class="token punctuation">,</span>    <span class="token string">"https://mirror.baidubce.com"</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>执行 <strong>$ docker info</strong>如果从结果中看到如下内容，说明配置成功。</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">..</span>.Registry Mirrors: https://hub-mirror.c.163.com/<span class="token punctuation">..</span>.</code></pre><h2 id="继续镜像的拉取"><a href="#继续镜像的拉取" class="headerlink" title="继续镜像的拉取"></a>继续镜像的拉取</h2><p>使用 docker pull 拉取Ubuntu 镜像</p><pre class=" language-bash"><code class="language-bash">$ docker pull ubuntu:18.0418.04: Pulling from library/ubuntu7595c8c21622: Pull completed13af8ca898f: Pull complete70799171ddba: Pull completeb6c12202c5ef: Pull completeDigest: sha256:a61728f6128fb4a7a20efaa7597607ed6e69973ee9b9123e3b4fd28b7bba100bStatus: Downloaded newer image <span class="token keyword">for</span> ubuntu:18.04docker.io/library/ubuntu:18.04</code></pre><p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 ubuntu:18.04，因此将会获取官方镜像 library/ubuntu 仓库中标签为 18.04 的镜像。</p><p>从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。</p><h2 id="以镜像为基础启动容器"><a href="#以镜像为基础启动容器" class="headerlink" title="以镜像为基础启动容器"></a>以镜像为基础启动容器</h2><pre class=" language-bash"><code class="language-bash">$ docker run -i -t --rm ubuntu:18.04 <span class="token function">bash</span>root@94053f3fa153:/<span class="token comment" spellcheck="true"># cat /etc/os-release</span>NAME<span class="token operator">=</span><span class="token string">"Ubuntu"</span>VERSION<span class="token operator">=</span><span class="token string">"18.04.4 LTS (Bionic Beaver)"</span>ID<span class="token operator">=</span>ubuntuID_LIKE<span class="token operator">=</span>debianPRETTY_NAME<span class="token operator">=</span><span class="token string">"Ubuntu 18.04.4 LTS"</span>VERSION_ID<span class="token operator">=</span><span class="token string">"18.04"</span>HOME_URL<span class="token operator">=</span><span class="token string">"https://www.ubuntu.com/"</span>SUPPORT_URL<span class="token operator">=</span><span class="token string">"https://help.ubuntu.com/"</span>BUG_REPORT_URL<span class="token operator">=</span><span class="token string">"https://bugs.launchpad.net/ubuntu/"</span>PRIVACY_POLICY_URL<span class="token operator">=</span><span class="token string">"https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"</span>VERSION_CODENAME<span class="token operator">=</span>bionicUBUNTU_CODENAME<span class="token operator">=</span>bionicroot@94053f3fa153:/<span class="token comment" spellcheck="true">#</span></code></pre><p>docker run 就是运行容器的命令，具体格式在后面容器相关章节进行详细介绍。这里简单解释一下</p><ul><li>-i 交互式操作，让容器的标准输入保持打开。</li><li>-t 选项让 Docker 分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上。</li><li>–rm 容器退出后随之将其删除。（默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 –rm 可以避免浪费空间。）</li><li>ubuntu：18.04  使用 ubuntu:18.04 镜像为基础来启动容器。</li><li>bash 放在镜像名后的是 命令，这里我们希望有个交互式 Shell，因此用的是 bash。</li></ul><p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 cat /etc/os-release，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 Ubuntu 18.04.1 LTS 系统。</p><p>最后我们通过 exit 退出了这个容器。</p><h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2><p>使用 docker image ls 列出已经下载了的镜像文件</p><pre class=" language-bash"><code class="language-bash">$ docker image <span class="token function">ls</span>REPOSITORY           TAG                 IMAGE ID            CREATED             SIZEredis                latest              5f515359c7f8        5 days ago          183 MBnginx                latest              05a60462f8ba        5 days ago          181 MBmongo                3.2                 fe9198c04d62        5 days ago          342 MB<span class="token operator">&lt;</span>none<span class="token operator">></span>               <span class="token operator">&lt;</span>none<span class="token operator">></span>              00285df0df87        5 days ago          342 MBubuntu               18.04               f753707788c5        4 weeks ago         127 MBubuntu               latest              f753707788c5        4 weeks ago         127 MB</code></pre><p>列表包含了 仓库名、标签、镜像 ID、创建时间 以及 所占用的空间。</p><ul><li><p>镜像 ID 则是镜像的唯一标识，因为一个镜像可以对应多个标签。因此，在上面的例子中，我们可以看到 ubuntu:18.04 和 ubuntu:latest 拥有相同的 ID，因为它们对应的是同一个镜像。</p></li><li><p>镜像的体积跟 Docker Hub 上的不一致是因为 Docker Hub 中显示的体积是压缩后的体积。而 docker image ls 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和。</p></li><li><p>另外一个需要注意的问题是，docker image ls 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p></li></ul><p>使用以下命令查看镜像、容器、数据卷所占用的空间。</p><pre class=" language-bash"><code class="language-bash">$ docker system <span class="token function">df</span>TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLEImages              24                  0                   1.992GB             1.992GB <span class="token punctuation">(</span>100%<span class="token punctuation">)</span>Containers          1                   0                   62.82MB             62.82MB <span class="token punctuation">(</span>100%<span class="token punctuation">)</span>Local Volumes       9                   0                   652.2MB             652.2MB <span class="token punctuation">(</span>100%<span class="token punctuation">)</span>Build Cache                                                 0B                  0B</code></pre><h3 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h3><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>none<span class="token operator">></span>               <span class="token operator">&lt;</span>none<span class="token operator">></span>              00285df0df87        5 days ago          342 MB</code></pre><p>既没有仓库名，也没有标签,显示为 none 的就是虚悬镜像</p><p>个镜像原本是有镜像名和标签的，原来为 mongo:3.2，随着官方镜像维护，发布了新版本后，重新 docker pull mongo:3.2 时，mongo:3.2 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <none>。除了 docker pull 可能导致这种情况，docker build 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <none> 的镜像。这类无标签镜像也被称为 虚悬镜像(dangling image) ，可以用下面的命令专门显示这类镜像：</none></none></p><pre class=" language-bash"><code class="language-bash">$ docker image <span class="token function">ls</span> -f dangling<span class="token operator">=</span>trueREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<span class="token operator">&lt;</span>none<span class="token operator">></span>              <span class="token operator">&lt;</span>none<span class="token operator">></span>              00285df0df87        5 days ago          342 MB</code></pre><p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。</p><pre class=" language-bash"><code class="language-bash">$ docker image prune</code></pre><h3 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h3><p>为了加速镜像构建、重复利用资源，Docker 会利用 中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 docker image ls 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。</p><pre class=" language-bash"><code class="language-bash">$ docker image <span class="token function">ls</span> -a</code></pre><p><strong>这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错</strong></p><h3 id="常用列出镜像的命令"><a href="#常用列出镜像的命令" class="headerlink" title="常用列出镜像的命令"></a>常用列出镜像的命令</h3><h4 id="根据仓库名列出镜像"><a href="#根据仓库名列出镜像" class="headerlink" title="根据仓库名列出镜像"></a>根据仓库名列出镜像</h4><pre class=" language-bash"><code class="language-bash">$ docker image <span class="token function">ls</span> ubuntuREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              18.04               f753707788c5        4 weeks ago         127 MBubuntu              latest              f753707788c5        4 weeks ago         127 MB</code></pre><h4 id="列出特定的某个镜像"><a href="#列出特定的某个镜像" class="headerlink" title="列出特定的某个镜像"></a>列出特定的某个镜像</h4><pre class=" language-bash"><code class="language-bash">$ docker image <span class="token function">ls</span> ubuntu:18.04REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              18.04               f753707788c5        4 weeks ago         127 MB</code></pre><h4 id="只查看镜像ID"><a href="#只查看镜像ID" class="headerlink" title="只查看镜像ID"></a>只查看镜像ID</h4><pre class=" language-bash"><code class="language-bash">$ docker image <span class="token function">ls</span> -q5f515359c7f805a60462f8bafe9198c04d6200285df0df87f753707788c5f753707788c51e0c3dd64ccd</code></pre><h4 id="以表格等距显示，并且有标题行"><a href="#以表格等距显示，并且有标题行" class="headerlink" title="以表格等距显示，并且有标题行"></a>以表格等距显示，并且有标题行</h4><pre class=" language-bash"><code class="language-bash">$ docker image <span class="token function">ls</span> --format <span class="token string">"table {{.ID}}\t{{.Repository}}\t{{.Tag}}"</span>IMAGE ID            REPOSITORY          TAG5f515359c7f8        redis               latest05a60462f8ba        nginx               latestfe9198c04d62        mongo               3.200285df0df87        <span class="token operator">&lt;</span>none<span class="token operator">></span>              <span class="token operator">&lt;</span>none<span class="token operator">></span>f753707788c5        ubuntu              18.04f753707788c5        ubuntu              latest</code></pre><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><blockquote><p>格式</p><pre class=" language-bash"><code class="language-bash">$ docker image <span class="token function">rm</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token operator">&lt;</span>镜像1<span class="token operator">></span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>镜像2<span class="token operator">></span> <span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre><p><strong>其中，&lt;镜像&gt; 可以是 镜像短 ID、镜像长 ID、镜像名 或者 镜像摘要。</strong></p></blockquote><h3 id="Untagged-和-Deleted"><a href="#Untagged-和-Deleted" class="headerlink" title="Untagged 和 Deleted"></a>Untagged 和 Deleted</h3><p>因为一个镜像可以有多个标签，当我们执行 <code>docker image rm</code> 命令时，如果如果还有其他标签指向这个镜像，那么就不会产生 Delete 操作。</p><h3 id="用-docker-image-ls-命令来配合删除"><a href="#用-docker-image-ls-命令来配合删除" class="headerlink" title="用 docker image ls 命令来配合删除"></a>用 docker image ls 命令来配合删除</h3><p>以下命令可以删除所有仓库名为 redis 的镜像</p><pre class=" language-bash"><code class="language-bash">$ docker image <span class="token function">rm</span> <span class="token variable"><span class="token variable">$(</span>docker image <span class="token function">ls</span> -q redis<span class="token variable">)</span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 学习笔记（一）</title>
      <link href="/2020/08/09/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
      <url>/2020/08/09/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="docker-介绍"><a href="#docker-介绍" class="headerlink" title="docker 介绍"></a>docker 介绍</h2><p>docker 这个东西应该做开发的应该都有听说过，但是不知道大家有没有详细的了解过。反正我是属于听说过，大概知道是个什么东西，能特别简单的使用。但是一直没有深入的学习过，今天在这里我想把学习 docker 的过程记录下来，方便日后查找。</p><p>那么下面开始啦。~~~</p><h2 id="为啥要使用-docker"><a href="#为啥要使用-docker" class="headerlink" title="为啥要使用 docker"></a>为啥要使用 docker</h2><blockquote><p>在我电脑上运行的是正常的啊？怎么到了别人的电脑上就不能正常运行了呢？</p></blockquote><p>如果你也碰到上面的问题了，那么请你也开始 docker 的学习吧。这个时候有人会说为啥不用虚拟机呢，因为虚拟机是完全模拟一台正常运行的。就算你只是需要运行一个 php 的环境，那么系统默认的一些其他进程也是会启动的，这样就会降低我们电脑的利用率。还有一点就是虚拟机一般是不能再生产环境中使用的。但是 docker 没有问题。总而言之一句话，虚拟机不好，我们要用 docker 。</p><h2 id="docker-的用途"><a href="#docker-的用途" class="headerlink" title="docker 的用途"></a>docker 的用途</h2><ol><li>提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</li><li>提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</li><li>组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</li></ol><h2 id="docker-的安装"><a href="#docker-的安装" class="headerlink" title="docker 的安装"></a>docker 的安装</h2><p>docker 分为社区版（CE）、企业版本（EE）<br>win 和 mac 安装很简单，就是正常的安装软件的方法，而用能用 linux 系统的，相信你也有办法找到安装的方法的。</p><p>安装完成之后使用如下命令验证是否安装成功</p><pre class=" language-bash"><code class="language-bash">$ docker version<span class="token comment" spellcheck="true"># 或者</span>$ docker info</code></pre><p><strong>Docker 需要用户具有 sudo 权限，为了避免每次命令都输入sudo，可以把用户加入 Docker 用户组</strong></p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">usermod</span> -aG docker <span class="token variable">$USER</span></code></pre><p>使用如下命令启动 docker</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># service 命令的用法</span>$ <span class="token function">sudo</span> <span class="token function">service</span> docker start<span class="token comment" spellcheck="true"># systemctl 命令的用法</span>$ <span class="token function">sudo</span> systemctl start docker</code></pre><h2 id="第一个实例-hello-world"><a href="#第一个实例-hello-world" class="headerlink" title="第一个实例 hello world"></a>第一个实例 hello world</h2><pre class=" language-bash"><code class="language-bash">$ docker container run hello-world</code></pre><p>如果运行成功，你会在屏幕上读到下面的输出。</p><pre class=" language-bash"><code class="language-bash">$ docker container run hello-worldHello from Docker<span class="token operator">!</span>This message shows that your installation appears to be working correctly.<span class="token punctuation">..</span>. <span class="token punctuation">..</span>.</code></pre><p>上面命令的过程就是：</p><ol><li>从 docker 的官方仓库拉取 hello world image 文件到本地</li><li>使用 image 文件 生成 容器文件</li><li>运行 hello world 容器 —&gt; 输出相关内容  —&gt; 容器自动终止（有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。）</li></ol><p>通过上面的实例大概知道了 docker 的是怎么回事了。主要就是需要明白两个文件，image文件和容器文件。接下来我们制作一个 image 文件，并通过该文件生成容器并运行。</p><h2 id="制作自己的-docker-容器"><a href="#制作自己的-docker-容器" class="headerlink" title="制作自己的 docker 容器"></a>制作自己的 docker 容器</h2><ol><li>新建一个目录<pre class=" language-bash"><code class="language-bash">$ <span class="token function">mkdir</span> hello <span class="token operator">&amp;&amp;</span> <span class="token function">cd</span> hello </code></pre></li><li>在目录中新建 .dockerignore 文件（该文件类似于 git 项目中的 .gitignore 文件）</li><li><p>在目录中新建 Dockerfile 文件,内容如下所示<br><img src="http://static.xiangdangnian.net.cn/blog/2020/08/10/20-29-32-9faae2396ce4759958aee55bfcabc924-f01fa1.png" alt=""></p></li><li><p>运行命令，进行 image 的构建</p><pre class=" language-bash"><code class="language-bash">$ docker build -t nginx:v1 <span class="token keyword">.</span></code></pre><p>看到如下内容则表示 image 构建成功。<br><img src="http://static.xiangdangnian.net.cn/blog/2020/08/10/20-30-47-a92e94e81727959af077be139e676ed6-044d5a.png" alt=""></p></li><li><p>通过 image 文件生成容器文件</p><pre class=" language-bash"><code class="language-bash">$ docker run --name webserver -p 9527:80 nginx:v1</code></pre></li><li>通过浏览器访问 localhost:9527,如果可以看到如下内容则成功<br><img src="http://static.xiangdangnian.net.cn/blog/2020/08/10/20-35-50-6f66e88683370b594f2ec01744c008cf-0c3367.png" alt=""></li></ol><p>一个简单的容器就完成了。通过这个例子我们可以大概了解 docker 的配置，运行， 后面会深入 docker 相关的概念进行学习，并定下第一个计划 ———— 配置一个属于自己的 LNMP docker 测试环境。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《被讨厌的勇气》读后感</title>
      <link href="/2020/06/09/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
      <url>/2020/06/09/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>自从从外地回到家里，感觉焦虑的情绪比之前更深了。就这本读后感来记录一下近期的情况吧。</p></blockquote><p>发现这本书也是一个偶然的机会吧。因为已经30岁了还没有结婚，而且也从来没有谈过恋爱，那么从回到家开始家里人就一直在张罗相亲的事情。最近认识了一个女生，也见过几面，聊的也算还行，就是比较客气的问候以及随便的闲聊。大概持续了得有2个月左右吧。近期感觉在微信上聊得非常不错，本想着约出来表白一下。也不知道那天是什么原因，吃饭的时候来到一家刚开也的烧烤店，因为刚开业在做活动，外面不停的有人在唱歌，声音很大听不清说话的那种。然后这顿饭就吃的不是很愉快，期间也没怎么聊。饭后大家就坐车回去了。到家后我就感觉不知道为什么都认识也算挺久的了，怎么在一起的时候还是像普通人一样，非常的客气、生疏，完全不像微信里聊天的那种感觉，更别说恋爱的感觉了。</p><p>后来我就这反思，究竟什么原因造成了现在的这种局面。我承认自己性格内向，不善于表达。但是平常在一些朋友同、事面前表现的也还好。然后就在网络上查这是怎么回事。有人提到了「社交恐惧症」。</p><p>之前也知道这么个词语，但真的没往自己身上想，就是觉得自己有点内向，不爱说话罢了。然而仔细看了下社恐的症状——可能我真的有些轻微的社恐了。</p><p>下面讲下重点——《被讨厌的勇气》这本书。</p><ul><li><p>本书主要通过哲人和以为青年之间的对话的方式引出了阿德勒心理学的相关内容。</p></li><li><p>首先颠覆了弗洛伊德的原因论。</p></li><li><p>接下来是人生的烦恼和自卑都是来自有人际关系。</p></li><li><p>第三教会我们如何把自己和别人的人生课题分开。</p></li><li><p>第四就是标题所讲的内容，要有被讨厌的勇气。</p></li><li><p>最后告知我们要活在当下，即不要纠结过去的原因，也不要畅享未来的美好，过好人生的每一个刹那。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 观后感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 websocket 简单模拟直播效果（初级版）</title>
      <link href="/2020/02/28/%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E7%9B%B4%E6%92%AD/"/>
      <url>/2020/02/28/%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F%E7%9B%B4%E6%92%AD/</url>
      
        <content type="html"><![CDATA[<blockquote><p>基于 swoole 通过 websocket 简单实现直播效果。（主要学习一下 websocket 相关知识点）</p></blockquote><p><img src="http://static.xiangdangnian.net.cn/blog/wesocket.jpg" alt="流程图"></p><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><ol><li>在直播页使用视频的方式模拟摄像头</li><li>利用 canvas 绘制视频内容</li><li>通过 canvas 将绘制的图片转化为 base64 格式</li><li>使用 settimeout 定时执行，通过 websocket 将 base64 格式图片传递到服务端</li><li>服务端接收到数据之后，通过广播的形式进行推送</li><li>客户端页面通过 websocket 接收服务端发来的数据在页面上循环展示</li><li>完成</li></ol><h2 id="直播页"><a href="#直播页" class="headerlink" title="直播页"></a>直播页</h2><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Title<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>video</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xszr.mp4<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>video<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>400<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>400<span class="token punctuation">"</span></span> <span class="token attr-name">autoplay</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">controls</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>video</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>canvas</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>canvas<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1280<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>720<span class="token punctuation">"</span></span> <span class="token attr-name">hidden</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>canvas</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    ws <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSocket</span><span class="token punctuation">(</span><span class="token string">"ws://test.test/ws"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> video <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'video'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> canvas <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'canvas'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> context <span class="token operator">=</span> canvas<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token string">'2d'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        context<span class="token punctuation">.</span><span class="token function">drawImage</span><span class="token punctuation">(</span>video<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ws<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>canvas<span class="token punctuation">.</span><span class="token function">toDataURL</span><span class="token punctuation">(</span><span class="token string">'image/jpeg'</span><span class="token punctuation">,</span><span class="token number">0.4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span>draw<span class="token punctuation">,</span><span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ws<span class="token punctuation">.</span>onopen <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><h2 id="websocket-服务端"><a href="#websocket-服务端" class="headerlink" title="websocket 服务端"></a>websocket 服务端</h2><pre class=" language-php"><code class="language-php"><span class="token variable">$ws</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">swoole_websocket_server</span><span class="token punctuation">(</span><span class="token string">'0.0.0.0'</span><span class="token punctuation">,</span><span class="token number">9527</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//监听WebSocket消息事件</span><span class="token variable">$ws</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token variable">$ws</span><span class="token punctuation">,</span> <span class="token variable">$frame</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$ws</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">connections</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$ws</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">connections</span> <span class="token keyword">as</span> <span class="token variable">$fd</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token variable">$ws</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">push</span><span class="token punctuation">(</span><span class="token variable">$fd</span><span class="token punctuation">,</span><span class="token variable">$frame</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">data</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//监听WebSocket连接关闭事件</span><span class="token variable">$ws</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'close'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token variable">$ws</span><span class="token punctuation">,</span> <span class="token variable">$fd</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">"client-{$fd} is closed\n"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$ws</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Title<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>img<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1280<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>720<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    ws <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSocket</span><span class="token punctuation">(</span><span class="token string">"ws://test.test/ws"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    img <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ws<span class="token punctuation">.</span>onmessage <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        img<span class="token punctuation">.</span>src <span class="token operator">=</span> event<span class="token punctuation">.</span>data    <span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="http://static.xiangdangnian.net.cn/blog/fdssddsfsdfsdf.gif" alt="最终效果"></p><h3 id="nginx-配置"><a href="#nginx-配置" class="headerlink" title="nginx 配置"></a>nginx 配置</h3><pre class=" language-nginx"><code class="language-nginx"><span class="token keyword">upstream</span> test <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true"># 因为使用的laradock 所以是workspace，其他环境根据具体情况填写对应 ip 地址</span>    <span class="token keyword">server</span> workspace<span class="token punctuation">:</span><span class="token number">9527</span> weight<span class="token operator">=</span><span class="token number">5</span> max_fails<span class="token operator">=</span><span class="token number">3</span> fail_timeout<span class="token operator">=</span>30s<span class="token punctuation">;</span>    <span class="token keyword">keepalive</span> <span class="token number">16</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">server</span> <span class="token punctuation">{</span>    <span class="token keyword">listen</span> <span class="token number">80</span><span class="token punctuation">;</span>    <span class="token keyword">server_name</span> test<span class="token punctuation">.</span>test<span class="token punctuation">;</span>    <span class="token keyword">root</span> <span class="token operator">/</span>var<span class="token operator">/</span>www<span class="token operator">/</span>test<span class="token punctuation">;</span>    <span class="token keyword">index</span> <span class="token keyword">index</span><span class="token punctuation">.</span>php <span class="token keyword">index</span><span class="token punctuation">.</span>html <span class="token keyword">index</span><span class="token punctuation">.</span>htm<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true"># 因为 laradock 开启其他端口比较麻烦，所以使用该方法进行转发</span>    <span class="token keyword">location</span> <span class="token operator">=</span><span class="token operator">/</span>ws <span class="token punctuation">{</span>        <span class="token keyword">proxy_http_version</span> <span class="token number">1.1</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Real<span class="token operator">-</span>IP <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Real<span class="token operator">-</span>PORT <span class="token variable">$remote_port</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Forwarded<span class="token operator">-</span>For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> Host <span class="token variable">$http_host</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> Scheme <span class="token variable">$scheme</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> <span class="token keyword">Server</span><span class="token operator">-</span><span class="token keyword">Protocol</span> <span class="token variable">$server_protocol</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> <span class="token keyword">Server</span><span class="token operator">-</span>Name <span class="token variable">$server_name</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> <span class="token keyword">Server</span><span class="token operator">-</span>Addr <span class="token variable">$server_addr</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> <span class="token keyword">Server</span><span class="token operator">-</span>Port <span class="token variable">$server_port</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> Upgrade <span class="token variable">$http_upgrade</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> Connection <span class="token variable">$connection_upgrade</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>test<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> swoole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《但是还有书籍》观后感</title>
      <link href="/2020/02/01/%E4%BD%86%E6%98%AF%E8%BF%98%E6%9C%89%E4%B9%A6%E7%B1%8D%E8%A7%82%E5%90%8E%E6%84%9F/"/>
      <url>/2020/02/01/%E4%BD%86%E6%98%AF%E8%BF%98%E6%9C%89%E4%B9%A6%E7%B1%8D%E8%A7%82%E5%90%8E%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天在 B 站上看了一部人文类的纪录片《但是还有书籍》，看过后激发了我内心深处那一丝文艺青年的骚动。(😓)所以就有了下面的内容。</p></blockquote><h2 id="第一集「书海编舟记」"><a href="#第一集「书海编舟记」" class="headerlink" title="第一集「书海编舟记」"></a>第一集「书海编舟记」</h2><p><em>一群隐身于书背后的人，他们穿梭于字里行间，钻研着逗号、句号的学问，他们以敏锐的眼光探寻文学的矿脉，他们以细微琐碎的工作搭建起跨越语言的桥梁，摆渡于作者和读者之间，编织着航行于浩瀚文海中的思想之舟。</em></p><p>上面的文字是这一集的开篇语，读过上面的文字相信大家应该已经知道这一集讲述的是什么内容了吧。没错！就是书籍编辑者和书籍翻译者。</p><p>这一集主要讲述了3个人的故事。</p><p>第一位叫做朱岳，是后浪文学的一名主编也是一名作者。主要是将一些台湾、新加坡之类的华语类文学引入国内，让国内的我们也可以读到这些地方的作品。第二位叫做俞国林，是中华书局学术著作出版中心的主任。通过他的努力，历时十三年的时间终于在2018年1月出版了《郑天挺西南联大日记》一书，该书的出版对研究西南联大校史、近代学术史都是极为重要的史料。第三位叫做范晔是北京大学外国语学院西葡语系的系主任。他是《百年孤独》中文版的译者，为了能够更好的表达作者的意思且可以在10个月内完成翻译，他翻遍了马尔克斯其他的作品，一遍一遍的查字典、翻阅资料，终于在2011年6月花了11月翻译的作品出版了。</p><p>虽然三位平凡的文字工作者在平凡的工作 岗位上做着平凡的事情，但是因为他们的努力我们才能看到其他地区华语文学作品，让我们得以了解他们的生活、文化。也是他们的努力让我可以了解历史，获悉曾经发生的故事。还是他们的努力让我们可以看到其他外国文学。</p><h2 id="第二集「二手书的奇幻漂流」"><a href="#第二集「二手书的奇幻漂流」" class="headerlink" title="第二集「二手书的奇幻漂流」"></a>第二集「二手书的奇幻漂流」</h2><p><em>书籍从一诞生便开始了他的奇幻之旅。从书店到读书人手中，从一个书房到另一个书房，他们在漫长的岁月中辗转流徙，不断增添新的痕迹与记忆，与人共同书写着一段段故事与传奇</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 观后感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>laravel通过关联模型实现无限极分类</title>
      <link href="/2020/01/15/laravel%E9%80%9A%E8%BF%87%E5%85%B3%E8%81%94%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%99%90%E6%9E%81%E5%88%86%E7%B1%BB/"/>
      <url>/2020/01/15/laravel%E9%80%9A%E8%BF%87%E5%85%B3%E8%81%94%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%99%90%E6%9E%81%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Laravel-通过关联模型实现无限极分类"><a href="#Laravel-通过关联模型实现无限极分类" class="headerlink" title="Laravel 通过关联模型实现无限极分类"></a>Laravel 通过关联模型实现无限极分类</h1><blockquote><p>这个内容是在 Laravel-China 论坛上看到的，怕以后不好找，这里记录一下。原文地址为：<a href="https://learnku.com/articles/14068/simple-practice-of-laravel-infinite-class-classification" target="_blank" rel="noopener">https://learnku.com/articles/14068/simple-practice-of-laravel-infinite-class-classification</a></p></blockquote><h2 id="数据库结构"><a href="#数据库结构" class="headerlink" title="数据库结构"></a>数据库结构</h2><p>这里使用省市区结构</p><pre class=" language-php"><code class="language-php"><span class="token keyword">class</span> <span class="token class-name">CreateAreasTable</span> <span class="token keyword">extends</span> <span class="token class-name">Migration</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span>    <span class="token punctuation">.</span>    <span class="token punctuation">.</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Schema<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">'areas'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>Blueprint <span class="token variable">$table</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token variable">$table</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">unsignedInteger</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token variable">$table</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">comment</span><span class="token punctuation">(</span><span class="token string">'城市名称'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token variable">$table</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">unsignedInteger</span><span class="token punctuation">(</span><span class="token string">'pid'</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token keyword">default</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">comment</span><span class="token punctuation">(</span><span class="token string">'父级id'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span>    <span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><h2 id="Area-模型增加关联方法"><a href="#Area-模型增加关联方法" class="headerlink" title="Area 模型增加关联方法"></a>Area 模型增加关联方法</h2><pre class=" language-php"><code class="language-php"><span class="token keyword">class</span> <span class="token class-name">Area</span> <span class="token keyword">extends</span> <span class="token class-name">Model</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span>    <span class="token punctuation">.</span>    <span class="token punctuation">.</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">childArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">hasMany</span><span class="token punctuation">(</span>Area<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token string">'pid'</span><span class="token punctuation">,</span><span class="token string">'id'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">allChildArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">childArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">with</span><span class="token punctuation">(</span><span class="token string">'allChildArea'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span>    <span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><blockquote><p>通过如下代码可以得到所有地区的无限极分类结构。更改条件可以查看某个地区及其子地区的无限极分类结构</p></blockquote><pre class=" language-php"><code class="language-php"><span class="token variable">$res</span> <span class="token operator">=</span> Area<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">with</span><span class="token punctuation">(</span><span class="token string">'allChildArea'</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">where</span><span class="token punctuation">(</span><span class="token string">'pid'</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token variable">$res</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> laravel </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ipad-mini2 降级记录</title>
      <link href="/2020/01/13/%E9%99%8D%E7%BA%A7%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/01/13/%E9%99%8D%E7%BA%A7%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>主要记录下 Ipad mini2 ios12.3.1 降级为 ios10.3.3 的过程</p></blockquote><p>最近因为想着手好好读读书，翻出了压箱底的ipad。（因为曾经手欠，把系统升级成了 ios12.3.1 导致巨卡无比，只能压箱底了）。然后用<a href="https://www.dogedoge.com" target="_blank" rel="noopener">狗子</a>搜索了一下。竟然让我找到了<a href="https://www.v2ex.com/t/608874" target="_blank" rel="noopener">V2ex上的一个讨论</a>，仔细一看感觉挺靠谱，接下来就搞了。</p><blockquote><p>下面基本上都是废话，会玩直接看 v2 的帖子应该就可以搞定了，上面贴出了 GitHub 上项目的地址，基本上就是一键操作。</p></blockquote><p>根据的帖子给出的 github 链接查看项目，发现该项目已经不再维护了，但是好在项目又给出了一个新的地址。赶紧进入新的项目看一下。</p><p>项目提示中指明了可以降级到10.3.3 的设备为 iPhone 5s, iPad Air, iPad Mini 2 (Not iPad4,6)。</p><p>其他还有可以降级到8.4.1 的设备为iPhone 5, iPhone 4s, iPad 2, iPad 3, iPad 4, iPad Mini 1, iPod 5。</p><p>以及可以降级到 6.1.3 的设备 iPhone 4s, iPad 2 (Not iPad2,4)。</p><p>需要的小伙伴们自取。我只实验了ipad mini2 可以成功降级，其他的大家烧香祷告吧。^_^</p><p>首先将项目克隆到本地，接着进入项目目录，并执行 <code>pip3 install -r requirements.txt</code> 安装项目需要的扩展。（确保当前系统中已经安装了python3，至少为3.5）</p><p>下载 ios 10.3.3 的镜像文件。可以使用<a href="https://www.i4.cn/firmware_iPad_iPad%20mini%202__A1489_10.3.3__.html" target="_blank" rel="noopener">爱思助手</a>提供的镜像，下载速度那是杠杠的。</p><p>接下来就是将 ipad 进入 DFU 模式。（这里吐槽一下，因为我不怎么用 ios 的设备，不知道 DFU 到底是个什么鬼，搜索了半天，很多人给出的方法根本不是进入 DFU的方法，最后还是在刚才那个 V2 讨论里面看到有朋友的回复，才明白了该怎么进入 DFU 模式。）</p><p><strong> 这里说一下进入 DFU 模式的方法， </strong></p><ol><li>将 ipad 链接电脑</li><li>经 ipad 关机</li><li>长按电源键和 home 键 10 秒以上然后只松开电源键并保持 home 一直按着，当电脑上提示已经进入恢复模式则可以松开 home 键了。这个时候 ipad 屏幕是黑的。</li></ol><p><img src="http://static.xiangdangnian.net.cn/blog/sssdfsdfsdjkl23jk23j4lk23j423lklkwfjs.png" alt="DFU 模式"></p><p>然后在项目里面执行 <code>./vieux -i .....ipsw</code>。 后面的省略号表示刚才下载的 ios10.3.3 的镜像文件。</p><p>最后尽是等待了。</p><p>我的一次成功，所以也没有什么好分享的啦，就先记录到这里啦。</p><p>对了，最后说一下这个项目应该是只能在 macOS 下操作，windows 是不支持的。在一个就是最好可以使用梯子，要不然项目下载的一下东西可能会很慢，或者完全下不来。</p><p>最后感谢 V2ex，啦啦啦啦又可以愉快地使用 Ipad 啦。</p>]]></content>
      
      
      <categories>
          
          <category> ios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis学习笔记-----基本数据类型之有序集合</title>
      <link href="/2019/12/26/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/"/>
      <url>/2019/12/26/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="有序集合（sort-sets）"><a href="#有序集合（sort-sets）" class="headerlink" title="有序集合（sort sets）"></a>有序集合（sort sets）</h1><ul><li>与集合类型，区别是集合不能字段排序，而有序集合可以设置额外的优先级(score)参数来为成员排序。</li><li>使用场景：当你需要一个有序并且不重复的集合列表的时候，使用有序集合。 </li></ul><h2 id="ZADD"><a href="#ZADD" class="headerlink" title="ZADD"></a>ZADD</h2><ul><li>将一个或多个元素以及其 score 值加入到 key 中。</li><li>如果某个元素已经在有序集合中，则更新该元素的 score 值。</li><li>score 值可以是整数或双精度浮点数。</li></ul><pre><code>127.0.0.1:6379&gt; zadd language 100 php 90 java 80 js(integer) 3</code></pre><h2 id="ZCARD"><a href="#ZCARD" class="headerlink" title="ZCARD"></a>ZCARD</h2><ul><li>返回有序集合 key 的值得个数</li><li>如果 key 不存在，则返回 0</li></ul><pre><code>127.0.0.1:6379&gt; zcard language(integer) 3127.0.0.1:6379&gt; zcard xxxxx(integer) 0</code></pre><h2 id="ZCOUNT"><a href="#ZCOUNT" class="headerlink" title="ZCOUNT"></a>ZCOUNT</h2><ul><li>返回有序集合 key 中，score 的值在 min 和 max 直接的成员个数。（包含 min 和 max）</li><li>如果在统计时，不需要包含某个 score时 ，则添加一个 ( 即可。<br><code>`</code><br>127.0.0.1:6379&gt; zcount language 80 100<br>(integer) 3</li></ul><p>127.0.0.1:6379&gt; zcount language 80 (100<br>(integer) 2</p><pre><code>## ZSCORE- 返回有序集合 key 中，成员的score值</code></pre><p>127.0.0.1:6379&gt; zscore language php<br>“100”</p><pre><code>## ZRANGE- 格式：zrange key start stop [withscores]- 根据索引返回元素- withscores 参数可以连同元素的 score 一起返回。- start 为 0，stop 为 -1，即可返回整个有序集合。</code></pre><p>127.0.0.1:6379&gt; zrange language 0 2<br>1) “js”<br>2) “java”<br>3) “php”</p><p>127.0.0.1:6379&gt; zrange language 0 2 withscores<br>1) “js”<br>2) “80”<br>3) “java”<br>4) “90”<br>5) “php”<br>6) “100”</p><pre><code>## ZREVRANGE- 同 zrange 基本一致，区别是 zrevrange 是反者来的。</code></pre><p>127.0.0.1:6379&gt; zrevrange language 0 2<br>1) “php”<br>2) “java”<br>3) “js”</p><p>127.0.0.1:6379&gt; zrevrange language 0 2 withscores<br>1) “php”<br>2) “100”<br>3) “java”<br>4) “90”<br>5) “js”<br>6) “80”</p><pre><code>## ZRANGEBYSCORE- 返回有序集合 key 中，score 的值在 min 和 max 直接的成员。（包含 min 和 max）- 如果不需要包含某个 score时 ，则添加一个 ( 即可。</code></pre><p>127.0.0.1:6379&gt; zrangebyscore language 80 100<br>1) “js”<br>2) “java”<br>3) “php”</p><p>127.0.0.1:6379&gt; zrangebyscore language 80 100 withscores<br>1) “js”<br>2) “80”<br>3) “java”<br>4) “90”<br>5) “php”<br>6) “100”</p><p>127.0.0.1:6379&gt; zrangebyscore language 80 (100<br>1) “js”<br>2) “java”</p><pre><code>## ZRANK- 返回有序集合 key 中成员 member 在集合中的排名序号。（排名按 score 值从小到大的顺序）。- 排名序号从 0 开始。(即 序号为 0 的 score 值最小)</code></pre><p>127.0.0.1:6379&gt; zrank language php<br>(integer) 2</p><p>127.0.0.1:6379&gt; zrank language js<br>(integer) 0</p><p>127.0.0.1:6379&gt; zrank language java<br>(integer) 1</p><pre><code>## ZREVRANK - 同上面的 zrank。区别是 zrevrank 的排序是从大到小</code></pre><p>127.0.0.1:6379&gt; zrevrank language php<br>(integer) 0</p><p>127.0.0.1:6379&gt; zrevrank language js<br>(integer) 2</p><p>127.0.0.1:6379&gt; zrevrank language java<br>(integer) 1</p><pre><code>## ZINCRBY- 格式：zincrby key increment member- 向有序集合 key 中的成员 member 的 score 值进行增加。- 如果 key 中不存在 member，则在 key 中创建一个 member，并且该 member 的 score 为 设置的值。</code></pre><p>127.0.0.1:6379&gt; zincrby language 100 php<br>“200”</p><p>127.0.0.1:6379&gt; zincrby language 100 python<br>“100”</p><pre><code>## ZREM- 从集合中删除指定 member。</code></pre><p> 127.0.0.1:6379&gt; zrem language python<br>(integer) 1</p><p>127.0.0.1:6379&gt; zrange language 0 -1 withscores<br>1) “js”<br>2) “80”<br>3) “java”<br>4) “90”<br>5) “php”<br>6) “200”<br> <code>`</code></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis学习笔记-----基本数据类型之哈希（HASH）</title>
      <link href="/2019/12/12/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%93%88%E5%B8%8C%EF%BC%88HASH%EF%BC%89/"/>
      <url>/2019/12/12/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%93%88%E5%B8%8C%EF%BC%88HASH%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="哈希（HASH）"><a href="#哈希（HASH）" class="headerlink" title="哈希（HASH）"></a>哈希（HASH）</h1><blockquote><p>哈希就像是一个微缩版的 redis。由键值对组成。一般讲数据库中的记录取出直接放入 redis 中使用。</p></blockquote><h2 id="HSET、HMSET"><a href="#HSET、HMSET" class="headerlink" title="HSET、HMSET"></a>HSET、HMSET</h2><ul><li>设置单个key</li><li>一次设置多个key</li></ul><blockquote><p>经过测试当前版本5.0.4，hset 也可以一次设置多个 key</p></blockquote><h3 id="hset-设置多个-key"><a href="#hset-设置多个-key" class="headerlink" title="hset 设置多个 key"></a>hset 设置多个 key</h3><pre><code>&gt; hset user:1 name jack email jack@qq.com(integer) 2&gt; hget user:1 name&quot;jack&quot;&gt; hget user:1 email&quot;jack@qq.com&quot;</code></pre><h3 id="hset-设置单个-key"><a href="#hset-设置单个-key" class="headerlink" title="hset 设置单个 key"></a>hset 设置单个 key</h3><pre><code>&gt; hset user:2 name tom email tom@qq.com(integer) 2&gt; hget user:2 name&quot;tom&quot;&gt; hget user:2 email&quot;tom@qq.com&quot;</code></pre><h2 id="HGET、HMGET"><a href="#HGET、HMGET" class="headerlink" title="HGET、HMGET"></a>HGET、HMGET</h2><ul><li>hget 获取单个 key 的值</li><li>hmget 一次获取多个 key 的值</li></ul><pre><code>&gt; hmget user:2 name email1) &quot;tom&quot;2) &quot;tom@qq.com&quot;</code></pre><h2 id="HEDL"><a href="#HEDL" class="headerlink" title="HEDL"></a>HEDL</h2><ul><li>删除一个或多个指定的key</li></ul><pre><code>&gt; hdel user:2 name(integer) 1&gt; hget user:2 name(nil)&gt; hget user:2 email&quot;tom@qq.com&quot;</code></pre><h2 id="HSETNX"><a href="#HSETNX" class="headerlink" title="HSETNX"></a>HSETNX</h2><ul><li>设置指定key的值，如果可以已经存在，则不进行任何操作</li></ul><pre><code>&gt; hsetnx user:2 email 2@qq.com(integer) 0&gt; hsetnx user:2 name tome(integer) 1&gt; hmget user:2 name email1) &quot;tome&quot;2) &quot;tom@qq.com&quot;</code></pre><h2 id="HVALS"><a href="#HVALS" class="headerlink" title="HVALS"></a>HVALS</h2><p>-返回所有格值</p><pre><code>&gt; hvals user:21) &quot;tom@qq.com&quot;2) &quot;tome&quot;</code></pre><h2 id="HKEYS"><a href="#HKEYS" class="headerlink" title="HKEYS"></a>HKEYS</h2><ul><li>返回所有的键</li></ul><pre><code>&gt; hkeys user:21) &quot;email&quot;2) &quot;name&quot;</code></pre><h2 id="HGETALL"><a href="#HGETALL" class="headerlink" title="HGETALL"></a>HGETALL</h2><ul><li>返回所有的键和值</li><li>返回值中，每个字段名的下一个就是他的值</li></ul><pre><code>&gt; hgetall user:21) &quot;email&quot;2) &quot;tom@qq.com&quot;3) &quot;name&quot;4) &quot;tome&quot;</code></pre><h2 id="HEXISTS"><a href="#HEXISTS" class="headerlink" title="HEXISTS"></a>HEXISTS</h2><ul><li>检查指定键是否存在</li></ul><pre><code>&gt; hexists user:2 class(integer) 0&gt; hexists user:2 email(integer) 1</code></pre><h2 id="HINCRBY"><a href="#HINCRBY" class="headerlink" title="HINCRBY"></a>HINCRBY</h2><ul><li>对哈希中指定的键进行自增操作，如果对应的键不存在，则创建。如果存在，直接新增</li><li>所操作的键的值必须为整型</li></ul><pre><code>&gt; hincrby user:2 old 1(integer) 1&gt; hgetall user:21) &quot;email&quot;2) &quot;tom@qq.com&quot;3) &quot;name&quot;4) &quot;tome&quot;5) &quot;sex&quot;6) &quot;man&quot;7) &quot;old&quot;8) &quot;1&quot;&gt; hincrby user:2 old 2(integer) 3&gt; hgetall user:21) &quot;email&quot;2) &quot;tom@qq.com&quot;3) &quot;name&quot;4) &quot;tome&quot;5) &quot;sex&quot;6) &quot;man&quot;7) &quot;old&quot;8) &quot;3&quot;&gt; hincrby user:2 name 1(error) ERR hash value is not an integer</code></pre><h2 id="HINCRBYFLOAT"><a href="#HINCRBYFLOAT" class="headerlink" title="HINCRBYFLOAT"></a>HINCRBYFLOAT</h2><ul><li>同上面的 hincrby，只不过支持的值是 float 类型</li></ul><h2 id="HLEN"><a href="#HLEN" class="headerlink" title="HLEN"></a>HLEN</h2><ul><li>返回指定哈希所包含的字段数量（key 的数量）</li></ul><pre><code>&gt; hlen user:2(integer) 4&gt; hgetall user:21) &quot;email&quot;2) &quot;tom@qq.com&quot;3) &quot;name&quot;4) &quot;tome&quot;5) &quot;sex&quot;6) &quot;man&quot;7) &quot;old&quot;8) &quot;3&quot;</code></pre><h2 id="HSTRLEN"><a href="#HSTRLEN" class="headerlink" title="HSTRLEN"></a>HSTRLEN</h2><ul><li>返回指定 key 的 value 的字符串长度</li><li>如果 value 或 哈希不存在，则返回0</li></ul><pre><code>&gt; hstrlen user:2 name(integer) 4&gt; hget user:2 name&quot;tome&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis学习笔记-----基本数据类型之集合</title>
      <link href="/2019/12/10/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%9B%86%E5%90%88/"/>
      <url>/2019/12/10/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="集合（Set）"><a href="#集合（Set）" class="headerlink" title="集合（Set）"></a>集合（Set）</h1><blockquote><p>与 list 类似，区别是 set 中的值是不重复的。</p></blockquote><h2 id="SADD"><a href="#SADD" class="headerlink" title="SADD"></a>SADD</h2><ul><li>将一个或多个member元素加入到集合key当中，已经存在于集合的member元素将被忽略。</li><li>假如key不存在，则创建一个只包含member元素作成员的集合。</li><li>当key不是集合类型时，返回一个错误。</li></ul><pre><code>&gt; sadd k1 v1 v2 v3(integer) 3</code></pre><h2 id="SMEMBERS"><a href="#SMEMBERS" class="headerlink" title="SMEMBERS"></a>SMEMBERS</h2><ul><li>返回集合key中的所有成员。</li></ul><pre><code>&gt; smembers k11) &quot;v2&quot;2) &quot;v3&quot;3) &quot;v1&quot;</code></pre><h2 id="SREM"><a href="#SREM" class="headerlink" title="SREM"></a>SREM</h2><ul><li>移除集合key中的一个或多个member元素，不存在的member元素会被忽略。</li><li>当key不是集合类型，返回一个错误。</li></ul><pre><code>&gt; srem k1 v2 v1(integer) 2&gt; smembers k11) &quot;v3&quot;</code></pre><h2 id="SISMEMBER"><a href="#SISMEMBER" class="headerlink" title="SISMEMBER"></a>SISMEMBER</h2><ul><li>判断 member 元素是否是集合 key 的成员。</li><li>返回 1，则 member 元素在集合中。返回 0，则不在集合中。</li></ul><pre><code>&gt; sismember k1 v3(integer) 1&gt; sismember k1 v2(integer) 0</code></pre><h2 id="SCARD"><a href="#SCARD" class="headerlink" title="SCARD"></a>SCARD</h2><ul><li>返回集合key的基数(集合中元素的数量)。</li></ul><pre><code>&gt; scard k1(integer) 1&gt; sadd k1 v4 v5(integer) 2&gt; scard k1(integer) 3</code></pre><h2 id="SMOVE"><a href="#SMOVE" class="headerlink" title="SMOVE"></a>SMOVE</h2><ul><li>将 member 元素从 source 集合移动到 destination 集合。</li><li>如果 source 集合不存在或不包含指定的 member 元素，则命令不执行任何操作，仅返回0。</li><li>当 destination 集合已经包含 member 元素时，则命令只是简单地将 source 集合中的 member 元素删除。</li><li>当source或destination不是集合类型时，返回一个错误。</li></ul><pre><code>&gt; smembers k11) &quot;v4&quot;2) &quot;v5&quot;3) &quot;v3&quot;&gt; smembers k2(empty list or set)&gt; smove k1 k2 v4(integer) 1&gt; smembers k11) &quot;v5&quot;2) &quot;v3&quot;&gt; smembers k21) &quot;v4&quot;</code></pre><h2 id="SPOP"><a href="#SPOP" class="headerlink" title="SPOP"></a>SPOP</h2><ul><li>移除并返回集合中的一个随机元素。</li><li>被移除的随机元素。</li><li>当key不存在或key是空集时，返回nil。</li></ul><pre><code>&gt; smembers k11) &quot;v5&quot;2) &quot;v3&quot;&gt; spop k1&quot;v3&quot;&gt; smembers k11) &quot;v5&quot;&gt; spop k1&quot;v5&quot;&gt; smembers k1(empty list or set)&gt; spop k1(nil)</code></pre><h2 id="SRANDMEMBER"><a href="#SRANDMEMBER" class="headerlink" title="SRANDMEMBER"></a>SRANDMEMBER</h2><ul><li>返回集合中的一个随机元素。(不删除)</li><li>返回值为被选中的随机元素。 当 key 不存在或 key 是空集时，返回nil。</li></ul><pre><code>&gt; sadd k1 v1 v2 v3(integer) 3&gt; smembers k11) &quot;v2&quot;2) &quot;v3&quot;3) &quot;v1&quot;&gt; srandmember k1&quot;v3&quot;&gt; smembers k11) &quot;v2&quot;2) &quot;v3&quot;3) &quot;v1&quot;</code></pre><h2 id="SINTER"><a href="#SINTER" class="headerlink" title="SINTER"></a>SINTER</h2><ul><li>返回给定的集合的交集。</li><li>当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。</li></ul><pre><code>&gt; smembers k11) &quot;v2&quot;2) &quot;v3&quot;3) &quot;v1&quot;&gt; smembers k21) &quot;v4&quot;2) &quot;v1&quot;3) &quot;v2&quot;4) &quot;v5&quot;5) &quot;v6&quot;&gt; sinter k1 k21) &quot;v2&quot;2) &quot;v1&quot;</code></pre><h2 id="SINTERSTORE"><a href="#SINTERSTORE" class="headerlink" title="SINTERSTORE"></a>SINTERSTORE</h2><ul><li>基本等同于 sinter 命令，但它将结果保存在一个新的集合里。</li><li>如果要保存的集合已经存在，则将其覆盖。</li><li>返回结果集合中成员的数量。</li></ul><pre><code>&gt; smembers k11) &quot;v2&quot;2) &quot;v3&quot;3) &quot;v1&quot;&gt; smembers k21) &quot;v4&quot;2) &quot;v1&quot;3) &quot;v2&quot;4) &quot;v5&quot;5) &quot;v6&quot;&gt; sinterstore k3 k1 k2(integer) 2&gt; smembers k31) &quot;v2&quot;2) &quot;v1&quot;</code></pre><h2 id="SUNION"><a href="#SUNION" class="headerlink" title="SUNION"></a>SUNION</h2><ul><li>返回给定的所有集合的并集。</li></ul><pre><code>&gt; smembers k11) &quot;v2&quot;2) &quot;v3&quot;3) &quot;v1&quot;&gt; smembers k21) &quot;v4&quot;2) &quot;v1&quot;3) &quot;v2&quot;4) &quot;v5&quot;5) &quot;v6&quot;&gt; sunion k1 k21) &quot;v4&quot;2) &quot;v3&quot;3) &quot;v1&quot;4) &quot;v2&quot;5) &quot;v5&quot;6) &quot;v6&quot;</code></pre><h2 id="SUNIONSTORE"><a href="#SUNIONSTORE" class="headerlink" title="SUNIONSTORE"></a>SUNIONSTORE</h2><ul><li>基本等同于 sunion 命令，但它将结果保存在一个新的集合里。</li><li>如果要保存的集合已经存在，则将其覆盖。</li><li>返回结果集合中成员的数量。</li></ul><pre><code>&gt; smembers k11) &quot;v2&quot;2) &quot;v3&quot;3) &quot;v1&quot;&gt; smembers k21) &quot;v4&quot;2) &quot;v1&quot;3) &quot;v2&quot;4) &quot;v5&quot;5) &quot;v6&quot;&gt; sunionstore k4 k1 k2(integer) 6&gt; smembers k41) &quot;v4&quot;2) &quot;v3&quot;3) &quot;v1&quot;4) &quot;v2&quot;5) &quot;v5&quot;6) &quot;v6&quot;</code></pre><h2 id="SDIFF"><a href="#SDIFF" class="headerlink" title="SDIFF"></a>SDIFF</h2><ul><li>返回给定的所有集合的差集。</li></ul><pre><code>&gt; smembers tom1) &quot;orange&quot;2) &quot;banner&quot;3) &quot;apple&quot;&gt; smembers jack1) &quot;pants&quot;2) &quot;t-shirt&quot;3) &quot;apple&quot;&gt; sdiff tom jack1) &quot;orange&quot;2) &quot;banner&quot;</code></pre><p>SDIFFSTORE</p><ul><li>基本等同于 sdiff 命令，但它将结果保存在一个新的集合里。</li><li>如果要保存的集合已经存在，则将其覆盖。</li><li>返回结果集合中成员的数量。</li></ul><pre><code>&gt; smembers tom1) &quot;orange&quot;2) &quot;banner&quot;3) &quot;apple&quot;&gt; smembers jack1) &quot;pants&quot;2) &quot;t-shirt&quot;3) &quot;apple&quot;&gt; sdiffstore new tom jack(integer) 2&gt; smembers new1) &quot;orange&quot;2) &quot;banner&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis学习笔记-----基本数据类型之列表</title>
      <link href="/2019/12/01/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%88%97%E8%A1%A8/"/>
      <url>/2019/12/01/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="List-列表"><a href="#List-列表" class="headerlink" title="List 列表"></a>List 列表</h1><h2 id="LPUSH、RPUSH、LRANGE"><a href="#LPUSH、RPUSH、LRANGE" class="headerlink" title="LPUSH、RPUSH、LRANGE"></a>LPUSH、RPUSH、LRANGE</h2><ul><li>lpush 可以将一个或多个值插入到列表的头部</li><li>rpush 可以将一个或多个值插入到列表的头部</li><li>lrange 从列表的头部查看列表，元素下标从 0 开始，-1 表示最后一个元素，-2 表示倒数第二个元素，以此类推</li></ul><pre><code>&gt; rpush mylist A    //将 A 插入到 mylist 列表的尾部(integer) 1&gt; rpush mylist B    //将 B 插入到 mylist 列表的尾部(integer) 2&gt; lpush mylist first    //将 first 插入到 mylist 列表的头部(integer) 3&gt; rpush mylist C D E    //将 C、D、E 插入到列表 mylist 的尾部(integer) 6&gt; lrange mylist 0 -1    //从列表的头部查看列表的全部内容1) &quot;first&quot;2) &quot;A&quot;3) &quot;B&quot;4) &quot;C&quot;5) &quot;D&quot;6) &quot;E&quot;&gt; lrange mylist 0 2 //从列表的头部查看 mylist 列表，从 0 开始，到 2 结束（元素下标从 0 开始，-1 表示最后一个元素，-2 表示倒数第二个元素，以此类推）1) &quot;first&quot;2) &quot;A&quot;3) &quot;B&quot;</code></pre><h2 id="LPOP、RPOP"><a href="#LPOP、RPOP" class="headerlink" title="LPOP、RPOP"></a>LPOP、RPOP</h2><ul><li>lpop 移除并返回头部元素</li><li>rpop 移除并返回尾部元素</li></ul><pre><code>&gt; lrange mylist 0 -11) &quot;first&quot;2) &quot;A&quot;3) &quot;B&quot;4) &quot;C&quot;5) &quot;D&quot;6) &quot;E&quot;&gt; lpop mylist       //移除头部元素，并返回该元素&quot;first&quot;&gt; lrange mylist 0 -11) &quot;A&quot;2) &quot;B&quot;3) &quot;C&quot;4) &quot;D&quot;5) &quot;E&quot;&gt; rpop mylist   //移除尾部元素，并返回该元素&quot;E&quot;&gt; lrange mylist 0 -11) &quot;A&quot;2) &quot;B&quot;3) &quot;C&quot;4) &quot;D&quot;&gt; rpop abc  //当 abc 列表不存在时，返回 nil(nil)</code></pre><h2 id="LINDEX"><a href="#LINDEX" class="headerlink" title="LINDEX"></a>LINDEX</h2><ul><li>返回列表指定下标的元素（下标从0开始，-1 为最后一个元素）</li></ul><pre><code>&gt; lrange mylist 0 -11) &quot;A&quot;2) &quot;B&quot;3) &quot;C&quot;4) &quot;D&quot;&gt; lindex mylist -1&quot;D&quot;&gt; lindex mylist 2&quot;C&quot;</code></pre><h2 id="LTRIM"><a href="#LTRIM" class="headerlink" title="LTRIM"></a>LTRIM</h2><ul><li>让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。下标与之前介绍的写法都一致，这里不赘述</li></ul><pre><code>&gt; lrange mylist 0 -11) &quot;A&quot;2) &quot;B&quot;3) &quot;C&quot;4) &quot;D&quot;&gt; ltrim mylist 0 1OK&gt; lrange mylist 0 -11) &quot;A&quot;2) &quot;B&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1、Redis 学习笔记————基本数据类型之字符串</title>
      <link href="/2019/11/27/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2019/11/27/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串（string）"><a href="#字符串（string）" class="headerlink" title="字符串（string）"></a>字符串（string）</h2><h3 id="SET、GET-基本操作"><a href="#SET、GET-基本操作" class="headerlink" title="SET、GET |基本操作"></a>SET、GET |基本操作</h3><ul><li>使用 set 关键字设置</li><li>使用 get 关键字获取字符串</li><li>值可以是任何类型的字符串（包括二进制，例如图片），值不能超过512 MB</li></ul><pre><code>&gt; set key valueOK&gt; get key&quot;value&quot;</code></pre><h3 id="APPEND-追加值"><a href="#APPEND-追加值" class="headerlink" title="APPEND |追加值"></a>APPEND |追加值</h3><ul><li>append 命令，如果 key 存在，则在 value 后追加值，不存在，则先创建一个 value 为空字符串的 key，然后在追加。</li></ul><pre><code>&gt; append haha 123(integer) 3&gt; get haha&quot;123&quot;&gt; append haha 456(integer) 6&gt; get haha&quot;123456&quot;</code></pre><h3 id="MSET-一次存储或获取多个-key"><a href="#MSET-一次存储或获取多个-key" class="headerlink" title="MSET |一次存储或获取多个 key"></a>MSET |一次存储或获取多个 key</h3><pre><code>&gt; mset a 10 b 20 c 30OK&gt; mget a b c1) &quot;10&quot;2) &quot;20&quot;3) &quot;30&quot;</code></pre><h3 id="GETSET-获取原值并赋予新值"><a href="#GETSET-获取原值并赋予新值" class="headerlink" title="GETSET |获取原值并赋予新值"></a>GETSET |获取原值并赋予新值</h3><ul><li>获取 key 原有的值，并赋予新值</li></ul><pre><code>&gt; set num 100OK&gt; getset num 50&quot;100&quot;&gt; get num&quot;50&quot;</code></pre><h3 id="EXISTS、DEL-删除键、检查键是否存在"><a href="#EXISTS、DEL-删除键、检查键是否存在" class="headerlink" title="EXISTS、DEL |删除键、检查键是否存在"></a>EXISTS、DEL |删除键、检查键是否存在</h3><ul><li>删除成功返回 1，失败返回 0</li><li>存在返回 1，不存在返回 0</li></ul><pre><code>&gt; set abc 123OK&gt; exists def(integer) 0&gt; exists abc(integer) 1&gt; del def(integer) 0&gt; del abc(integer) 1</code></pre><h3 id="TYPE-查看数据类型操作命令"><a href="#TYPE-查看数据类型操作命令" class="headerlink" title="TYPE |查看数据类型操作命令"></a>TYPE |查看数据类型操作命令</h3><ul><li>查询的键存在返回相应的数据类型，不存在返回 none</li></ul><pre><code>&gt; set hello wordOK&gt; type hellostring&gt; type wordnone</code></pre><h3 id="SETEX、TTL、PSETEX、PTTL-设置过期时间（1-秒-1000-毫秒）"><a href="#SETEX、TTL、PSETEX、PTTL-设置过期时间（1-秒-1000-毫秒）" class="headerlink" title="SETEX、TTL、PSETEX、PTTL |设置过期时间（1 秒 = 1000 毫秒）"></a>SETEX、TTL、PSETEX、PTTL |设置过期时间（1 秒 = 1000 毫秒）</h3><ul><li>使用 setex 设置以秒为单位的过期时间</li><li>使用 psetex 设置以毫秒为单位的过期时间</li><li>使用 ttl 获取以秒为单位的剩余时间</li><li>使用 pttl 获取以毫秒为单位的剩余时间<blockquote><p><strong>使用 ttl 和 pttl 查询键的过期时间，键不存在返回 -2，没有设置过期时间返回 -1，其他情况返回以秒为单位的剩余时间</strong></p></blockquote></li></ul><pre><code>// 秒为单位&gt; setex hello 10 11111OK&gt; ttl hello(integer) 6&gt; ttl hello(integer) 4&gt; ttl hello(integer) 3&gt; get hello(nil)</code></pre><pre><code>//毫秒为单位&gt; psetex test 10000 1111OK&gt; pttl test(integer) 8455&gt; pttl test(integer) 7430&gt; pttl test(integer) 6733&gt; get test(nil)</code></pre><h3 id="INCR、INCRBY、DECR、DECRBY-原子递增递减"><a href="#INCR、INCRBY、DECR、DECRBY-原子递增递减" class="headerlink" title="INCR、INCRBY、DECR、DECRBY |原子递增递减"></a>INCR、INCRBY、DECR、DECRBY |原子递增递减</h3><ul><li>set 一个值为整型的字符串，可以使用 incr 操作命令自增</li><li>可以使用 incrby 操作命令指定步长自增</li><li>incr 是原子操作。也就是说客户端 1 和客户端 2 同时读出10，他们俩都对其加 1 操作，最终的值一定是12。</li><li>相应的有 decr 和 decrby 操作命令进行递减操作</li></ul><pre><code>&gt; set count 100OK&gt; incr count(integer) 101&gt; incr count(integer) 102&gt; incrby count 100(integer) 202</code></pre><h3 id="SETNX-不存在则设置，存在则不进行任何操作"><a href="#SETNX-不存在则设置，存在则不进行任何操作" class="headerlink" title="SETNX |不存在则设置，存在则不进行任何操作"></a>SETNX |不存在则设置，存在则不进行任何操作</h3><ul><li>set 命令在执行的时候，如果 key 已经存在，则新值会覆盖旧值。</li><li>setnx 命令，如果 key 存在，则不做任何操作，否则等同于 set。</li></ul><pre><code>&gt; set test 123OK&gt; set test 456OK&gt; get test&quot;456&quot;&gt; setnx test aaa(integer) 0&gt; get test&quot;456&quot;</code></pre><h3 id="STRLEN-计算-value-的长度"><a href="#STRLEN-计算-value-的长度" class="headerlink" title="STRLEN | 计算 value 的长度"></a>STRLEN | 计算 value 的长度</h3><pre><code>&gt; set xixi abc123OK&gt; strlen xixi(integer) 6</code></pre>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的三十岁</title>
      <link href="/2019/09/27/%E6%88%91%E7%9A%84%E4%B8%89%E5%8D%81%E5%B2%81/"/>
      <url>/2019/09/27/%E6%88%91%E7%9A%84%E4%B8%89%E5%8D%81%E5%B2%81/</url>
      
        <content type="html"><![CDATA[<blockquote><p>没有想到时间过的这么快，就这么来到了三十岁的生日，总觉得需要记录点什么。</p></blockquote><p>没有想三十岁来的这么快，自己还没有完全做好准备。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用LaraDock配置laravel-echo-sever遇到的坑</title>
      <link href="/2019/08/15/%E4%BD%BF%E7%94%A8LaraDock%E9%85%8D%E7%BD%AElaravel-echo-sever%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
      <url>/2019/08/15/%E4%BD%BF%E7%94%A8LaraDock%E9%85%8D%E7%BD%AElaravel-echo-sever%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前情提要：项目需要使用 webSocket 进行通信，并且使用的是 <a href="https://laradock.io/" target="_blank" rel="noopener">LaraDock</a> 作为环境。所以使用 laravel-echo-server、laravel-horizon、php-worker 容器进行环境的部署。因为对 Docker 并不懂，仅仅只是使用 LaraDock，所以过程中遇到了很多问题，特此记录下来。</p></blockquote><h2 id="坑二-参考资料"><a href="#坑二-参考资料" class="headerlink" title="坑二 参考资料"></a>坑二 <a href="https://github.com/laradock/laradock/issues/1340#issuecomment-390484505" target="_blank" rel="noopener">参考资料</a></h2><blockquote><p>LaraDock 的 Nginx 使用多站点配置的时候，laravel-echo-server 无法链接到 web 进行认证。</p></blockquote><p>通过在 nginx 容器配置中添加别名 <strong> laradock/docker-compose.yml </strong></p><pre class=" language-yml"><code class="language-yml">### NGINX Server #########################################    nginx:      build:        context: ./nginx        args:          - PHP_UPSTREAM_CONTAINER=${NGINX_PHP_UPSTREAM_CONTAINER}          - PHP_UPSTREAM_PORT=${NGINX_PHP_UPSTREAM_PORT}      volumes:        - ${APP_CODE_PATH_HOST}:${APP_CODE_PATH_CONTAINER}        - ${NGINX_HOST_LOG_PATH}:/var/log/nginx        - ${NGINX_SITES_PATH}:/etc/nginx/sites-available      ports:        - "${NGINX_HOST_HTTP_PORT}:80"        - "${NGINX_HOST_HTTPS_PORT}:443"      depends_on:        - php-fpm      networks:        # before ----        # - frontend        # - backend        # end before ----        frontend:        backend:            aliases:              - my-site.com    ##别名地址，在laravel-echo-server.json 中填写该地址就可以了</code></pre><p>更改完配置之后需要重新构建 nginx 和 laravel-echo-server 容器。<br>并重新开启。</p><h2 id="坑二"><a href="#坑二" class="headerlink" title="坑二"></a>坑二</h2><blockquote><p>larave-echo-server 的 ssl 证书</p></blockquote><ol><li>直接配置 ssl 证书。（不明白证书需要发在目录的什么位置，所以 google 了很多内容之后选择了下面的方法。以后如果有机会补充第一点）</li><li>配置 nginx 反向代理。 <a href="https://github.com/tlaverdure/laravel-echo-server" target="_blank" rel="noopener">laravel-echo-server</a></li></ol><pre class=" language-nginx"><code class="language-nginx"><span class="token comment" spellcheck="true">#以下内容需要在你的 nginx 站点配置文件的 server{} 块之内</span><span class="token keyword">location</span> <span class="token operator">/</span>socket<span class="token punctuation">.</span>io <span class="token punctuation">{</span>        <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>laravel<span class="token operator">-</span>echo<span class="token operator">-</span><span class="token keyword">server</span><span class="token punctuation">:</span><span class="token number">6001</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">#填写非 https 的地址进行反向代理，如果 Echo 和 Nginx 在同一个服务器可以填写 localhost</span>        <span class="token keyword">proxy_http_version</span> <span class="token number">1.1</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> Upgrade <span class="token variable">$http_upgrade</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> Connection <span class="token string">"Upgrade"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ol start="3"><li>配置 laravel-echo-server 配置文件 laravel-echo-server.json 为如下内容</li></ol><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>        <span class="token property">"authHost"</span><span class="token operator">:</span> <span class="token string">"https://laravel-echo-server"</span><span class="token punctuation">,</span> //注意：改地址指向 web 站点，即 echo-server 想web端认证的地址        <span class="token property">"authEndpoint"</span><span class="token operator">:</span> <span class="token string">"/broadcasting/auth"</span><span class="token punctuation">,</span>        <span class="token property">"clients"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token property">"database"</span><span class="token operator">:</span> <span class="token string">"redis"</span><span class="token punctuation">,</span>        <span class="token property">"databaseConfig"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                <span class="token property">"redis"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                        <span class="token property">"port"</span><span class="token operator">:</span> <span class="token string">"6379"</span><span class="token punctuation">,</span>                        <span class="token property">"host"</span><span class="token operator">:</span> <span class="token string">"redis"</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token property">"devMode"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token property">"host"</span><span class="token operator">:</span> <span class="token null">null</span><span class="token punctuation">,</span>        <span class="token property">"port"</span><span class="token operator">:</span> <span class="token string">"6001"</span><span class="token punctuation">,</span>        <span class="token property">"protocol"</span><span class="token operator">:</span> <span class="token string">"http"</span><span class="token punctuation">,</span>        <span class="token property">"socketio"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token property">"sslCertPath"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>        <span class="token property">"sslKeyPath"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">}</span></code></pre><h2 id="操作技巧"><a href="#操作技巧" class="headerlink" title="操作技巧"></a>操作技巧</h2><ol><li>不使用 -d 参数可以更好的进行调试<pre class=" language-shell"><code class="language-shell">docker-compose up laravel-echo-server</code></pre></li><li>使用 logs 参数可以查看详情的日志输出<pre class=" language-shell"><code class="language-shell">docker-compose logs laravel-echo-server</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境 </tag>
            
            <tag> LaraDock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel学习笔记</title>
      <link href="/2019/06/18/Laravel%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/06/18/Laravel%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="第一步：了解几个常用名称"><a href="#第一步：了解几个常用名称" class="headerlink" title="第一步：了解几个常用名称"></a>第一步：了解几个常用名称</h2><blockquote><p>代码基于 Laravel-5.8 部分内容给其他版本不一致，但整体逻辑是没有太大差别的。</p></blockquote><blockquote><p>Service Container、Service Provider、Facades、Contracts。当第一次使用 Laravel 框架的时候被这几个词直接搞蒙圈了，完全不知道是什么意思，尤其是在看完文档之后，真的想说 WTF 。不过不知道也不会太影响使用。（😅有个朋友说过，不管用着在 NB 的框架，依然可以写出屎一样的代码）</p></blockquote><h3 id="Service-Container"><a href="#Service-Container" class="headerlink" title="Service Container"></a>Service Container</h3><p>中文解释：服务容器 （😂 是不是看完这个翻译更不知道是啥了）</p><p>我的理解：一个装着各种各样的服务实例的容器。这些服务就是 Laravel 中的各种模块，如 Redis、Route 等等。</p><p>实现一个简单的容器：</p><pre class=" language-php"><code class="language-php"><span class="token keyword">class</span> <span class="token class-name">Container</span><span class="token punctuation">{</span>  <span class="token keyword">protected</span> <span class="token variable">$binds</span><span class="token punctuation">;</span>  <span class="token keyword">protected</span> <span class="token variable">$instances</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token variable">$abstract</span><span class="token punctuation">,</span> <span class="token variable">$concrete</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//Todo: 向 container 添加一种对象的的生产方式</span>    <span class="token comment" spellcheck="true">//$abstract: 第一个参数 $abstract, 一般为一个字符串(有时候也会是一个接口), 当你需要 make 这个类的对象的时候, 传入这个字符串(或者接口), 这样make 就知道制造什么样的对象了</span>    <span class="token comment" spellcheck="true">//$concrete: 第二个参数 $concrete, 一般为一个 Closure 或者 一个单例对象, 用于说明制造这个对象的方式</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$concrete</span> <span class="token keyword">instanceof</span> <span class="token class-name">Closure</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">binds</span><span class="token punctuation">[</span><span class="token variable">$abstract</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$concrete</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">instances</span><span class="token punctuation">[</span><span class="token variable">$abstract</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$concrete</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token variable">$abstract</span><span class="token punctuation">,</span> <span class="token variable">$parameters</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//Todo: 生产一种对象</span>    <span class="token comment" spellcheck="true">//$abstract: 在bind方法中已经介绍过</span>    <span class="token comment" spellcheck="true">//$parameters: 生产这种对象所需要的参数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">instances</span><span class="token punctuation">[</span><span class="token variable">$abstract</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">instances</span><span class="token punctuation">[</span><span class="token variable">$abstract</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">array_unshift</span><span class="token punctuation">(</span><span class="token variable">$parameters</span><span class="token punctuation">,</span> <span class="token variable">$this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">call_user_func_array</span><span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">binds</span><span class="token punctuation">[</span><span class="token variable">$abstract</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token variable">$parameters</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="为什么理解-IOC-Container-对于理解-Laravel-架构是如此的重要？"><a href="#为什么理解-IOC-Container-对于理解-Laravel-架构是如此的重要？" class="headerlink" title="为什么理解 IOC Container 对于理解 Laravel 架构是如此的重要？"></a>为什么理解 IOC Container 对于理解 Laravel 架构是如此的重要？</h4><blockquote><p>因为在 Laravel 中，你所能使用到的 Laravel 的特性和功能几乎全部是由 IOC Container 实现的。</p></blockquote><pre class=" language-php"><code class="language-php">Cache<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> Route<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token string">'HomeController@index'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面的 Cache、Route 都是通过把各自类的实现 bind 到 Container 中，然后 Container make 出的一个实例。<br>那么它们是在哪里进行的 bind 呢？没错就是 Service Provider 中。</p><h3 id="Service-Provider"><a href="#Service-Provider" class="headerlink" title="Service Provider"></a>Service Provider</h3><p>在 Laravel 中有两种方式来使用 IOC Container：</p><ol><li>通过 Service Provider</li><li>不通过 Service Provider<blockquote><p>一般情况都是使用第一种方式。</p></blockquote></li></ol><h4 id="不通过-Service-Provider-来使用-IOC-Container"><a href="#不通过-Service-Provider-来使用-IOC-Container" class="headerlink" title="不通过 Service Provider 来使用 IOC Container"></a>不通过 Service Provider 来使用 IOC Container</h4><p>实例：</p><pre class=" language-php"><code class="language-php"><span class="token comment" spellcheck="true">//web.php</span><span class="token comment" spellcheck="true">//创建一个类</span><span class="token keyword">class</span> <span class="token class-name">Apple</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token variable">$id</span> <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Route<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//使用 app() 辅助方法将 Apple 类 bind 到 IOC Container 中  </span>  App<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Apple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//使用 App() 辅助方法将 Apple 实例 make 出来</span>  <span class="token variable">$apple</span> <span class="token operator">=</span> App<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//使用 Apple 类中的属性</span>  <span class="token keyword">return</span> <span class="token variable">$apple</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">id</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="通过-Service-Provider-来使用-IOC-Container"><a href="#通过-Service-Provider-来使用-IOC-Container" class="headerlink" title="通过 Service Provider 来使用 IOC Container"></a>通过 Service Provider 来使用 IOC Container</h4><blockquote><p>原因：我们知道，有时候我们的类、模块会有需要其他类和组件的情况，为了保证初始化阶段不会出现所需要的模块和组件没有注册的情况，laravel 将注册和初始化行为进行拆分，注册的时候就只能注册，初始化的时候就是初始化。拆分后的产物就是现在的 服务提供者。<br>可以想象这样一个场景，你要绑定 3 个类 A B C 到 IOC Container 中。 A，B，C 都是非常复杂的类。在 bind A 时，引用了一个类 B 的实例，那么想要获得类 B 的实例，就需要 B 已经被 bind，只有这样，我们的 IOC Container 才有能力 make 出一个 B 的实例。 而在 bind B 时，恰好又需要 C 的实例.<br>如果是这样的逻辑，那么在 bind A B C 时，就必须手动的严格安排 bind 的次序，而且这只是 3 个类的情况，如果有几十个类的话，人工已经无法完成了.<br>而这时就需要 Service Provider 的作用了。</p><blockquote><p>引用自——<a href="https://learnku.com/laravel/t/3361/starting-with-the-1-line-of-code-with-a-systematic-understanding-of-the-core-concepts-of-service-container#e9b441" target="_blank" rel="noopener">从 1 行代码开始，带你系统性地理解 Service Container 核心概念</a></p></blockquote></blockquote><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token comment" spellcheck="true">// 1. 创建一个 Apple 类 app/Test/Apple.php</span><span class="token keyword">namespace</span> <span class="token package">App<span class="token punctuation">\</span>Test</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Apple</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token variable">$id</span> <span class="token operator">=</span> <span class="token string">'agg'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//2. 使用 php artisan make:provider AppleProvider 生成 provider</span><span class="token keyword">namespace</span> <span class="token package">App<span class="token punctuation">\</span>Providers</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token package">Illuminate<span class="token punctuation">\</span>Support<span class="token punctuation">\</span>ServiceProvider</span><span class="token punctuation">;</span><span class="token keyword">use</span> <span class="token package">App<span class="token punctuation">\</span>Test<span class="token punctuation">\</span>Apple</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">AppleProvider</span> <span class="token keyword">extends</span> <span class="token class-name">ServiceProvider</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * Register services.     *     * @return void     */</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">register</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">app</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">singleton</span><span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token variable">$app</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Apple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Bootstrap services.     *     * @return void     */</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">boot</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 3. 在 config/app.php 中注册 APPServiceProvider</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token string">'providers'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    App\<span class="token package">Providers<span class="token punctuation">\</span>AppleProvider</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">class</span><span class="token punctuation">,</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment" spellcheck="true">// 4. 最终在 route/web.php 中使用</span>Route<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">app</span><span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token function">app</span><span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*输出结果，因为使用了单例的模式进行绑定所以输出的两个实例的编号是一致的object(App\Test\Apple)#206 (1) { ["id"]=> string(3) "agg" } object(App\Test\Apple)#206 (1) { ["id"]=> string(3) "agg" }*/</span></code></pre><h3 id="Facades"><a href="#Facades" class="headerlink" title="Facades"></a>Facades</h3><pre class=" language-php"><code class="language-php">Route<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token string">'HomeController@index'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>想必大家在第一使用 Laravel 的时候一定会注意到这行代码。在使用 phpStorm 之类的 IDE 工具是无法跳转到对应的类文件。那么这是为啥呢？</p></blockquote><p>你是无法找到对 Route 类的声明的，是因为使用了别名。别名是 PHP 的一个特性（ <a href="https://www.php.net/manual/zh/function.class-alias.php" target="_blank" rel="noopener">class_alias</a> 方法 ）。</p><p>别名在哪里设置呢——app/config/app.php</p><pre class=" language-php"><code class="language-php"><span class="token string">'aliases'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token string">'Route'</span> <span class="token operator">=</span><span class="token operator">></span> Illuminate\<span class="token package">Support<span class="token punctuation">\</span>Facades<span class="token punctuation">\</span>Route</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">class</span><span class="token punctuation">,</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><p>查看 <em>vendor/laravel/framework/src/Illuminate/Support/Facades/Route.php</em> 文件….哎？怎么只有这么点东西，get 呢？</p><pre class=" language-php"><code class="language-php"><span class="token keyword">namespace</span> <span class="token package">Illuminate<span class="token punctuation">\</span>Support<span class="token punctuation">\</span>Facades</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*   通过这行注释可以找到真实的 Route 类在什么地方 * @see \Illuminate\Routing\Router */</span><span class="token keyword">class</span> <span class="token class-name">Route</span> <span class="token keyword">extends</span> <span class="token class-name">Facade</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * Get the registered name of the component.     *     * @return string     */</span>    <span class="token keyword">protected</span> <span class="token keyword">static</span> <span class="token keyword">function</span> <span class="token function">getFacadeAccessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">'router'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>首先要知道 Facade 的作用：使用一个简单的语法，让你从 Laravel 的 IOC Container 中方便的 make 出你想要的对象。</p></blockquote><h4 id="Facade-实现原理（make）"><a href="#Facade-实现原理（make）" class="headerlink" title="Facade 实现原理（make）"></a>Facade 实现原理（make）</h4><ol><li>首先 Route 继承自 <code>Illuminate\Support\Facades</code>。</li><li><code>Illuminate\Support\Facades</code> 里也没有 get 静态方法。</li><li>使用了 <a href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.callstatic" target="_blank" rel="noopener">__callStatic()</a> 魔术方法。</li><li>在 Route 中调用静态的 get 方法，实际上 Illuminate\Support\Facades 中的 <code>__callStatic</code> 魔术方法被调用。</li><li>在 <a href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.callstatic" target="_blank" rel="noopener">__callStatic()</a> 方法中调用了静态的 getFaRoot 方法。</li><li>在 <code>getFacadeRoot</code> 方法中调用了静态的 <code>resolveFacadeInstance</code> 方法。</li><li><code>resolveFacadeInstance</code> 方法需要传递一个参数，该参数通过静态 <code>getFacadeAccessor</code> 方法获得。</li><li><code>getFacadeAccessor</code> 该方法在 Route 类中实现了 <code>getFacadeAccessor</code>并返回 route。</li><li><code>resolveFacadeInstance</code> 方法接收 route 字符串参数。首先判断是否为对象，当然不是啦，$name 是字符串。 然后判断该 <code>resolvedInstance</code> 数组中是否存在 route 相关信息，因为我们的程序是第一次运行当然也是没有的。 最后返回 <code>static::$app[&#39;route&#39;]</code>,同时把结果保存到 <code>resolvedInstance</code> 数组中。</li><li>$app 其实就是前面说的 Application 类的实例对象，这个类是一个 IOC Container，实例化过程在 Laravel 最开始的时候。Facade 初始化的时候也让自己有了一个 $app,这个就是 Application 类的实例化对象。</li><li>其实此时 $app 中并没有 ‘route’ 属性，那么为什么可以调用呢？因为 Application 继承了 Container, 而 Container 又继承了 ArrayAccess 类,并实现了 offsetGet 方法。 该方法的内容为 <code>return $this-&gt;make($key);</code> 这里就很明显了，直接make 出了一个 route 实例。</li><li>最终相当于 <code>$instance = static::getFacadeRoot();</code> 与 <code>$instance = $app-&gt;make(&#39;router&#39;);</code> 是相等的。</li></ol><pre class=" language-php"><code class="language-php">    <span class="token comment" spellcheck="true">//Illuminate\Support\Facades\Facades.php;</span>    <span class="token comment" spellcheck="true">//以上内容省略</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">function</span> <span class="token function">getFacadeRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">static</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">resolveFacadeInstance</span><span class="token punctuation">(</span><span class="token keyword">static</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getFacadeAccessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">//该方法被子类复写</span>    <span class="token keyword">protected</span> <span class="token keyword">static</span> <span class="token keyword">function</span> <span class="token function">getFacadeAccessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">'Facade does not implement getFacadeAccessor method.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> <span class="token keyword">static</span> <span class="token keyword">function</span> <span class="token function">resolveFacadeInstance</span><span class="token punctuation">(</span><span class="token variable">$name</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_object</span><span class="token punctuation">(</span><span class="token variable">$name</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token variable">$name</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token keyword">static</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$resolvedInstance</span><span class="token punctuation">[</span><span class="token variable">$name</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">static</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$resolvedInstance</span><span class="token punctuation">[</span><span class="token variable">$name</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">static</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$resolvedInstance</span><span class="token punctuation">[</span><span class="token variable">$name</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">static</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token variable">$app</span><span class="token punctuation">[</span><span class="token variable">$name</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">//以下内容省略 </span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">function</span> <span class="token function">__callStatic</span><span class="token punctuation">(</span><span class="token variable">$method</span><span class="token punctuation">,</span> <span class="token variable">$args</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$instance</span> <span class="token operator">=</span> <span class="token keyword">static</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getFacadeRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token variable">$instance</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">'A facade root has not been set.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token variable">$instance</span><span class="token operator">-</span><span class="token operator">></span><span class="token variable">$method</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token variable">$args</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h4 id="Facade-实现原理（bind）"><a href="#Facade-实现原理（bind）" class="headerlink" title="Facade 实现原理（bind）"></a>Facade 实现原理（bind）</h4><blockquote><p>在最开始就了解到，既然要 make，必须首先 bind。而且最好的方式是通过 serviceProvider 来 bind 类。 而且不论是 make 还是 bind 都需要一个 key，用来在容器中保存和查找这个类。上面讲的是使用 route 关键字进行 make 的过程。那么我们可以肯定在之前一定有一个使用 route 进行 bind 的操作。下面就进行 bind 的讲解。</p></blockquote><ol><li>首先 ServiceProvider 需要在 <code>config/app.php</code> 进行注册，我们在文件中找到对应 route 相关的内容，就是 <code>App\Providers\RouteServiceProvider::class,</code>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> laravel </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网易云音乐评论摘录</title>
      <link href="/2019/05/28/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E8%AF%84%E8%AE%BA%E6%91%98%E5%BD%95/"/>
      <url>/2019/05/28/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E8%AF%84%E8%AE%BA%E6%91%98%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>网易云音乐里有才的人实在太多，写出来的歌词或评论是真的不错。这里就把我觉得还不错的收藏一波吧（不定期更新）。</p><h2 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h2><blockquote><p>人会长大三次：<br>第一次是在发现自己不是世界的中心的时候。<br>第二次是在发现即使在怎么努力，终究还是有些事令人无能为力的时候。<br>第三次是在，明知道有些事可能会无能为力，但还是会尽力争取的时候。<br>————《一如少年模样》</p></blockquote><blockquote><p>白天要好好读书 书里有您不知道的<br>夜里要好好睡觉 梦里有你想要的<br>————《他》</p></blockquote><blockquote><p>你哭的最伤心的那个晚上变成大人了么？不是，是我忍住没哭的那个晚上。<br>————林宥嘉《天真有邪》</p></blockquote><blockquote><p>小时候，把一片口香糖掰成两块儿，很舍不得吃。那时候就天真的想，等我长大了，有钱了，就一口气嚼一包！一定特别甜！今天突然想到了儿时的这个梦想，就买了一包，当我把口香糖一片片塞进嘴里的时候，我的眼泪夺目而出。。。我哽咽着大口的嚼着。。。心里却满是酸楚，我想，这时光一点也不甜。。。<br>————周传雄《黄昏》 </p></blockquote><blockquote><p>爱上一个人，始于颜值，陷于才华，忠于人品；爱上一首歌，始于歌名，陷于旋律，忠于词义。</p></blockquote><blockquote><p>当我孑然一身的时候，贫穷与我不过是晚上吃馒头还是牛排的问题，无损我的快乐，当但我爱上一个姑娘的时候，我才深深感受到了贫穷所带来的自卑。</p></blockquote><blockquote><p>古代药房门口会挂着：<br>但愿世上无疾苦，宁可架上药生尘。<br>现在药房门口贴着：<br>会员积分，买十赠五，消费满58送20个鸡蛋。<br>————《只要平凡》</p></blockquote><blockquote><p>月老，麻烦下次为我牵红线的时候能换成钢丝吗，红线老TM断。<br>————《猫都瞧不起我》</p></blockquote><blockquote><p>我告诉你我喜欢你，并不是一定要和你在一起，只是希望今后的您，在遭遇人生低谷的时候，不要灰心，至少曾经有人被你的魅力所吸引，曾经是，以后也会是。<br>————《我要你》</p></blockquote><h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><blockquote><p>你是我患得患失的梦 我是你可有可无的人 毕竟这穿越山河的剑 刺的都是用情至极的人 你是我辗转反侧的梦 我是你如梦山河的古人<br>————解忧少帅《写给黄淮》</p></blockquote><blockquote><p>像我这样优秀的人 本该灿烂过一生 怎么二十多年到头来 还在人海里浮沉<br>———— 毛不易《像我这样的人》</p></blockquote><blockquote><p>可是你曾经的那些梦，都已变得模糊看不见，那些为了理想的战斗，也不过是为了钱。<br>我不要在失败孤独中死去，我不要一直活在地下里，物质的骗局，匆匆的蚂蚁，没有文化的人不伤心。<br>———— 新裤子乐队《没有理想的人不伤心》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令总结</title>
      <link href="/2019/04/06/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2019/04/06/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>内容不定期更新</p></blockquote><h2 id="自己常用的-git-alias-可以在命令行中更好的显示-log-信息"><a href="#自己常用的-git-alias-可以在命令行中更好的显示-log-信息" class="headerlink" title="自己常用的 git alias 可以在命令行中更好的显示 log 信息"></a>自己常用的 git alias 可以在命令行中更好的显示 log 信息</h2><pre class=" language-shell"><code class="language-shell">alias gl="git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit"alias gll="git log --graph --abbrev-commit --decorate --all --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(dim white) - %an%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n %C(white)%s%C(reset)'"</code></pre><h2 id="1-git-commit-–amend"><a href="#1-git-commit-–amend" class="headerlink" title="1. git commit –amend"></a>1. git commit –amend</h2><pre class=" language-git"><code class="language-git">git commit --amend</code></pre><blockquote><p>解释：当第一次 commit 之后，发现没有修改正确，但是又不想在 git log 中出现两次提交记录，那么在第二次修改后，可以使用 git commit –amend 命令进行修改提交。此时提交成功后就只有一条 commit 记录了。</p></blockquote><h2 id="2-gitignore-生效"><a href="#2-gitignore-生效" class="headerlink" title="2. gitignore 生效"></a>2. gitignore 生效</h2><blockquote><p>解释: .gitignore 文件是忽略 git 项目中不需要提交的内容的配置文件。但是当某次提交的时候把不需要的内容提交到 git 版本控制中了之后。再想修改 .gitignore 文件来忽略那个文件的话是不会生效的。需要先想文件在 git 缓存中删除，然后在进行提交。就可以了。（下面是操作步骤）</p></blockquote><pre class=" language-git"><code class="language-git">git rm -r --cached .   //如何是目录的话，增加 -r 参数git add .git commit -m <span class="token string">'fix ignore'</span>//删除指定文件的缓存git rm --cached xx.html</code></pre><h2 id="3-git-reset-–soft-hard-hash"><a href="#3-git-reset-–soft-hard-hash" class="headerlink" title="3. git reset –soft/hard  hash*"></a>3. git reset –soft/hard  <strong>hash*</strong></h2><pre class=" language-git"><code class="language-git">git reset --soft  **hash***git reset --hard  **hash***</code></pre><blockquote><p>解释：当执行 git commit 之后，想回到之前的版本，可以使用 git reset 进行版本回退。–sorf 参数的意思是，git log 撤销版本，但代码中的内容没有回退。 –hard 参数的意思是，git log 中的记录和 文件内容完全回退到选的的版本。（–hard 更常用）</p></blockquote><h2 id="4-git-stash"><a href="#4-git-stash" class="headerlink" title="4. git stash"></a>4. git stash</h2><pre class=" language-git"><code class="language-git">git stash           //将当前工作去内容进行暂存，然后就进行切换分支或其他的操作了git stash list      //查看当前已经暂存的记录列表git stash pop       //将当前暂存内容回复到工作区并删除暂存记录列表中的内容git stash apply     //将当前暂存内容回复到工作区，不删除记录</code></pre><h2 id="5-git-rebase-变基"><a href="#5-git-rebase-变基" class="headerlink" title="5. git rebase (变基)"></a>5. git rebase (变基)</h2><blockquote><p>解释：当在两个分支进行操作的时候，一般我们使用 merge 将两个分支进行合并，但是这样会产生一个新的提交，并且另一个分支的提交记录在当前分支是不存在的。为了解决这个问题，可以使用 rebase。</p></blockquote><pre class=" language-git"><code class="language-git">//前提：master 分支和 new-feature 分支都进行了多次提交git checkout new-feature        //首先切换到新分支git rebase master               //将 master 分支的提交记录添加到当前分支git checkout master             //切换回 master 分支git merge new-feature           //将 new-feature 分支合并入master，此时 master 分支中就有了 new-feature 分支的提交记录，但是不会产生新的提交记录。此命令可以使提交历史更为整洁。</code></pre>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用frp搭建本地微信开发环境</title>
      <link href="/2019/03/08/%E4%BD%BF%E7%94%A8frp%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2019/03/08/%E4%BD%BF%E7%94%A8frp%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>2019-3-10</strong> 更新记录</p></blockquote><p>再使用 TP5 进行开发的时候需要注意一下几点</p><ol><li>关闭 trace 调试模式。</li><li>在使用路由的时候尽量确定对应接口请求的类型，如果不知道类型建议使用 <strong>Route::any()</strong>;</li></ol><p><em>可以使用 <a href="http://www.fangbei.org/tool/message" target="_blank" rel="noopener">微信消息测试工具</a>进行测试</em>。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>之前在做相关微信开发时，因为需要验证公网可以访问的到的域名，所以总是将代码推到线上服务器进行相关的测试。每次有些小改动也要进本地代码推送到服务器，服务器拉取最新代码这种重复性的操作，感觉十分繁琐，一直想找一个简单方便的方式进行微信本地环境的开发。😓 无奈之前自己太懒了……总是拖。最近几天好好研究了下特此记录下来。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>一台公网可以访问的服务器（或使用海外服务器）。</li><li>一个已经备案的域名。</li><li>内网穿透工具 <a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">frp</a></li></ol><h2 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h2><h3 id="下载-frp"><a href="#下载-frp" class="headerlink" title="下载 frp"></a>下载 frp</h3><p>下载对应系统的 <a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">frp</a> 包。因为我的公网服务器是 centOS6-x64 所以下载了 <code>frp_0.24.1_linux_amd64.tar.gz</code> 包。</p><h3 id="配置-frp-服务端"><a href="#配置-frp-服务端" class="headerlink" title="配置 frp 服务端"></a>配置 frp 服务端</h3><ol><li>在服务器上解压下载好的 frp 包。</li></ol><pre class=" language-bash"><code class="language-bash"> <span class="token function">tar</span> zxvf frp_0.24.1_linux_amd64.tar.gz</code></pre><ol start="2"><li><p>进入解压好的目录，编辑 frp 服务器端配置文件 <strong>frps.ini</strong>。</p><pre class=" language-ini"><code class="language-ini"><span class="token selector">[common]</span><span class="token constant">bind_port</span> <span class="token attr-value"><span class="token punctuation">=</span> 7000             #frp 绑定的端口</span><span class="token constant">vhost_http_port</span> <span class="token attr-value"><span class="token punctuation">=</span> 8000       #http 访问端口</span></code></pre><ol start="3"><li>启动服务端 frp</li></ol><pre class=" language-bash"><code class="language-bash">./frps -c ./frps.ini</code></pre></li></ol><h2 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h2><p>在域名服务商配置域名解析，将域名解析到上面的服务器 ip 地址上。</p><h2 id="配置-nginx-反向代理进行-frp-端口的转发"><a href="#配置-nginx-反向代理进行-frp-端口的转发" class="headerlink" title="配置 nginx 反向代理进行 frp 端口的转发"></a>配置 nginx 反向代理进行 frp 端口的转发</h2><ol><li>配置 nginx </li></ol><pre class=" language-nginx"><code class="language-nginx"><span class="token keyword">server</span> <span class="token punctuation">{</span>    <span class="token keyword">listen</span> <span class="token number">80</span><span class="token punctuation">;</span>    <span class="token keyword">server_name</span> wx<span class="token punctuation">.</span>domain<span class="token punctuation">.</span>com<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 绑定域名</span>    <span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">{</span>        <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token punctuation">:</span><span class="token number">8000</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 转发至本机8000,即在frps.ini中配置>的vhost_http_port</span>        <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Real<span class="token operator">-</span>IP <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> Host <span class="token variable">$host</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Forwarded<span class="token operator">-</span>For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol start="2"><li>重启 nginx</li></ol><h2 id="本地端配置"><a href="#本地端配置" class="headerlink" title="本地端配置"></a>本地端配置</h2><blockquote><p> 本地使用的是 vagrant 虚拟机。使用的同样是 centOS6-x64。在配置 frp 客户端之前需要将项目代码在 nginx 中正确配置，指定的域名就是上面解析的域名。</p></blockquote><ol><li>根据本地系统环境下载对应的  <a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">frp</a> 包。</li><li><p>编辑 frp 客户端配置文件 <strong>frpc.ini</strong>。</p><pre class=" language-ini"><code class="language-ini"><span class="token selector">[common]</span><span class="token constant">server_addr</span> <span class="token attr-value"><span class="token punctuation">=</span> x.x.x.x     #frps 所在的服务器的 IP</span><span class="token constant">server_port</span> <span class="token attr-value"><span class="token punctuation">=</span> 7000        #frps 绑定的端口</span><span class="token constant">use_encryption</span> <span class="token attr-value"><span class="token punctuation">=</span> true     #将 frpc 与 frps 之间的通信内容加密传输，将会有效防止流量被拦截。 </span><span class="token constant">use_compression</span> <span class="token attr-value"><span class="token punctuation">=</span> true     # 对传输内容进行压缩，可以有效减小 frpc 与 frps 之间的网络流量，加快流量转发速度，但是会额外消耗一些 cpu 资源。</span><span class="token selector">[web]</span><span class="token constant">type</span> <span class="token attr-value"><span class="token punctuation">=</span> http</span><span class="token constant">local_port</span> <span class="token attr-value"><span class="token punctuation">=</span> 80   #为本地机器上 web 服务对应的端口</span><span class="token constant">custom_domains</span> <span class="token attr-value"><span class="token punctuation">=</span> wx.domain.com   #上一步中解析好的域名</span></code></pre></li></ol><ol start="3"><li>启动 frp 客户端<pre class=" language-bash"><code class="language-bash">./frpc -c ./frpc.ini</code></pre></li></ol><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>如果一切正常那么现在随便找一台设备，访问刚才的域名就可以访问到本地的项目了。</p>]]></content>
      
      
      <categories>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> frp </tag>
            
            <tag> 开发环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 各种锁的理解</title>
      <link href="/2019/02/14/%E5%90%84%E7%A7%8D%E9%94%81%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2019/02/14/%E5%90%84%E7%A7%8D%E9%94%81%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>之前总是听说 MySQL 中的锁，一直没有具体的看过，晚上抽了空看了一点就先记录了下来，后面有机会在补充。</p></blockquote><h2 id="为什么需要锁"><a href="#为什么需要锁" class="headerlink" title="为什么需要锁"></a>为什么需要锁</h2><p>因为数据库是一个多用户共享的资源，也就是任何人都可以访问数据。当有一个商品表库存为1，当一个用户购买该商品的时候，首先需要查询商品的库存。如果一个人请求是没有任何问题的。但是当两个用户同时购买该商品的时候由于时间比较接近，当第一个用户查询完商品还未进行更新库存的时候，第二个用户就进来了，由于库存还没有更新，所以该用户也可以下单成功。最终将导致库存为-1，破幻了数据的一致性。为了解决这问题才有个锁的概念。</p><h2 id="有哪些锁"><a href="#有哪些锁" class="headerlink" title="有哪些锁"></a>有哪些锁</h2><ul><li>锁的类型<ul><li>读锁</li><li>写锁</li></ul></li><li>锁的粒度<ul><li>行锁</li><li>表锁</li></ul></li><li>持有锁的时间<ul><li>临时锁</li><li>持续锁</li></ul></li></ul><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><blockquote><p>说到锁那么接下来就需要了解隔离级别，了解隔离级别就需要了解数据库的四要素。</p></blockquote><h3 id="数据库四要素（ACID）"><a href="#数据库四要素（ACID）" class="headerlink" title="数据库四要素（ACID）"></a>数据库四要素（ACID）</h3><ul><li>原子性（Atomicity）：要么全部完成，要么全 <strong>不</strong> 完成。</li><li>一致性（Consistency）：一个事务单元提交后才可以被其他事务查看到。</li><li>隔离性（Isolation）：并发事务之间不相互影响。<em>设立了不同的隔离级别，通过适度破坏一致性来提高性能</em></li><li>持久性（Durability）：事物提交之后即持久化到磁盘中不会丢失。</li></ul><p><em><strong>锁只是实现隔离级别的几种方式之一，除了锁，实现并发问题的方式还有时间戳，多版本控制等等，这些也可以称为无锁的并发控制。</strong></em></p><h3 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h3><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> @<span class="token variable">@tx_isolation</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">#查询当前隔离级别</span><span class="token keyword">select</span> @<span class="token variable">@global.tx_isolation</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">#查询全局隔离级别</span><span class="token keyword">set</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation level</span> <span class="token keyword">read</span> <span class="token keyword">uncommitted</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">#设置当前隔离级别为 RU</span><span class="token keyword">set</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation level</span> <span class="token keyword">read</span> <span class="token keyword">committed</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">#设置当前隔离级别为 RC</span><span class="token keyword">set</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation level</span> <span class="token keyword">repeatable</span> <span class="token keyword">read</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">#设置当前隔离级别为 RR</span><span class="token keyword">set</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation level</span> <span class="token keyword">serializable</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">#设置当前隔离级别为 RS</span></code></pre><ul><li>读未提交（Read Uncommitted）：事务的读不阻塞其他事务的读和写，事务的写只阻塞其他事务的写，但不阻塞读。<strong>通过对写操作加“持续 X 锁”，对读操作不加锁实现。</strong></li><li>读已提交（Read Committed）：事务的读不阻塞其他事务的读和写，事务的写也会阻塞其他事务的读和写。<strong>通过对写操作加“持续 X 锁”，对读操作加“临时 S 锁”实现。</strong></li><li>可重复读（Repeatable Read）：事务的读会阻塞其他事务的写，但不阻塞读。事务的写会阻塞其他事务的读和写。<strong>通过对写操作加“持续 X 锁”，对读操作加“持续 S 锁”实现。</strong></li><li>序列化（Serializable）：最安全的一种级别，不会出现脏读、不可重复读、幻读问题。但是可能会导致大量的超时现象和锁竞争。<strong>使用的是表级锁</strong></li></ul><h3 id="可能产生的问题"><a href="#可能产生的问题" class="headerlink" title="可能产生的问题"></a>可能产生的问题</h3><p><img src="http://static.xiangdangnian.net.cn/blog/WX20190219-093153@2x.png" alt="WX20190219-093153@2x.png"></p><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>公司发工资，打了10000万到我的账户，但是该事务没有提交。这时我正好查看账户，发现10000元已经到账，非常开心。可以公司这时又发现发错了，于是回滚事务，修改金额为5000，然后提交事务。最终我实际得到的工资只有5000，空欢喜一场。</p><blockquote><p>这就是脏读，两个并发的事务，其中一个读取到了另一个没有提交的数据。</p></blockquote><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>拿着刚发的工资去买本书看看，付钱时系统读到我卡里有5000元，然而此时女友也拿着我的卡在消费，并花完了卡里的钱，并在我之前提交了事务，当我这边进行扣款的时候系统发现卡里没有钱了，提示扣款失败。我就十分纳闷，明明有钱啊，怎么。。。</p><blockquote><p> 这就是不可重复读，两个并发事务，在一个事务中读取到另一个事务中提交了的结果，第一事务在第二个事务提交前和提交后查看到的结果不一致。（主要是针对更新和删除操作）<strong>当隔离级别设置为Read committed时，避免了脏读，但是可能会造成不可重复读。</strong></p></blockquote><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>我又一个计划任务表，当前为空的。在第一个事务中我查看所有任务显示为空。这时女友在另一个事务增加了一条任务“早上起床做早饭”，并提交了事务。这是我又查看了一下所有任务发现还是空的，我就准备加一个任务“早上起床做早饭”，可是这时却提示我错误。我就纳了闷了，明明没有数据啊，怎么不让我加呢？难道出现了幻觉？</p><blockquote><p>这就是幻读。第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。（主要针对新增操作）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现负载均衡</title>
      <link href="/2019/01/27/%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/2019/01/27/%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="http://static.xiangdangnian.net.cn/blog/2019-01-273.56.02.png" alt="架构图"></p><blockquote><p>简介： 用户访问负载均衡服务器，负载均衡服务器将相应的请求转发至应用服务器APP1或APP2。当前其中一台应用服务器down调的时候，负载均衡服务器将会把请求转发至另一台正常的服务器上。</p></blockquote><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="安装负载均衡服务器"><a href="#安装负载均衡服务器" class="headerlink" title="安装负载均衡服务器"></a>安装负载均衡服务器</h3><h4 id="安装并启动-nginx-或使用-jellybool-的-sh-脚本"><a href="#安装并启动-nginx-或使用-jellybool-的-sh-脚本" class="headerlink" title="安装并启动 nginx (或使用 jellybool 的 sh 脚本)"></a>安装并启动 nginx (<a href="https://github.com/JellyBool/laravel-server-script/blob/master/laravel-nginx-proxy-server.sh" target="_blank" rel="noopener">或使用 jellybool 的 sh 脚本</a>)</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> update<span class="token function">sudo</span> LC_ALL<span class="token operator">=</span>en_US.UTF-8 add-apt-repository ppa:nginx/development -y<span class="token function">sudo</span> <span class="token function">apt-get</span> update<span class="token function">sudo</span> <span class="token function">apt-get</span> -y <span class="token function">install</span> nginx<span class="token function">sudo</span> <span class="token function">cp</span> /etc/nginx/sites-available/default /etc/nginx/sites-available/default.bak<span class="token function">sudo</span> <span class="token function">service</span> nginx start</code></pre><h4 id="配置-nginx-服务器为负载均衡服务器"><a href="#配置-nginx-服务器为负载均衡服务器" class="headerlink" title="配置 nginx 服务器为负载均衡服务器"></a>配置 nginx 服务器为负载均衡服务器</h4><pre class=" language-nginx"><code class="language-nginx"><span class="token keyword">upstream</span> backend <span class="token punctuation">{</span>    <span class="token keyword">server</span> pravite<span class="token operator">-</span>ip<span class="token operator">-</span>address<span class="token number">-1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">#应用服务器ip地址</span>    <span class="token keyword">server</span> pravite<span class="token operator">-</span>ip<span class="token operator">-</span>address<span class="token number">-2</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">#应用服务器ip地址</span><span class="token punctuation">}</span><span class="token keyword">server</span> <span class="token punctuation">{</span>    <span class="token keyword">listen</span> <span class="token number">80</span> default_server<span class="token punctuation">;</span>    <span class="token keyword">listen</span> <span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token number">80</span> default_server<span class="token punctuation">;</span>    <span class="token keyword">server_name</span> nuli<span class="token punctuation">.</span>io www<span class="token punctuation">.</span>nuli<span class="token punctuation">.</span>io<span class="token punctuation">;</span>    <span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">{</span>        <span class="token keyword">add_header</span> X<span class="token operator">-</span>Content<span class="token operator">-</span>Type<span class="token operator">-</span>Options nosniff<span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Scheme <span class="token variable">$scheme</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Real<span class="token operator">-</span>IP <span class="token variable">$remote_addr</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>Forwarded<span class="token operator">-</span>For <span class="token variable">$proxy_add_x_forwarded_for</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> Host <span class="token variable">$http_host</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_set_header</span> X<span class="token operator">-</span>NginX<span class="token operator">-</span><span class="token keyword">Proxy</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">proxy_hide_header</span> X<span class="token operator">-</span>Powered<span class="token operator">-</span>By<span class="token punctuation">;</span>        <span class="token keyword">proxy_hide_header</span> Vary<span class="token punctuation">;</span>        <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>backend<span class="token punctuation">;</span>        <span class="token keyword">proxy_redirect</span> off<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="检测-nginx-配置并重启-nginx-服务"><a href="#检测-nginx-配置并重启-nginx-服务" class="headerlink" title="检测 nginx 配置并重启 nginx 服务"></a>检测 nginx 配置并重启 nginx 服务</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> nginx -t<span class="token function">sudo</span> <span class="token function">service</span> nginx reload</code></pre><h3 id="安装应用服务器-APP1"><a href="#安装应用服务器-APP1" class="headerlink" title="安装应用服务器 APP1"></a>安装应用服务器 APP1</h3><h4 id="安装-nginx-和-php-以及-php-扩展-或使用-jellybool-的-sh-脚本"><a href="#安装-nginx-和-php-以及-php-扩展-或使用-jellybool-的-sh-脚本" class="headerlink" title="安装 nginx 和 php 以及 php 扩展  或使用 jellybool 的 sh 脚本"></a>安装 nginx 和 php 以及 php 扩展  <a href="https://github.com/JellyBool/laravel-server-script/blob/master/laravel-app-server.sh" target="_blank" rel="noopener">或使用 jellybool 的 sh 脚本</a></h4><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> update<span class="token function">sudo</span> <span class="token function">apt-get</span> -y <span class="token function">install</span> zsh <span class="token function">htop</span> <span class="token function">zip</span> unzip composer<span class="token function">sudo</span> LC_ALL<span class="token operator">=</span>en_US.UTF-8 add-apt-repository ppa:nginx/development -y<span class="token function">sudo</span> <span class="token function">apt-get</span> update<span class="token function">sudo</span> <span class="token function">apt-get</span> -y <span class="token function">install</span> nginx<span class="token function">sudo</span> <span class="token function">service</span> nginx start<span class="token function">sudo</span> LC_ALL<span class="token operator">=</span>en_US.UTF-8 add-apt-repository ppa:ondrej/php -y<span class="token function">sudo</span> <span class="token function">apt-get</span> update<span class="token function">sudo</span> <span class="token function">apt-get</span> -y <span class="token function">install</span> php7.2<span class="token function">sudo</span> <span class="token function">apt-get</span> -y <span class="token function">install</span> php7.2-mysql<span class="token function">sudo</span> <span class="token function">apt-get</span> -y <span class="token function">install</span> php7.2-fpm<span class="token function">sudo</span> <span class="token function">apt-get</span> -y <span class="token function">install</span> php7.2-curl php7.2-xml php7.2-json php7.2-gd php7.2-mbstring php7.2-bcmath<span class="token function">sudo</span> <span class="token function">service</span> php7.2-fpm restart<span class="token function">sudo</span> <span class="token function">cp</span> /etc/nginx/sites-available/default /etc/nginx/sites-available/default.bak</code></pre><h3 id="安装应用服务器-APP2-同-APP1"><a href="#安装应用服务器-APP2-同-APP1" class="headerlink" title="安装应用服务器 APP2 (同 APP1)"></a>安装应用服务器 APP2 (同 APP1)</h3><h3 id="测试负载均衡"><a href="#测试负载均衡" class="headerlink" title="测试负载均衡"></a>测试负载均衡</h3><ol><li>在 APP1 服务器上的 <code>/var/www/html</code> 目录下将 <code>index.html</code>文件内容更改为 APP1。</li><li>在 APP2 服务器上的 <code>/var/www/html</code> 目录下将 <code>index.html</code>文件内容更改为 APP2。</li><li>访问负载均衡服务器 ip 地址或配置的域名。此时页面将交替显示 APP1 和 APP2 。~~~成功。</li></ol><h3 id="使用-Envoy-将-Laravel-项目同时部署在所有负载均衡的机器上"><a href="#使用-Envoy-将-Laravel-项目同时部署在所有负载均衡的机器上" class="headerlink" title="使用 Envoy 将 Laravel 项目同时部署在所有负载均衡的机器上"></a>使用 Envoy 将 Laravel 项目同时部署在所有负载均衡的机器上</h3><ol><li>在本机上创建 Laravel 项目</li><li>将项目提交到 coding 或 github 上</li><li>配置 coding 或 github 的ssh （可选）</li><li>使用 ssh 或 https 的方式将项目部署到 APP1 和 APP2 服务器上</li><li>配置两台服务器的 .env 文件 <strong><strong>保证两台服务器的 APP_KEY 要一直</strong></strong></li><li>测试——<em>访问负载均衡服务器可以看到 Laravel 欢迎语</em></li><li>在本机中的 Laravel 项目中安装 Envoy 扩展  <a href="https://laravel-china.org/docs/laravel/5.7/envoy/2307" target="_blank" rel="noopener">参考文档</a></li><li>在项目根目录新增 <code>Envoy.blade.php</code> 文件并在文件中增加如下内容。「需要注意的是：本机可以通过 ssh 的方式访问对应的服务器」</li></ol><pre class=" language-php"><code class="language-php">@<span class="token function">servers</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'web-1'</span>  <span class="token operator">=</span><span class="token operator">></span>  <span class="token string">'ssh root@192.168.3.11'</span><span class="token punctuation">,</span> <span class="token string">'web-2'</span>  <span class="token operator">=</span><span class="token operator">></span>  <span class="token string">'ssh root@192.168.3.11'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>@<span class="token function">task</span><span class="token punctuation">(</span><span class="token string">'deploy'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'on'</span>  <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token string">'web-1'</span><span class="token punctuation">,</span> <span class="token string">'web-2'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'parallel'</span>  <span class="token operator">=</span><span class="token operator">></span>  <span class="token boolean">true</span><span class="token punctuation">]</span><span class="token punctuation">)</span>cd <span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>www<span class="token operator">/</span>laravel<span class="token operator">-</span>deploy   sudo git pull origin master@endtask</code></pre><ol start="9"><li>运行部署命令 <code>envoy run deploy</code>,如果输出内容没有错误的话，就表示部署成功，就可以在负载均衡服务器上进行查看了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> nginx </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CGI, Fast-CGI，PHP-CGI，PHP-FPM 几个概念的总结</title>
      <link href="/2019/01/24/cgi-fast-cgi-php-cgi-php-fpm%E7%90%86%E8%A7%A3-md/"/>
      <url>/2019/01/24/cgi-fast-cgi-php-cgi-php-fpm%E7%90%86%E8%A7%A3-md/</url>
      
        <content type="html"><![CDATA[<blockquote><p>2020-2-6 更新</p></blockquote><p><strong> 最近又看到一篇<a href="https://segmentfault.com/q/1010000000256516" target="_blank" rel="noopener">文章</a>，讲解的非常到位，在更正一下之前的结论  </strong></p><ol><li><p>cgi、fast-cgi 都是协议，规定了 web server 需要传递那些数据给 php 解释器。他们的区别是 cgi 每次都需要加载配置文件来初始化，而 fast-cgi 会先启一个master，解析配置文件，初始化执行环境，然后再启动多个worker。当请求过来时，master会传递给一个worker，然后立即可以接受下一个请求。这样就避免了重复的劳动，效率自然是高。</p></li><li><p>php-cgi 相当于 php 的一个解释器是一个具体的程序，也就是系统中的进程。而 php-fpm 是一个实现了 fast-cgi 的具体程序，用来管理 php-cgi 进程。</p></li></ol><hr><blockquote><p>2019-6-27 更新</p></blockquote><p><strong> 最近又看到了类似的文章，发现之前记录的好像是不太对。现在也不知道哪个是正确的，就都先记下来吧。</strong> </p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol><li>CGI、FastCGI 只是PHP的的运行方式。其他的还有APACHE2HANDLER、CLI 方式。</li><li>PHP-FPM（FastCGI Process Manager） 只是 FastCGI 的进程管理器。</li><li>PHP-CGI 只是 Fast-CGI 的子进程。</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.jb51.net/article/62554.htm" target="_blank" rel="noopener">php 的4种常见运行方式</a></p><hr><blockquote><p>在开始学php的时候有几个概念一直没有弄明白，最近查了些资料，特此补充记录一下，以防忘记。有不对的地方还请高手指点。</p></blockquote><h2 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h2><ul><li>CGI：WEB 服务器与 WEB 应用程序之间交换数据的一种协议。</li><li>FastCGI：同 CGI 一样，也是一种协议，只是在效率上比 CGI 好一些。</li><li>PHP-CGI：fastCGI 协议的一种实现。(也就是 php 可执行目录下的php-cgi程序)。他有2个问题。<ul><li>更改配置文件后无法平滑重启。</li><li>无法动态调整进制多少。</li></ul></li><li>spawn-fcgi：解决了 php-cgi 出现的问题。但器仅仅是一个进程管理器。</li><li>PHP-FPM：实现了 Fast-CGI 协议并且之前平滑重启，同时还带有进程管理功能。</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.ietf.org/rfc/rfc3875" target="_blank" rel="noopener">CGI 协议内容</a></p><p><a href="http://andylin02.iteye.com/blog/648412" target="_blank" rel="noopener">Fast-CGI 协议内容</a></p><p><a href="http://yongxiong.leanote.com/post/%E4%BB%8ECGI%E5%88%B0FastCGI%E5%88%B0PHP-FPM" target="_blank" rel="noopener">从CGI到FastCGI到PHP-FPM</a></p><p><a href="https://www.awaimai.com/371.html" target="_blank" rel="noopener">CGI、FastCGI和PHP-FPM关系图解</a></p>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇文章</title>
      <link href="/2019/01/21/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2019/01/21/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="我的第一篇文章"><a href="#我的第一篇文章" class="headerlink" title="我的第一篇文章"></a>我的第一篇文章</h1><blockquote><p>这是我的第一篇文章，主要记录一下hexo博客的建立和使用方法。</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/HarleyWang93/blog/issues/1" target="_blank" rel="noopener">搭建参考</a></p><p><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">主题配置</a></p><h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><ol><li>需要安装git和Node.js</li><li>注册Github账号</li></ol><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><ol><li><p>使用npm全局安装hexo</p><pre class=" language-yaml"><code class="language-yaml">sudo npm install <span class="token punctuation">-</span>g hexo<span class="token punctuation">-</span>cli</code></pre></li><li><p>使用hexo init 初始化项目</p><pre class=" language-yaml"><code class="language-yaml">hexo init blog</code></pre></li><li><p>使用hexo s查看状态(默认访问该地址<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000 </a>)</p><pre class=" language-yaml"><code class="language-yaml">hexo s</code></pre></li></ol><h3 id="关联Github"><a href="#关联Github" class="headerlink" title="关联Github"></a>关联Github</h3><ol><li>创建仓库</li><li>开启Github Pages</li><li>选择分支</li></ol><h3 id="修改全局配置-注意：每个冒号后面都有个空格"><a href="#修改全局配置-注意：每个冒号后面都有个空格" class="headerlink" title="修改全局配置(注意：每个冒号后面都有个空格)"></a>修改全局配置(注意：每个冒号后面都有个空格)</h3><p>在项目中找到_config.yml文件，在文件最后添加如下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span> git    <span class="token key atrule">repository</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//github.com/xxx/xxx.github.io.git  <span class="token key atrule">branch</span><span class="token punctuation">:</span> master</code></pre><h3 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a>生成静态页面</h3><ol><li>执行生成静态文件命令</li></ol><pre class=" language-yaml"><code class="language-yaml">hexo g</code></pre><ol start="2"><li>安装git上传插件</li></ol><pre class=" language-yaml"><code class="language-yaml">npm install hexo<span class="token punctuation">-</span>deployer<span class="token punctuation">-</span>git <span class="token punctuation">-</span><span class="token punctuation">-</span>save</code></pre><ol start="3"><li>执行上传静态文件命令</li></ol><pre class=" language-yaml"><code class="language-yaml">hexo d</code></pre><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><pre><code>hexo new &quot;文章标题&quot;         //新建文章hexo new page &quot;页面名&quot;      //新建页面hexo g                     //生成静态文件至public目录hexo server                //开启本地访问hexo deploy                //部署到github</code></pre><h2 id="主题使用"><a href="#主题使用" class="headerlink" title="主题使用"></a>主题使用</h2><blockquote><p>具体详细内容查看项目链接 <a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">hexo-theme-matery</a></p></blockquote><h3 id="文章头部示例"><a href="#文章头部示例" class="headerlink" title="文章头部示例"></a>文章头部示例</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-07 09:25:00</span><span class="token key atrule">author</span><span class="token punctuation">:</span> 赵奇<span class="token key atrule">img</span><span class="token punctuation">:</span> /source/images/xxx.jpg <span class="token comment" spellcheck="true"># 或者:http://xxx.com/xxx.jpg</span><span class="token key atrule">top</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true"># 如果top值为true，则会是首页推荐文章</span><span class="token comment" spellcheck="true"># 如果要对文章设置阅读验证密码的话，就可以在设置password的值，该值必须是用SHA256加密后的密码，防止被他人识破</span><span class="token key atrule">password</span><span class="token punctuation">:</span> 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92<span class="token comment" spellcheck="true"># 本文章是否开启mathjax，且需要在主题的_config.yml文件中也需要开启才行</span><span class="token key atrule">mathjax</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">categories</span><span class="token punctuation">:</span> Markdown<span class="token key atrule">tags</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> Typora  <span class="token punctuation">-</span> Markdown<span class="token punctuation">---</span></code></pre><blockquote><ol><li>如果img属性不填写的话，文章特色图会根据文章标题的hashcode的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。</li><li>date的值尽量保证每篇文章是唯一的，因为本主题中Gitalk和Gitment识别id是通过date的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在Front-matter中设置采用了SHA256加密的password的值，还需要在主题的_config.yml中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
